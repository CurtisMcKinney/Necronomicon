coolPattern :: Event Audio
coolPattern = pattern times values
    where
        times  = seq [0.25, 0.5, 0.25]
        values = seq [countUp, mouseX |> take 1, countDown]

mouseX    = {0, 100, 200..N*100}
countUp   = {1,2}
countDown = { -1, -2 }

-- Embed coeffects DIRECTLY into language, akin to two ways of approaching monads,
-- as presented by Moggi and coeffects thesis

-- coolPattern used in context 1:
stream time = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
item  time  = { 0, 1, 0,    0,  1, 0, 1,   0,  0,  1 }
globaltime  = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
values      = { 1, 2, 200, -1, -2, 1, 2, 700, -1, -2 }

-- coolPattern used in context 2:
stream  time = { 0, 1, 2,    3,  4,  5,  6,    7,  8,  9 }
item  time   = { 0, 1, 0,    0,  1,  0,  1,    0,  0,  1 }
global time  = { 5, 6, 7,    8,  9, 10, 11,   12, 13, 14 }
values       = { 1, 2, 700, -1, -2,  1,  2, 1200, -1, -2 }

-- Cool, semantically that works, but how does this affect
-- reuse and variable binding?
-- Values are now associated with a context comprised of TWO time streams: static time and dynamic time
-- Static time is the time of the scope where the was value declared.
-- Dynamic time is the time of the scope where the value is being used.
-- Thus when a value is constructed it is can be stored as such:
-- coolPattern 1: [(0, 0), (1, 1), (2, 2)]
-- coolPattern 2: [(0, 5), (1, 6), (2, 7)]
-- The semantics are still pure as multiple accesses to the same stream within the same context
-- always provide the same result

-- Ok, but does that work with feedback:
countUp    = {1,2}
countDown  = {9,8}
mouseX     = {0, 100, 200..N*100}

feedBack    = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {0, 1, 2, 3, 4, 5}
values      = {1, 2, 9, 8, 1, 2}

feedBack2   = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {5, 6, 7, 8, 9, 10}
values      = {1, 2, 9, 8, 1, 2}

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

noFeedback  = seq [countUp, mouseX |> take 1, countDown]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

-- New idea:
-- Use Monad to enforce current value, everything else is a pure lazy stream.
-- No need for keeping track of "Contexts" or clocks
-- Needs garbage collection, but naturally handles feed back, cycles, and "current" values
-- Prevents top level "current" computations
-- Resolves ambiguity of "current" value times (value is from the time at which it was bound)
-- Enforces purity (the current value is bound to a single value which can be shared).
-- Don't need to record entire history of inputs
-- Feeback can still cause large thunk chains, but I think this is fine and akin to needing to understand that foldr can blow up on infinite lists
-- Need to check against global time of cached value in thunk?!?!?!!?

current :: CurrentMonad m => a -> m a

semantics then become:
data Stream a = Stream  (Maybe a) (StreamState -> Stream a) --value, next, StreamState
              | End
              | Constant a


-- | Current IORef a

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
noFeedback  = seq [countUp, mouseX |> take 1, countDown]

countDownBase = Stream 9 (Stream 8 End)

next :: Stream a -> (a, Stream a)
next = undefined

mkSequence :: Array (Stream a) -> Stream a
mkSequence streams = sequence 0 streams (Array.empty (Array.size streams))
    where
        sequence index streams newStreams =

take :: Stream a -> Stream Int -> Stream a
take stream numStream = go stream ystream 0
    where
         go (Stream streamVal streamCont) (Stream numVal numCont) count = if count >= numVal
            then Stream Nothing          (go streamCont numCont 0)
            else Stream (Just streamVal) (go streamCont numCont (count + 1))

countUp   = Stream (Just 1) (Stream (Just 2) End))
countDown = Stream (Just 9) (Stream (Just 8) End))
feedBack3 =

data StreamIO a = StreamIO (World -> (a, StreamIO (), World))

instance Monad StreamIO where
    x >>= f = StreamIO $ \world -> case demand x of
        (xVal, xCont) -> case f xVal of
            StreamIO ff -> case ff world of
                (gVal, gCont, world2) -> (gVal, xCont >> gCont, world2)

current :: Stream a -> StreamIO (Stream a)
current (Stream val cont) = StreamIO $ \world ->
    case mkCurrentRef val world of
        (ref, world2) -> let refStream     = Stream (Just (unsafeRead ref)) stream
                             refCont cont' = StreamIO (\world3 -> let (contVal, contCont) = demand cont' in let world4 = writeCurrentRef contVal in ((), refCont' contCont, world4))
                         in  StreamIO (refStream, refCont, world2)

data StreamIO x a = StreamIO (StreamState -> (a, x -> StreamIO a, StreamState))
data Stream   a   = Stream a (StreamIO () a)

instance Monad StreamIO where
    x >>= f = StreamIO $ \state ->
        let (xVal, xCont)         = demand x
            StreamIO sf           = f xVal
            (gVal, gCont, state') = sf state
        in (gVal, (xCont ()) >>= gCont, state')

-- Non-Strict, No Circular References, is it possible:
feedback = seq [0, 1 + feedback]

values   = {0, 1, 2, 3}
refs     = {[ref 0, ref 1 + ref feedback[0]]}

feedback[0] = Sequence ()

main :: IO () ()
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

-- Comonadic semantics for effects idea:
-- Comonadic do idea
-- Extraction is a safe opeartion in the main Necro Language
current :: a -> {a}

-- Injection is an unsafe operation in the main Necro language
-- constant :: {a} -> a -- UNSAFE!!!

rand :: Num a => a -> a -> {a}

(=>>) :: a -> (a -> {b}) -> b

sin 440 =>> current
sin 440 =>> simpleRand

main :: ()
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

randSynth :: Audio -> Audio -> {Audio}
randSynth low high = do
    r1 <- rand low high
    r2 <- rand low high
    r1 + r2 |> current

-equivalant to-

randSynth :: Audio -> Audio -> {Audio}
randSynth low' high' =
    (low'         =>> \low  ->
    high'         =>> \high ->
    rand low high =>> \r1   ->
    (rand low high |> \r2   ->
     current (r1 + r2)))

    current (coolSynth =>> \coolSynth' -> current coolSynth')
    current (rand l h  =>> \rand' -> current rand')

current :: Stream a -> a
current (Stream aVal aCont) = aVal

rand :: Stream Audio -> Stream Audio -> Audio
rand (Stream lowVal _ lowState) (Stream highVal _ highState) = genRandWithSeed (mergeRand lowState highState + 1)

instance Comonad Stream where
    current (Stream aVal _ _) = aVal
    stream =>> f = Stream (f stream) (cont stream =>> f)

-- Need State parameter for things like rand to get threaded through...how?
Store Comonad for State

()            \_     ->
rand 0 1  =>> \rand1 ->
rand 0 2  =>> \rand2 ->
coolSynth =>> \coolSynth' ->

randSynth :: Audio -> Audio -> {Audio}
randSynth low high = do
    r1 <- rand low high
    r2 <- rand low high
    current (r1 + r2)

randSynth :: Audio -> Audio -> {Audio}
randSynth low high =
    rand low high =>> (\r1 ->
    rand low high |>  (\r2 ->
    current (r1 + r2))

-- Like this things can actually be strict because the cont is hidden in a function
data Stream a = Stream a (\Int -> Stream) (Int -> Int) Int

instance Comonad Stream where
    current (Stream aVal _ _ _ _) = aVal
    (Stream val cont getter state) =>> f =

---------------------------------------------------------------------
-- Comonads approach 2: Comonadic effects on top of main language
type IO a = StreamIO StreamState a

main :: IO State -> ()
main = do (u)
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth (current sample1)) mouseX
        synth2 = poly1 tick       (synth (current sample2)) mouseY
        synths = synth 1 + synth2
    current audioOut 0 synths

loadSample :: String -> IO () -> AudioBuffer

audioOut :: Audio -> IO () -> ()
rand :: IO (Audio, Audio) -> Audio

-- rand :: Audio -> Audio -> IO Audio
-- rand low high = store (\state -> genRand low high state) initState

data IO s a = IO (s -> a) s
instance Function (IO s) where
    fmap f (IO g s) = IO (f . g) s

instance Comonad (IO s) where
    current   (IO g s) = g s
    duplicate (IO g s) = IO (IO g) (bumpSeed s)

---------------------------------------------------------------------
-- Monadic approach 3: Use Comonad Store under the hood

data Stream a = Stream a (Stream a)
data IO s a   = IO (s -> a -> a) (Stream s) (Stream a)

audioOut :: Stream Audio -> IO (Stream ())
load :: Stream String -> IO (Stream AudioBuffer)
rand :: Stream Audio -> Stream Audio -> IO (Stream Audio)

current :: Stream a -> IO (Stream a)
current (Stream aVal aCont) = IO (Constant aVal) aCont

rand :: Stream Audio -> Stream Audio -> IO (Stream Audio)

-- Split and merge state for random numbers
instance Monad IO where
    pure x = go
        where
            go = IO (\_ -> (x, go)) x
    IO xf xs xa >>= f = IO (fsa fs
        where
            xVal         = xf (current xs) (current xa)
            IO fsa fs fa = f xVal
            fsa xs fa = fsa' (IO xsa xCont)

---------------------------------------------------------------------
-- Comonads approach 3: Comonadic effects on top of main language with alternate do and api
type IO a = StreamIO StreamState a

main :: IO () -> ()
main = do ()
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth (current sample1)) mouseX
        synth2 = poly1 tick       (synth (current sample2)) mouseY
        synths = synth 1 + synth2
    current audioOut 0 synths

loadSample :: String -> IO () -> AudioBuffer
audioOut :: IO Audio -> ()
rand :: IO (Audio, Audio) -> Audio

data IO s a = IO (s -> a) s
instance Function (IO s) where
    fmap f (IO g s) = IO (f . g) s

instance Comonad (IO s) where
    current   (IO g s) = g s
    duplicate (IO g s) = IO (IO g) (bumpSeed s)

---------------------------------------------------------------------
-- Arrow approach to effects: Works but seems like overkill

audioOut :: IO Audio ()
load     :: IO String AudioBuffer
rand     :: IO (Audio, Audio) (Audio)
current  :: IO a a

main :: IO () ()
main = proc () -> do
    sample1 <- load -< "pulseDemon"
    sample2 <- load -< "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 -< synths

randSynth :: Audio Audio -> IO () Audio
randSynth low high = proc () -> do
    r1 <- rand -< (low, high)
    r2 <- rand -< (low, high)
    returnA -< r1 + r2

---------------------------------------------------------------------
-- Stream Monad approach: World Parameter fuxorz this idea, causes time and space leak

data World = World
data IO a  = IO (World -> (a, IO a, World))

instance Functor IO where
    pure x         = IO (\w -> (x, pure x, w))
    map  f (IO xw) = IO (\w -> let (x, xs, w') = xw w in (f x, map f xs, w'))

instance Monad IO where
    xs >>= f = IO diagonal (map f xs)
        where
            ioHead   (IO xw) w = let (xh, _, w') = xw w in (xh, w')
            ioTail   (IO xw)   = IO (\w -> let (_, IO xw', w') = xw w in xw' w')
            diagonal (IO xw) w = (h, IO diagonal (map ioTail ioss), w')
                where
                    (ios, ioss, w') = xw w
                    (h, w'')        = ioHead ios w'

instance Monad IO where
    xs >>= f = diagonal (map f xs)
        where
            ioHead (IO x _)        = x
            ioTail (IO _ xs)       = xs
            diagonal (IO ios ioss) = IO (ioHead ios) (diagonal (map ioTail ioss))

current :: Stream a -> IO (Stream a)
current (Stream aVal aCont) = IO (\w -> (Constant aVal, current aCont, w))

rand :: (Rand a) => Stream a -> Stream a -> IO (Stream a)
rand low high = IO go
    where
        g w = (nStream n, pure nStream, w')
            where
                (n, w') = genRand (streamHead low) (streamHead high) w
                nStream = Constant n

---------------------------------------------------------------------
-- Stream Monad approach: World Parameter fuxorz this idea, causes time and space leak
data World    = World
data Stream a = Stream a (Stream a)
data IO a     = IO (World -> (Stream a, World))

current :: Stream a -> IO (Stream a)
current stream = IO (\w -> (go stream, w))
    where
        go

---------------------------------------------------------------------
-- Streamed IO idea .... doesn't work, state gets wonky and if the value isn't used (such as with >>) the effect doesn't manifest

-- Monadic approaches also don't solve the problem of having lazy streams but still having access to "input" benign effects like mouse input as a pure stream

data World    = World
data Stream a = Stream a (Stream a)
data IO a     = IO (World -> a) World

current :: Stream a -> Stream (IO a)
current (Stream aVal aCont) = Stream (IO (\_ -> aVal)) (current aCont)

rand :: (Rand a) => Stream a -> Stream a -> Stream (IO a)
rand (Stream lowVal lowCont) (Stream highVal highCont) = Stream (IO (\w -> w))

load :: Stream String -> Stream (IO (Stream AudioBuffer))
load


-- Haskell-fied
type World    = Int
data Stream a = Stream a (Stream a)
data SIO a    = SIO (World -> a) World

mergeWorlds :: World -> World -> World
mergeWorlds w1 w2 = w1 + w2

initWorld :: World
initWorld = 0

runSIO :: SIO a -> a
runSIO (SIO sa s) = sa s

instance Functor SIO where
    fmap f (SIO sa s) = SIO (\s' -> let x = sa s' in f x) s

instance Applicative SIO where
    pure x = SIO (\_ -> x) initWorld
    (<*>)  = undefined

instance Monad SIO where
    return = pure;
    SIO sa s >>= f = SIO fsa initWorld
        where
            fsa s' = let SIO fsa' s'' = f (sa (mergeWorlds s s')) in fsa' s''

countSeed :: SIO Int
countSeed = SIO (\s -> s + 1) 1 -- initWorld of 1 will bump seed count by 1 when it merges with another world

---------------------------------------------------------------------
-- Comonadic IO on top Streams.....????

audioOut :: IO Audio -> ()
load :: IO String -> AudioBUffer
rand :: Num a => IO a -> IO a -> a
current :: IO a -> a

main :: IO () -> ()
main = do () =>
    -- how the fuck does this work???
    let sample1 = load "pulseDemon"
        sample2 = load "doomBlade"
        synth1  =  poly1 mouseClick (synth (current sample1)) mouseX
        synth2  =  poly1 tick       (synth (current sample2)) mouseY
    audioOut 0 synth

randSynth :: IO Audio -> IO Audio -> Audio
randSynth = do (low, high) =>
    r1 <- rand low high
    r2 <- rand low high
    current r1 + current r2

---------------------------------------------------------------------
-- Comonadic IO on top Streams 2???

audioOut   :: Int -> IO Audio -> ()
playBuffer :: IO AudioBuffer -> Audio
loadBuffer :: String -> IO () -> AudioBuffer
current    :: IO a -> a
rand       :: Num a => a -> a -> IO () -> a

main :: IO () -> ()
main = do(io)
    sample1 <- loadBuffer "pulseDemon" io
    sample2 <- loadBuffer "doomBlade" io
    synth1  <- poly1 mouseClick (synth sample1) mouseX
    synth2  <- poly1 tick       (synth sample2) mouseY
    synths  <- extract synth1 + extract synth2
    audioOut 0 synth

---------------------------------------------------------------------
-- Coeffects, using Indexed Comonads
(models both per-variable and whole context)

-- Linear Types vs Coeffects?!?!?!
-- Since we're already doing a comonadic translation, making them "Indexed" comonads might be simpler?!?! or is it?!?!

-- Bounded reuse
audioOut   :: Int -> Audio -> IO -o IO
playBuffer :: AudioBuffer -> Audio
loadBuffer :: String -o IO -o (AudioBuffer, IO)

-- Non-determinism
rand       :: Num a => a -> a -> IO -o (a, IO)
noise      :: Num a => a -> a -> IO -o (a, IO)
blur       :: Num a => a -> a -> Int -> (a -> a) -> IO -o (a, IO)

-- Bang notation a la' alms
"The pattern !cap bound by let marks cap
 as an “imperative variable,” which means
 that within its scope, functions applied to
 cap are expected to return a pair of their
 real result and the new version of cap.
 Alms transforms this code into the explicitly-threaded
 version above. Currently this transformation
 happens before type checking, which means that it
 cannot compromise soundness but also cannot exploit type in-
 formation."

-- Semantically this works well
-- Syntactically
-- Wait, how do demand rate semantics play into this!!?!?!?!
-- Linearity should prevent shenanigans?
-- current combinator / concept still needs to be banged out, but this seems like the most promising idea
-- Perhaps still Lucids idea, but use bind operator:
    currSynth <- sinOsc 440 * sinOsc 0.1

main :: IO -o IO
main !io = audioOut 0 synths io
    where
        sample1 = loadBuffer "pulseDemon" io
        sample2 = loadBuffer "doomBlade"  io
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

randSynth :: Audio -> Audio -> IO -o (Audio, IO)
randSynth low high !io = (b, io)
    where
        r1  = rand  low high io
        n   = noise low high io
        f x = x * r1 + n |> sinOsc
        b   = blur  low high 64 f io

currSynth :: Event Audio
currSynth = pattern ts vs
    where
        c <- sinOsc 440 * sinOsc 0.1
        ts = [0.5, 0.25, 0.25]
        vs = seq [0, 1, take 2 c]

=== Stream translation

-- Works perfectly since the impure actions can now manifest and share values in the regular stream scope
rand :: Stream a -> Stream a -> Stream IO -> Stream (a, IO)
rand (Stream lowVal _) (Stream highVal _) (Stream ioVal ioCont) = Stream (rVal, ioVal2) (rCont ioCont)
    where
        (rVal, ioVal2)                = genRand lowVal highVal ioVal
        rCont (Stream ioVal3 ioCont2) = Stream (rVal, ioVal3) (rCont ioCont2)

mainDriver :: (Stream IO -> Stream IO) -> IO -> (Stream IO -> StreamIO, IO)
mainDriver (Stream mainVal mainCont) io = (mainCont, streamHead (mainVal (Constant io)))

-- ???? Still needs to be worked out
currSynth :: Stream (Event Audio)
currSynth =
    where
        Stream cVal cCont = ...
        c                 = Stream (cVal `until` ???)
        currSynthBody c   = ...

//=====================================================
// Stream Bind
//=====================================================
data Stream a = Stream a (Stream a)
data World    = World
data IO a     = IO (World -> (a, World))

data IOC a    = IO (a -> World -> (a, World)) a

(>>=) :: Monad m => Stream (m a) -> Stream (a -> m b) -> Stream (m b)

instance Monad IO where
    return x                                = Constant (\w -> (x, w))
    Stream xVal xCont >>= Stream fVal fCont = Stream g (xCont >>= fCont)
        where


//=====================================================
// Continuation IO
//=====================================================
data Stream a = Stream a (Stream a)
data World    = World
data IO a     = IO ((a -> World) -> World)

instance Monad IO where
    return x    = IO (\k -> k a)
    IO xk >>= f = IO <| \k ->
        let

//=====================================================
// Ticked IO -- Now with ticked World Stream
//=====================================================
latch :: Event a -> a

data CoolState { x :: Int, y :: Int}

setX, setY :: Int -> CoolStateMonad ()
getX, getY :: CoolStateMonad Int

data CoolStateMonad a = CoolStateMonad (CoolState -> (a, CoolState))

instance Monad CoolStateMonad where
    return x                = CoolStateMonad (\s -> (a, s))
    CoolStateMonad xa >>= f = CoolStateMonad g where g s = ga s'
        where
            (x, s')           = xa s
            CoolStateMonad ga = f x

getX :: CoolStateMonad Int
getX = CoolStateMonad <| \s -> (global (x s), s)

setX :: Int -> CoolStateMonad ()
setX val = CoolStateMonad <| \s -> ((), s{x = val})

fby :: a -> a -> a
fby x y = <x0, y0, y1,...,xn> (primop)

next :: a -> a
next x  = <x1, x2, x3,...,xn> (primop)

first :: a -> a
first x = y
    where
        y = [x, y]

whenever :: a -> Bool -> a
whenever a b = if first b
    then [first a, whenever (next a) (next b)]
    else whenever (next a) (next b)

upon :: a -> Bool -> a
upon a b = [first a, a']
    where
        a' = if first b
            then upon (next a) (next b)
            else upon a        (next b)

-- Flowing a global time through everything breaks sharing, a no go
globalTime :: Int
globalTime = ... (primOp)

-- Lucid to the rescue?
-- This might need to be slightly more involved
global :: a -> a
global x = x `upon` (count == globalTime)
    where
        count = [0, count + 1]

coolMain :: CoolStateMonad ()
coolMain = do
    x <- getX
    let doubleTime = pattern twoToOne x |> latch
    doubleTime + 1 |> setX

runCoolStateMonad :: CoolStateMonad a -> CoolState -> a
runCoolStateMonad (CoolStateMonad f) state = f state

initState :: CoolState
initState = CoolState 0 0

runCoolMain :: CoolStateMonad ()
runCoolMain = state
    where
        state = runCoolStateMonad coolMain [initState, state]

-- Does this work!?!?!?!?

---------------------------------------------------------------------
-- Uniqueness Types (a la the paper Uniqueness Typing Simplified)

-- Bounded reuse
audioOut   :: Int -> Audio -> World* -> World*
loadBuffer :: String -> World* -> (AudioBuffer, World*)
playBuffer :: AudioBuffer -> Audio

-- Non-determinism
rand       :: Rand a => a -> a -> World* -> (a, World*)
noise      :: Rand a => a -> a -> World* -> (a, World*)
blur       :: Rand a => a -> a -> [(a -> a)] -> World* -> (a, World*)

-- Semantically this works well
-- Syntactically....?
-- Uniquness types prevent demand rate shenanigans on I/O
-- Another win is performance, Monads introduce more bloat on top of the language,
   whereas Uniqueness are much lighter weight (a word-sized object is tossed around) and even allows for things like in-place updates
-- current combinator / concept still needs to be banged out, but this seems like the most promising idea

-- No Sugar
main :: World* -> World*
main w = audioOut 0 synths w2
    where
        (sample1, w1) = loadBuffer "pulseDemon" w
        (sample2, w2) = loadBuffer "doomBlade"  w1
        synth1        = poly1 mouseClick (synth sample1) mouseX
        synth2        = poly1 tick       (synth sample2) mouseY
        synths        = synth1 + synth2

-- Bang notation a la' alms
"The pattern !cap bound by let marks cap
 as an “imperative variable,” which means
 that within its scope, functions applied to
 cap are expected to return a pair of their
 real result and the new version of cap.
 Alms transforms this code into the explicitly-threaded
 version above. Currently this transformation
 happens before type checking, which means that it
 cannot compromise soundness but also cannot exploit type in-
 formation."

-- Uniqueness bang notation, stolen from Alms programming language
main :: World* -> World*
main !w = audioOut 0 synths w
    where
        sample1 = loadBuffer "pulseDemon" w
        sample2 = loadBuffer "doomBlade"  w
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

randSynth :: Audio -> Audio -> World* -> (Audio, World*)
randSynth low high !w = b w
    where
        r1  = rand  low high w
        n   = noise low high w
        f x = x * r1 + n |> sinOsc
        b   = blur low high (repeat 64 f)

//=====================================================
//
//=====================================================
audioOut   :: Audio -> IO ()
loadBuffer :: String -> IO AudioBuffer
rand       :: Rand a => a -> a -> IO a
current    :: a -> IO a

main :: IO ()
main = do
    sample1 <- loadBuffer "pulseDemon"
    sample2 <- loadBuffer "doomBlade"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth1 + synth2
    audioOut 0 synths

//=====================================================
// Coeffects
//=====================================================
data Input  = LoadAudioBuffer String
            | Mouse Int Int
data Output = AudioOut Int Audio

-- Coeffects put requirements on the environment
-- "Indexed Comonads", are essentially type level monoids
   that you can perform type level operatios on and which contain information
   about the requirements on the context of your program.

audioOut   :: Audio {1|aout}-> ()
loadBuffer :: String {aload}-> AudioBuffer

-- Rand just seems effectful
rand       :: Rand a => a -> a -> IO a

-- Current? Carries around time offset? Or something!?
current    :: a -> IO a

main :: () -{_}-> ()
main _ = audioOut 0 synths
    where
        sample1 = loadBuffer "pulseDemon"
        sample2 = loadBuffer "doomBlade"
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

audioOut   :: Int -> Audio -> Output -> Output
loadBuffer :: String -> Input -> AudioBuffer

-- bido?

main :: Input -> Output
main input = audioOut 0 synths initOut
    where
        sample1 = loadBuffer "pulseDemon" input
        sample2 = loadBuffer "doomBlade"  input
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2