--------------------
-- Necro.Base
--------------------

-- Math constants
pi :: Floating a => a
pi = 3.1415926535897932384626433

twoPi :: Floating a => a
twoPi = pi * 2

twoOverPi :: Floating a => a
twoOverPi = 2 / pi

halfPi :: Floating a => a
halfPi = pi * 0.5

threeHalfPi :: Floating a => a
threeHalfPi = 3 * halfPi

fourOverPi :: Floating a => a
fourOverPi = 4 / pi

quarterPi :: Floating a => a
quarterPi = pi * 0.25

sixthPi :: Floating a => a
sixthPi = pi / 6

twelthPi :: Floating a => a
twelthPi = pi / 12

tanSixthPi :: Float
tanSixthPi = tanF64 sixthPi

tanTwelthPi :: Float
tanTwelthPi = tanF64 twelthPi

tau :: Floating a => a
tau = 2 * pi

recipPi :: Floating a => a
recipPi = 1 / pi

recipTau :: Floating a => a
recipTau = 1 / tau

recipTwoPi :: Floating a => a
recipTwoPi = recipTau

-- -- TODO: Move into tests!
-- data ETest1 a     = ETest1 (Maybe a)
-- data ETest2 a     = ETest2 (Bool, Maybe a)
-- data ETest3 a     = ETest3 (Maybe (Bool, Maybe a))
-- data T3feri a b c = T3feri (a, a) (b, b) (c, c)
-- data HKT  t a     = HKT  (t a)
-- data HTest  a b   = HTest (Maybe a) (Maybe b) (Either a b)
-- data HKT2 t a b   = HKT2 (t a b)

testAssertion :: Bool -> *World -> *World
testAssertion b w = primUndefined

panic :: UInt -> UInt
panic x = primUndefined

panicWithMessage :: Array n Char -> a
panicWithMessage msg =
  traceLn msg 1
  |> panic
  |> const primUndefined

boundsCheck :: UInt -> UInt -> UInt
boundsCheck index capacity =
  if index < capacity then index else
    index
    |> traceLn "bounds check FAILED:"
    -- |> trace "| "
    -- |> traceLn str
    |> trace "| index:    "
    |> traceLn index
    |> trace "| capacity: "
    |> traceLn capacity
    |> traceLn " "
    |> panic

-- testAndPrintAssertion :: (Print a, Eq a) => a -> a -> *World -> *World
-- testAndPrintAssertion x y w = testAssertion (x == y) <| printLn x w

boolToInt :: Bool -> Int
boolToInt b = primUndefined

id :: .a -> .a
id x = x

fst :: (.a, .b) -> .a
fst (x, _) = x

snd :: (.a, .b) -> .b
snd (_, y) = y

fst' :: (#.a, .b#) -> .a
fst' (#x, _#) = x

snd' :: (#.a, .b#) -> .b
snd' (#_, y#) = y

fst3 :: (.a, .b, .c) -> .a
fst3 (x, _, _) = x

snd3 :: (.a, .b, .c) -> .b
snd3 (_, y, _) = y

thd :: (.a, .b, .c) -> .c
thd (_, _, z) = z

fst3' :: (#.a, .b, .c#) -> .a
fst3' (#x, _, _#) = x

snd3' :: (#.a, .b, .c#) -> .b
snd3' (#_, y, _#) = y

thd' :: (#.a, .b, .c#) -> .c
thd' (#_, _, z#) = z

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

clamp :: Ord a => a -> a -> a -> a
clamp x low high =
  max (min x high) low

uncurry :: .(.a -> .b -> .c) -> (.a, .b) -> .c
uncurry f (x, y) = f x y

uncurry3 :: .(.a -> .b -> .c -> .d) -> (.a, .b, .c) -> .d
uncurry3 f (x, y, z) = f x y z

uncurry' :: .(.a -> .b -> .c) -> (#.a, .b#) -> .c
uncurry' f (#x, y#) = f x y

uncurry3' :: .(.a -> .b -> .c -> .d) -> (#.a, .b, .c#) -> .d
uncurry3' f (#x, y, z#) = f x y z

mouseX :: Int
mouseX = getMouseX ()

mouseY :: Int
mouseY = getMouseY ()

keyPress :: UInt
keyPress = getKeyPress ()

asTypeOf :: a -> a -> a
asTypeOf x _ = x

asTypeOfU :: *a -> *a -> (#*a, *a#)
asTypeOfU x y = (#x, y#)

doOnce :: (.a -> b) -> .a -> b
doOnce f x =
  case my of
    Just y -> y
    _      -> panicWithMessage "doOnce"
  where
    my ~ Nothing =
      case my of
        Nothing -> Just (f x)
        _       -> my

doOnce2 :: (.a -> .b -> c) -> .a -> .b -> c
doOnce2 f x y =
  case mout of
    Just out -> out
    _        -> panicWithMessage "doOnce2"
  where
    mout ~ Nothing =
      case mout of
        Nothing -> Just (f x y)
        _       -> mout

doOnce3 :: (.a -> .b -> .c -> d) -> .a -> .b -> .c -> d
doOnce3 f x y z =
  case mout of
    Just out -> out
    _        -> panicWithMessage "doOnce3"
  where
    mout ~ Nothing =
      case mout of
        Nothing -> Just (f x y z)
        _       -> mout

initial :: a -> a
initial x =
  case my of
    Just y -> y
    _      -> panicWithMessage "initial"
  where
    my ~ Nothing =
      case my of
        Nothing -> Just x
        _       -> my

fby :: Print a => a -> a -> a
fby x y =
  if isFirstTime <= 1 then x else y
  where
    isFirstTime ~ 0 = isFirstTime + 1

doFby :: (.a -> b) -> .a -> b -> b
doFby f x y =
  if isFirstTime <= 1 then f x else y
  where
    isFirstTime ~ 0 = isFirstTime + 1


-- TODO: take combinator?

----------------------
-- Bool
----------------------
data Bool = False | True

-- TODO: primitive for not
not :: .Bool -> .Bool
not b =
  case b of
    True  -> False
    False -> True

----------------------
-- Some Base Classes
----------------------

class Print a where
  print :: a -> *World -> *World

class Semigroup m where
  append :: m -> m -> m

class Semigroup m => Monoid m where
  mempty :: m

class Functor f where
  map :: (a -> b) -> f a -> f b

class UFunctor f where
  umap :: .(.a -> .b) -> f .a -> f .b

class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c
  map3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  map4 :: (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  -- TODO: map4, etc

class Functor f => Applicative f where
  pure :: a -> f a
  ap   :: f (a -> b) -> f a -> f b

class Applicative m => Monad m where
  bind :: m a -> (a -> m b) -> m b

class Applicative f => Alternative f where
  empty       :: f a
  alternative :: f a -> f a -> f a

-- TODO: Implement Bifunctor
-- class Bifunctor f where
--   bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
--   mapFst
--   mapSnd

-- TODO: Look into making this a UInt instead of an Int?
class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

unsafeToEnum :: Enum a => Int -> a
unsafeToEnum x =
  primUndefined

unsafeFromEnum :: Enum a => a -> Int
unsafeFromEnum x =
  primUndefined

class Foldable f where
  fold   :: Monoid m => f m -> m
  foldl  :: (.b -> a -> .b) -> .b -> .f a -> .b

class Eq a where
  eq  :: a -> a -> Bool
  neq :: a -> a -> Bool

class Eq a => Ord a where
  lt  :: a -> a -> Bool
  gt  :: a -> a -> Bool
  lte :: a -> a -> Bool
  gte :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a

class Default a where
  default :: a

printUInt :: UInt -> *World -> *World
printUInt u w = w

printInt :: Int -> *World -> *World
printInt i w = w

printFloat :: Float -> *World -> *World
printFloat i w = w

printChar :: Char -> *World -> *World
printChar c w = w

printTuple :: (Print a, Print b) => (a, b) -> *World -> *World
printTuple t w = case t of
  (a, b) -> print '(' w |> print a |> print ", " |> print b |> print ')'

printNewline :: *World -> *World
printNewline w = printChar '\n' w

instance Print UInt where
  print x w = printUInt x w

instance Print Int where
  print x w = printInt x w

instance Print Float where
  print x w = printFloat x w

instance Print Char where
  print x w = printChar x w

printLn :: Print a => a -> *World -> *World
printLn x w =
  printNewline (print x w)

trace :: Print a => a -> .b -> .b
trace x y =
  case print x primUndefined of
    _ -> y

traceLn :: Print a => a -> .b -> .b
traceLn x y =
  case printLn x primUndefined of
    _ -> y

traceLn2 :: (Print a, Print b) => a -> b -> b
traceLn2 x y =
  case print x primUndefined of
    w ->
      case printLn y w of
        _ -> y

----------------------
-- File IO
----------------------

data File = File

arrayLength :: NatVal n -> Array n a -> UInt
arrayLength n _ = natVal n

arrayLengthNatVal :: NatVal n -> Array n a -> NatVal n
arrayLengthNatVal n _ = n

-- arrayLengthU :: NatVal n -> .Array n a -> (#UInt, .Array n a#)
arrayLengthU n arr = (#natVal n, arr#)

arrayLengthFromIndex :: NatVal n -> Index n -> UInt
arrayLengthFromIndex n _ = natVal n

natValGetFrom :: f n -> NatVal n
natValGetFrom _ = NatVal

nextPowerOfTwoNatVal :: NatVal n -> NatVal (NatNextPowerOfTwo n)
nextPowerOfTwoNatVal _ = NatVal

unsafeArrayToPtr :: Array n .a -> Ptr .a
unsafeArrayToPtr a = primUndefined

deepCopyArray :: Array n a -> .Array n a
deepCopyArray arr = freezeArray arr2
  where
    arr2 =
      loop arr2 = unsafeEmptyArray () for i <- each do
        writeArray i (readArray i arr) arr2

-- TODO: Deep copy class, or perhaps "duplicate" class
-- This is a bit of a hack...
deepCopyAudio :: AudioFormat f => f Audio -> f Audio
deepCopyAudio cs =
  map f cs
  where
    f a =
      case a of
        AudioEnd     -> AudioEnd
        BlockRate b  -> BlockRate b
        AudioRate as ->
          let
            asv :: Array (NatDiv BlockSize 32) (FloatVec 32)
            asv = toFloatVecArray as
            as' =
              loop asv2 = unsafeEmptyArray () for i <- each do
                writeArray i (readArray i asv) asv2
          in
            as' |> freezeArray |> fromFloatVecArray |> AudioRate

unsafeOpenFile :: Ptr Char -> UInt -> *File
unsafeOpenFile fileName fileNameLength = primUndefined

openFile :: Array n Char -> *World -> (*File, *World)
openFile fileName w =
  (unsafeOpenFile (unsafeArrayToPtr fileName) (arrayLength NatVal fileName), w)

closeFile :: *File -> ()
closeFile f = primUndefined

writeIntToFile :: Int -> *File -> *File
writeIntToFile x f = primUndefined

writeUIntToFile :: UInt -> *File -> *File
writeUIntToFile x f = primUndefined

writeFloatToFile :: Float -> *File -> *File
writeFloatToFile x f = primUndefined

writeCharToFile :: Char -> *File -> *File
writeCharToFile x f = primUndefined

writeStringToFile :: Array n Char -> *File -> *File
writeStringToFile str file =
  loop f = file for i <- each do
    writeCharToFile (readArray i str) f

writePlot2DToFileOnce :: Array s Char -> Array n Float -> *World -> *World
writePlot2DToFileOnce name dat w0 =
  if epoch > 1 then
    w0
  else
    let
      (f0, w1) = openFile name w0
      f1       =
        loop f = f0 for i <- each do
          writeUIntToFile (indexToUInt i) f
          |> writeCharToFile ' '
          |> writeFloatToFile (readArray i dat)
          |> writeCharToFile '\n'
    in
      case closeFile f1 of
        _ -> printLn "Done writing file" w1
  where
    epoch ~ 0 = epoch + 1

----------------------
-- Numeric Hierarchy
----------------------
class Semiring a where
  zero :: a
  one  :: a
  add  :: a -> a -> a
  mul  :: a -> a -> a

class Semiring a => Ring a where
  sub     :: a -> a -> a
  fromInt :: Int -> a

class Ring a => DivisionRing a where
  recip :: a -> a

class Ring a => EuclideanRing a where
  div :: a -> a -> a
  rem :: a -> a -> a
  -- mod :: a -> a -> a

class (EuclideanRing a, DivisionRing a) => Field a where

-- class (Eq a, Ring a) => Num a where
class (Ring a) => Num a where
  abs      :: a -> a
  signum   :: a -> a
  copysign :: a -> a -> a

class (Num a, EuclideanRing a) => Integral a where
  -- quotient :: a -> a -> a

class (Num a, Field a) => Floating a where
  fromFloat :: Float -> a
  sqrt :: a -> a
  floor :: a -> a
  ceil :: a -> a
  truncate :: a -> a
  round :: a -> a

class Floating a => Trig a where
  sine     :: a -> a
  cosine   :: a -> a
  -- tan      :: a -> a
  -- asine    :: a -> a
  -- acosine  :: a -> a
  -- atan     :: a -> a
  atan2    :: a -> a -> a
  sineh    :: a -> a
  cosineh  :: a -> a
  -- tanh     :: a -> a
  -- asineh   :: a -> a
  -- acosineh :: a -> a
  -- atanh    :: a -> a
  -- atanh2   :: a -> a -> a
  exp      :: a -> a
  exp2     :: a -> a
  log      :: a -> a
  log10    :: a -> a
  log2     :: a -> a
  pow      :: a -> a -> a

  -- atan      :: a -> a
  -- floor'    :: Integral b => a -> b
  -- ceil'     :: Integral b => a -> b

-- toFloating :: (Num' a, Floating b) => a -> b
-- toFloating = fromRational' <. toRational


class Bits a where
  bitAnd         :: a -> a -> a
  bitNot         :: a -> a
  bitOr          :: a -> a -> a
  bitXor         :: a -> a -> a
  bitShiftLeft   :: a -> UInt -> a
  bitShiftRight  :: a -> UInt -> a -- logical right shift
  bitShiftRightA :: a -> UInt -> a -- arithmetic right shift
  bitReverse     :: a -> a
  toBits         :: a -> UInt
  fromBits       :: UInt -> a

bit :: UInt -> UInt
bit n = bitShiftLeft 1 n

sqr :: Semiring a => a -> a
sqr n = n * n

--------------------
-- ()
--------------------
-- TODO: Can't currently parse () in an instance head!
-- instance Eq () where
--   eq  _ _ = True
--   neq _ _ = False
--
-- instance Ord () where
--   lt  _ _ = False
--   gt  _ _ = False
--   lte _ _ = True
--   gte _ _ = True


--------------------
-- Bool
--------------------
instance Eq Bool where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Bool where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined
  min x y = primUndefined
  max x y = primUndefined

instance Semiring Bool where
  zero    = False
  one     = True
  add x y = x || y
  mul x y = x && y

instance Semigroup Bool where
  append x y = x || y

instance Monoid Bool where
  mempty = False

instance Default Bool where
  default = True


--------------------
-- Int
--------------------
instance Eq Int where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Int where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined
  min x y = primUndefined
  max x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Int where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Int where
  sub   x y = primUndefined
  fromInt x = x

instance EuclideanRing Int where
  div x y = primUndefined
  rem x y = primUndefined

instance Num Int where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x sign = (abs x) * (signum sign)

instance Integral Int where

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Default Int where
  default = 0

instance Enum Bool where
  toEnum   x = if x == 0 then False else True
  fromEnum x =
    case x of
      False -> 0
      _     -> 1

maxInt :: Int
maxInt = 9223372036854775807


--------------------
-- UInt
-- NOTE: that this is the traditional programming language concept of an unsigned integer (with its idiosyncrasies) and not the more mathematically defined set of Natural Numbers
--------------------
instance Eq UInt where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord UInt where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined
  min x y = primUndefined
  max x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring UInt where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring UInt where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance EuclideanRing UInt where
  div x y = primUndefined
  rem x y = primUndefined

instance Num UInt where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x _ = x

instance Integral UInt where

instance Bits UInt where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = x
  fromBits       x   = x

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Default UInt where
  default = 0

uintToInt :: UInt -> Int
uintToInt x = primUndefined

fromUInt :: Ring a => UInt -> a
fromUInt x = fromInt (uintToInt x)


--------------------
-- Float
--------------------
instance Eq Float where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Float where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined
  min x y = primUndefined
  max x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Float where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Float where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num Float where
  abs    x = primUndefined
  copysign x sign = primUndefined
  signum x = if x == 0 then 0 else copysign 1 x

instance EuclideanRing Float where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing Float where
  recip x = 1 / x

instance Field Float where

instance Floating Float where
  fromFloat x = x
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined

lerp :: Floating a => a -> a -> Float -> a
lerp x y deltaF =
  (x * (1 - delta)) + (y * delta)
  where
    delta = fromFloat deltaF

cerp :: Floating a => a -> a -> a -> a -> Float -> a
cerp x0 x1 x2 x3 deltaF =
  (a0 * delta * delta2) + ((a1 * delta2) + (a2 * delta) + a3)
  where
    delta  = fromFloat deltaF
    delta2 = delta * delta
    a0     = x3 - x2 - x0 + x1
    a1     = x0 - x1 - a0
    a2     = x2 - x0
    a3     = x1



----------------------------------------
-- Trig Approximation Functions
----------------------------------------

-- -- How to deal with Float maybe 64 vs 32 bit?
-- tanF32 :: Float -> Float
-- tanF32 n = tanResult
--   where
--     x = rem n twoPi
--     octant = floor <| (x * fourOverPi)
--     -- HACK -> Need to be able to convert from Float to
--     octantInt = if octant < 1 then 0
--       else if octant < 2 then 1
--       else if octant < 3 then 2
--       else if octant < 4 then 3
--       else if octant < 5 then 4
--       else if octant < 6 then 5
--       else if octant < 7 then 6
--       else 7
--     -- Accurate to about 8.2 decimal digits over the range (0, pi/4)
--     -- This computes tan (pi * x/4), range reduction must be used before input
--     tan82 x = (x * (c1 + c2 * x2) / (c3 + x2 * (c4 + x2)))
--       where
--         c1 = 211.849369664121
--         c2 = -12.5288887278448
--         c3 = 269.7350131214121
--         c4 = -71.4145309347748
--         x2 = (x * x)
--     tanResult = case octantInt of
--       0 -> tan82 (x * fourOverPi)
--       1 -> 1 / (tan82 ((halfPi - x) * fourOverPi))
--       2 -> -1 / (tan82 ((x - halfPi) * fourOverPi))
--       3 -> negate <| tan82 ((pi - x) * fourOverPi)
--       4 -> tan82 ((x - pi) * fourOverPi)
--       5 -> 1 / (tan82 ((threeHalfPi - x) * fourOverPi))
--       6 -> -1 / (tan82 ((x - threeHalfPi) * fourOverPi))
--       7 -> negate <| tan82 ((twoPi - x) * fourOverPi)
--       _ -> 0 -- ?!?

tanF64 :: Float -> Float
tanF64 n = tanResult
  where
    wrappedN = rem n twoPi
    twoPiN = twoPi + wrappedN
    x = if wrappedN < 0 then twoPiN else wrappedN
    -- TODO: investigate alternatives like masking etc..
    -- signMask = bitShiftRightA wrappedN 63
    -- x = wrappedN + (bitAnd (twoPi - wrappedN - wrappedN) signMask)
    -- x = rem wrappedN twoPi
    octant = truncateToInt <| (x * fourOverPi)
    -- Accurate to about 14 decimal digits over the range (0, pi/4)
    -- This computes tan (pi * x/4), range reduction must be used before input
    tan14s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = -34287.4662577359568109624
        c2 = 2566.7175462315050423295
        c3 = -26.5366371951731325438
        c4 = -43656.1579281292375769579
        c5 = 12244.4839556747426927793
        c6 = -336.611376245464339493
        x2 = (x * x)
    tanResult = case octant of
      0 -> tan14s (x * fourOverPi)
      1 -> 1 / (tan14s ((halfPi - x) * fourOverPi))
      2 -> -1 / (tan14s ((x - halfPi) * fourOverPi))
      3 -> negate <| tan14s ((pi - x) * fourOverPi)
      4 -> tan14s ((x - pi) * fourOverPi)
      5 -> 1 / (tan14s ((threeHalfPi - x) * fourOverPi))
      6 -> -1 / (tan14s ((x - threeHalfPi) * fourOverPi))
      7 -> negate <| tan14s ((twoPi - x) * fourOverPi)
      _ -> 0 -- ?!?


-- create a scalar for branchless selection if x > y
scalarIfGreaterThan :: Float -> Float -> Float
scalarIfGreaterThan x y = bitAnd subtractionMask 1
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF
    subtractionMask = bitShiftRightA subtractionSign 63

-- create a mask (0xFFFFFFFFFFFFFFFF or 0x0000000000000000) for branchless masking if x > y
maskIfGreaterThan :: Float -> Float -> Float
maskIfGreaterThan x y = bitShiftRightA subtractionSign 63
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF

-- Various resources for chebyshev approximation of functions:
-- http://www.ganssle.com/approx.htm
-- Computer Approximations by John Hart
-- Constrained Chebyshev Approximations to Some Elementary Functions Suitable for Evaluation with Floating-point Arithmetic
-- *** ^ note the coefficients tables starting on page 18 ***
-- For general approximation this is a useful resource
-- https://github.com/chebfun/chebfun
-- https://people.maths.ox.ac.uk/trefethen/ATAP/ATAPfirst6chapters.pdf

sinhConstant = log ((1 + (sqrt 5)) / 2)

-- More accurate at extremes of ranges?
sinh64_accurate :: Float -> Float
sinh64_accurate n = copysign z n
  where
    y = (abs n) - sinhConstant
    z = expY + ((expV / 2 - 1) * expY) - ((expNegV / 2) * expNegY)
    expV = exp sinhConstant
    expNegV = exp (negate sinhConstant)
    expY = exp y
    expNegY = exp (negate y)

-- sinh64_broken :: Float -> Float
-- sinh64_broken n = sinh_193s
--   where
--     l = log ((1 + sqrt 5) / 2)
--     -- l = log (1 + sqrt 2)
--     -- remN = rem n l
--     -- x = if remN < 0 then l + remN else remN
--     -- x = remN
--     -- x = remN
--     -- x = remN
--     -- x = rem n twoPi
--     wrappedN = rem n twoPi
--     twoPiN = twoPi + wrappedN
--     x = if wrappedN < 0 then twoPiN else wrappedN
--     -- sinh_193s = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
--     x2 = x * x
--     x3 = x2 * x
--     sinh_193s = x + (x3 / q)
--     -- q = c1 + (c2 * x2) + (c3 * pow x 4) + (c4 * pow x 6) + (c5 * pow x 8) + (c6 * pow x 10)
--     q = c1 + x2 * (c2 + x2 * (c3 + x2 * (c4 + x2 * (c5 + x2 * c6))))
--       where
--         c1 = 6.0000000000000000007
--         c2 = -0.30000000000000008212
--         c3 = 0.0078571428571458936741
--         c4 = -0.00013492063497385892777
--         c5 = 0.0000014507323068404717765
--         c6 = -0.0000000025198955964371314936
--         c7 = -0.00000000028298256368337042599
--     -- q = c1 + x2 * (c2 + x2 * (c3 + x2 * (c4 + x2 * (c5 + x2 * c6))))
--     --   where
--     --     c1 = 6.0000000000000003884
--     --     c2 = -0.30000000000002227888
--     --     c3 = 0.0078571428580357722224
--     --     c4 = -0.0003492064627800558812
--     --     c5 = 0.000004508048887469666981
--     --     c6 = -0.0000000027491054512754144867


-- branchless 64 bit atan
atanF64 :: Float -> Float
atanF64 n = copysign z n
  where
    absN = bitAnd n (bitNot iEEESignMaskF)
    -- absN = abs n
    -- complement = absN > 1
    -- complementCon = if complement then allBitsF else 0
    -- Set sign bit if absN > 1
    complement = bitAnd (1 - (absN + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    complementCon = bitShiftRightA complement 63
    -- x = if complement then 1 / absN else absN
    x = (bitAnd complementCon (1 / absN)) + (bitAnd absN (bitNot complementCon))
    -- region = x > tanTwelthPi
    -- regionCon = if region then 1 else 0
    -- Set sign bit if x > tanTwelthPi
    region = bitAnd (tanTwelthPi - (x + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    regionMask = bitShiftRightA region 63
    -- create scalar from mask for selection
    regionCon = bitAnd regionMask 1
    -- x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    x' = (x - (tanSixthPi * regionCon)) / (1 + (tanSixthPi * x * regionCon))
    -- y = if region then atan137s + sixthPi else atan137s
    y = atan137s + (sixthPi * regionCon)
    -- z = if complement then halfPi - y else y
    z = y + (bitAnd complementCon (halfPi - y - y))
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s = (x' * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x' * x'

slowAtanF64 :: Float -> Float
slowAtanF64 n = if sign then negate z else z
  where
    sign = n < 0
    absN = abs n
    complement = absN > 1
    x = if complement then 1 / absN else absN
    region = x > tanTwelthPi
    x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    y = if region then atanX + sixthPi else atanX
    z = if complement then halfPi - y else y
    atanX = atan137s x'
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x * x
----------------------------------------

instance Bits Float where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = primUndefined
  fromBits       x   = primUndefined

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Default Float where
  default = 0

negate :: Ring a => a -> a
negate x = 0 - x

floatToUInt :: Float -> UInt
floatToUInt x = primUndefined

-- f64ToUInt :: F64 -> UInt
-- f64ToUInt x = primUndefined

-- --------------------
-- -- F64
-- --------------------
-- instance Eq F64 where
--   eq  x y = primUndefined
--   neq x y = primUndefined
--
-- instance Ord F64 where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined
--
-- -- TODO: prim zero / one instances
-- instance Semiring F64 where
--   zero    = primUndefined
--   one     = primUndefined
--   add x y = primUndefined
--   mul x y = primUndefined
--
-- instance Ring F64 where
--   sub   x y = primUndefined
--   fromInt x = primUndefined
--
-- instance Num F64 where
--   abs    x = primUndefined
--   copysign x sign = primUndefined
--   signum x = copysign 1 x
--
-- instance EuclideanRing F64 where
--   div x y = primUndefined
--   rem x y = primUndefined
--
-- instance DivisionRing F64 where
--   recip x = 1 / x
--
-- instance Field F64 where
--
-- instance Floating F64 where
--   fromFloat x = primUndefined
--   sqrt      x = primUndefined
--   floor     x = primUndefined
--   ceil      x = primUndefined
--   truncate  x = primUndefined
--   round     x = primUndefined
--   -- fmin      x y = primUndefined
--   -- fmax      x y = primUndefined
--
-- instance Trig F64 where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined
--
-- instance Bits F64 where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined
--
-- instance Semigroup F64 where
--   append x y = x + y
--
-- instance Monoid F64 where
--   mempty = 0
--
-- instance Default F64 where
--   default = 0

fastFloor :: Float -> Float
fastFloor x = primUndefined

-- floor :: F64 -> F64
-- floor x = primUndefined
--
-- ceil :: F64 -> F64
-- ceil x = primUndefined
--
-- truncate :: F64 -> F64
-- truncate x = primUndefined
--
-- round :: F64 -> F64
-- round x = primUndefined
--
-- copysign :: F64 -> F64 -> F64
-- copysign x sign = primUndefined
--
-- fmin :: F64 -> F64 -> F64
-- fmin x y = primUndefined
--
-- fmax :: F64 -> F64 -> F64
-- fmax x y = primUndefined

floorToInt :: Float -> Int
floorToInt x = primUndefined

ceilToInt :: Float -> Int
ceilToInt x = primUndefined

truncateToInt :: Float -> Int
truncateToInt x = primUndefined

roundToInt :: Float -> Int
roundToInt x = primUndefined

fma :: Float -> Float -> Float -> Float
fma x y z = primUndefined

------------------------------------------------------------
-- iEEE 754 Double Precision Float Format constants
------------------------------------------------------------
iEEESignMask :: UInt
iEEESignMask = bitShiftLeft 1 63

iEEESignMaskF :: Float
iEEESignMaskF = fromBits iEEESignMask

iEEENumExponentBits :: UInt
iEEENumExponentBits = 11

iEEENumSignificandBits :: UInt
iEEENumSignificandBits = 52

iEEEExponentMask :: UInt
iEEEExponentMask = bitShiftLeft (-1) iEEENumSignificandBits |> bitAnd (bitNot iEEESignMask)

iEEEExponentMaskF :: Float
iEEEExponentMaskF = fromBits iEEEExponentMask

iEEESignificandMask :: UInt
iEEESignificandMask = bitAnd (-1) (bitNot (bitOr iEEEExponentMask iEEESignMask))

iEEESignificandMaskF :: Float
iEEESignificandMaskF = fromBits iEEESignificandMask

floatEpsilon :: Float
floatEpsilon = 0.00000000000000022204460492503131

floatEpsilonA :: Audio
floatEpsilonA = 0.00000000000000022204460492503131

allBits :: UInt
allBits = -1

allBitsF :: Float
allBitsF = fromBits allBits

f64EpsilonU :: UInt
f64EpsilonU = 4372995238176751616

f64Epsilon :: Float
f64Epsilon = fromBits f64EpsilonU

instance Trig Float where
  sine    x = primUndefined
  cosine  x = primUndefined
  exp     x = primUndefined
  exp2    x = primUndefined
  log     x = primUndefined
  log10   x = primUndefined
  log2    x = primUndefined
  pow   x y = primUndefined
  sineh   x = (exp x - exp (negate x)) * 0.5
  cosineh x = (exp x + exp (negate x)) * 0.5
  atan2 y x =
    let
      halfPiSignY = copysign halfPi y
      atan20Y = if y == 0 then 0 else halfPiSignY -- TODO: use fselect!
      atan2XY =
        if (abs x) > (abs y) then
          (atanF64 (y / x)) + (if x > 0 then 0 else (copysign pi y))
        else
          (negate <| atanF64 (x / y)) + halfPiSignY
    in
      if x == 0 then atan20Y else atan2XY

--------------------
-- FloatVec
--------------------

--TODO: insertelement
--TODO: extractelement

-- TODO: Finish!
instance Eq (FloatVec n) where
  eq  x y = primUndefined
  neq x y = primUndefined

-- instance Ord (FloatVec n) where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring (FloatVec n) where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring (FloatVec n) where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num (FloatVec n) where
  abs      x      = primUndefined
  copysign x sign = primUndefined
  signum   x      = copysign 1 x

instance EuclideanRing (FloatVec n) where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing (FloatVec n) where
  recip x = 1 / x

instance Field (FloatVec n) where

instance Floating (FloatVec n) where
  fromFloat x = primUndefined
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined

-- instance Trig (FloatVec n) where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined

-- instance Bits (FloatVec n) where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined

instance Semigroup (FloatVec n) where
  append x y = x + y

instance Monoid (FloatVec n) where
  mempty = 0

instance Default (FloatVec n) where
  default = 0

-- floatVecInsert :: Index n -> Float -> FloatVec n -> FloatVec n
-- floatVecInsert i f v = primUndefined

-- floatVecExtract :: Index n -> FloatVec n -> Float
-- floatVecExtract i v = primUndefined

toFloatVecArray :: .Array n Float -> .Array (NatDiv n vn) (FloatVec vn)
toFloatVecArray a = primUndefined

fromFloatVecArray ::  .Array (NatDiv n vn) (FloatVec vn) -> .Array n Float
fromFloatVecArray v = primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
-- TODO: More efficient gcd algorithm
data Rational = Rational# Int Int

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, a % b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational# (x / d) (y / d)
  where
    d = gcd x y

rational :: Int -> Int -> Rational
rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational# n _) = n

denominator :: Rational -> Int
denominator (Rational# _ d) = d

instance Eq Rational where
  eq  (Rational# xn xd) (Rational# yn yd) = eq (xn * yd) (yn * xd)
  neq (Rational# xn xd) (Rational# yn yd) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational# xn xd) (Rational# yn yd) = lt  (xn * yd) (yn * xd)
  lte (Rational# xn xd) (Rational# yn yd) = lte (xn * yd) (yn * xd)
  gt  (Rational# xn xd) (Rational# yn yd) = gt  (xn * yd) (yn * xd)
  gte (Rational# xn xd) (Rational# yn yd) = gte (xn * yd) (yn * xd)
  min x                 y                 = if x < y then x else y
  max x                 y                 = if x > y then x else y

instance Semiring Rational where
  zero = Rational# 0 1
  one  = Rational# 1 1
  add (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd + yn * xd) (xd * yd)
  mul (Rational# xn xd) (Rational# yn yd) = reduce (xn * yn) (xd * yd)

instance Ring Rational where
  sub (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd - yn * xd) (xd * yd)
  fromInt x                               = Rational# (fromInt x) 1

instance Num Rational where
  abs    (Rational# xn xd) = Rational# (abs xn) xd
  signum (Rational# xn _)  = Rational# (signum xn) 1
  copysign (Rational# xn xd) (Rational#  yn _) = Rational# (copysign xn yn) (abs xd)

instance DivisionRing Rational where
  recip (Rational# n d) =
    if n == 0 then
      Rational# 0 1
    else
      d // n

instance EuclideanRing Rational where
  rem x y = primUndefined
  div x y = x * recip y

instance Field Rational where

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

instance Default Rational where
  default = 0

rationalToFloat :: Rational -> Float
rationalToFloat r = fromInt (numerator r) / fromInt (denominator r)

maxRational :: Rational
maxRational = 922337203685477580 // 1


--------------------
-- Complex
--------------------
data Complex = Complex# Float Float

realPart :: Complex -> Float
realPart (Complex# r _) = r

imagPart :: Complex -> Float
imagPart (Complex# _ i) = i

mkPolar :: Float -> Float -> Complex
mkPolar r theta = Complex# (r * cosine theta) (r * sine theta)

cis :: Float -> Complex
cis theta = Complex# (cosine theta) (sine theta)

polar :: Complex -> (Float, Float)
polar c = (magnitude c, phase c)

polar' :: Complex -> (#Float, Float#)
polar' c = (#magnitude c, phase c#)

sqrMagnitude :: Complex -> Float
sqrMagnitude (Complex# r i) = (r * r) + (i * i)

magnitude :: Complex -> Float
magnitude (Complex# r i) = if ((r == 0) && (i == 0)) then 0 else sqrt ((r * r) + (i * i))

conjugate :: Complex -> Complex
conjugate (Complex# r i) = Complex# r (negate i)

phase :: Complex -> Float
phase (Complex# r i) = atan2 i r

instance Eq Complex where
  eq  (Complex# rx ix) (Complex# ry iy) = rx == ry && ix == iy
  neq (Complex# rx ix) (Complex# ry iy) = rx /= ry || ix /= iy

instance Semiring Complex where
  zero                                  = Complex# 0 0
  one                                   = Complex# 1 0
  add (Complex# rx ix) (Complex# ry iy) = Complex# (rx + ry) (ix + iy)
  mul (Complex# rx ix) (Complex# ry iy) = Complex# (rx * ry - ix * iy) (rx * iy + ix * ry)

instance Ring Complex where
  sub (Complex# rx ix) (Complex# ry iy) = Complex# (rx - ry) (ix - iy)
  fromInt z                             = Complex# (fromInt z) 0

instance EuclideanRing Complex where
  div x y = if yIntoConjugate /= 0
    then
      Complex# (zx / yIntoConjugate) (zi / yIntoConjugate)
    else
      Complex# 0 0
    where
      conjugateY     = conjugate y
      yIntoConjugate = y * conjugateY |> realPart
      Complex# zx zi = x * conjugateY
  rem x y = x - y * w
    where
      z = x / y
      w = case z of
        Complex# rz iz -> Complex# (floor rz) (floor iz)

instance DivisionRing Complex where
  recip (Complex# r i) = Complex# (r / sqrRsqrI) (negate (i / sqrRsqrI))
    where
      sqrRsqrI = (r * r) + (i * i)

instance Num Complex where
  abs z    = Complex# (magnitude z) 0
  signum z =
    case z of
      Complex# r i ->
        if r == 0 && i == 0 then 0 else
          let m = magnitude z in
            Complex# (r / m) (i / m)
  copysign x sign = (abs x) * (signum sign) -- Note: unsure if this is well founded or not?

instance Field Complex where

instance Floating Complex where
  fromFloat f = Complex# (fromFloat f) 0
  sqrt z = case z of
    Complex# r i ->
        let
            halfSqrt2 = (sqrt 2) / 2
            magZ = (magnitude z)
            magZR = r + magZ
            magZNegR = magZ - r
            u = if magZR /= 0 then sqrt magZR else 0
            v = if magZNegR /= 0 then (signum i) * (sqrt magZNegR) else 0
        in
            Complex# (halfSqrt2 * u) (halfSqrt2 * v)
  floor     (Complex# r i) = Complex# (floor r) (floor i)
  ceil      (Complex# r i) = Complex# (ceil r) (ceil i)
  truncate  (Complex# r i) = Complex# (truncate r) (truncate i)
  round     (Complex# r i) = Complex# (round r) (round i)

instance Trig Complex where
  sine (Complex# r i) = Complex# (sine r * cosineh i) (cosine r * sineh i)
  cosine (Complex# r i) = Complex# (cosine r * cosineh i) (negate (sine r * sineh i))
  sineh (Complex# r i) = Complex# (sineh r * cosine i) (cosineh r * sine i)
  cosineh (Complex# r i) = Complex# (cosineh r * cosine i) (negate (sineh r * sine i))
  exp (Complex# r i) = Complex# (expR * cosine i) (expR * sine i)
    where
      expR = exp r
  exp2 c = case c of
    (Complex# _ i) -> let
        magC = magnitude c
        logTwo = log 2
        iLogTwo = i * log 2
      in
        Complex# (magC * cosine iLogTwo) (magC * sine iLogTwo)
  log c = Complex# (log <| magnitude c) (phase c)
  log2 c = Complex# (log2 <| magnitude c) (phase c)
  log10 c = Complex# (log10 <| magnitude c) (phase c)
  pow n c = exp (c * log n)
  atan2 y x = (Complex# 0 -1) * (log ((x + ((Complex# 0 1) * y)) / (sqrt ((x * x) + (y * y)))))

lerpComplex :: Complex -> Complex -> Float -> Complex
lerpComplex (Complex# rx ix) (Complex# ry iy) delta =
  Complex# r i
  where
    r = rx * (1 - delta) + ry * delta
    i = ix * (1 - delta) + iy * delta

-- lerpTheta :: Float -> Float -> Float -> Float
-- lerpTheta x y delta =
--   s * ((2 * abs d) % tau) - d
--   where
--     ymx = y - x
--     s   = signum ymx
--     d   = s * (abs ymx % tau)

lerpTheta :: Float -> Float -> Float -> Float
lerpTheta x y delta =
  (x + shortestAngle * delta) % tau
  where
    shortestAngle = ((((y - x) % tau) + pi) % tau) - pi



--------------------
-- Vector2D
--------------------
data Vector2D      = Vector2D# Float Float
data AudioVector2D = AudioVector2D# Audio Audio

magnitude2D :: Vector2D -> Float
magnitude2D (Vector2D# x y) = sqrt ((x * x) + (y * y))

magnitudeSquared2D :: Vector2D -> Float
magnitudeSquared2D (Vector2D# x y) = (x * x) + (y * y)

dotProduct2D :: Vector2D -> Vector2D -> Float
dotProduct2D (Vector2D# x0 y0) (Vector2D# x1 y1) = (x0 * x1) + (y0 * y1)

instance Eq Vector2D where
  eq  (Vector2D# x0 y0) (Vector2D# x1 y1) = x0 == x1 && y0 == y1
  neq (Vector2D# x0 y0) (Vector2D# x1 y1) = x0 /= x1 || y0 /= y1

instance Ord Vector2D where
  lt  v0 v1 = lt  (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  lte v0 v1 = lte (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  gt  v0 v1 = gt  (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  gte v0 v1 = gte (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  min x  y  = if x < y then x else y
  max x  y  = if x > y then x else y

instance Semiring Vector2D where
  zero                                    = Vector2D# 0 0
  one                                     = Vector2D# 1 1
  add (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 + x1) (y0 + y1)
  mul (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 * x1) (y0 * y1)

instance Ring Vector2D where
  sub (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 - x1) (y0 - y1)
  fromInt x                               = Vector2D# (fromInt x) (fromInt x)

instance Num Vector2D where
  abs      (Vector2D# x y)                     = Vector2D# (abs x) (abs y)
  signum   (Vector2D# x y)                     = Vector2D# (signum x) (signum y)
  copysign (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (copysign x0 x1) (copysign y0 y1)

instance DivisionRing Vector2D where
  recip (Vector2D# x y) = Vector2D# (1 / x) (1 / y)

instance EuclideanRing Vector2D where
  rem (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (rem x0 x1) (rem y0 y1)
  div (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (div x0 x1) (div y0 y1)

instance Field Vector2D where

instance Floating Vector2D where
  fromFloat f              = Vector2D# f f
  sqrt     (Vector2D# x y) = Vector2D# (sqrt x) (sqrt y)
  floor    (Vector2D# x y) = Vector2D# (floor x) (floor y)
  ceil     (Vector2D# x y) = Vector2D# (ceil x) (ceil y)
  truncate (Vector2D# x y) = Vector2D# (truncate x) (truncate y)
  round    (Vector2D# x y) = Vector2D# (round x) (round y)

instance Semigroup Vector2D where
  append x y = x + y

instance Monoid Vector2D where
  mempty = 0

instance Default Vector2D where
  default = 0

instance Print Vector2D where
  print (Vector2D# x y) w =
    print '(' w
    |> print x
    |> print ','
    |> print y
    |> print ')'


----------------------
-- Vector3D
----------------------
data Vector3D      = Vector3D# Float Float Float
data AudioVector3D = AudioVector3D# Audio Audio Audio

magnitude3D :: Vector3D -> Float
magnitude3D (Vector3D# x y z) = sqrt ((x * x) + (y * y) + (z * z))

magnitudeSquared3D :: Vector3D -> Float
magnitudeSquared3D (Vector3D# x y z) = (x * x) + (y * y) + (z * z)

dotProduct3D :: Vector3D -> Vector3D -> Float
dotProduct3D (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = (x0 * x1) + (y0 * y1) + (z0 * z1)

-- TODO: VectorType class?

instance Eq Vector3D where
  eq  (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = x0 == x1 && y0 == y1 && z1 == z1
  neq (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = x0 /= x1 || y0 /= y1 || z1 /= z1

instance Ord Vector3D where
  lt  v0 v1 = lt  (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  lte v0 v1 = lte (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  gt  v0 v1 = gt  (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  gte v0 v1 = gte (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  min x  y  = if x < y then x else y
  max x  y  = if x > y then x else y

instance Semiring Vector3D where
  zero                                          = Vector3D# 0 0 0
  one                                           = Vector3D# 1 1 1
  add (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 + x1) (y0 + y1) (z0 + z1)
  mul (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 * x1) (y0 * y1) (z0 * z1)

instance Ring Vector3D where
  sub (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 - x1) (y0 - y1) (z0 - z1)
  fromInt x                                     = let f = fromInt x in Vector3D# f f f

instance Num Vector3D where
  abs      (Vector3D# x y z)                         = Vector3D# (abs x) (abs y) (abs z)
  signum   (Vector3D# x y z)                         = Vector3D# (signum x) (signum y) (signum z)
  copysign (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (copysign x0 x1) (copysign y0 y1) (copysign z0 z1)

instance DivisionRing Vector3D where
  recip (Vector3D# x y z) = Vector3D# (1 / x) (1 / y) (1 / z)

instance EuclideanRing Vector3D where
  rem (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (rem x0 x1) (rem y0 y1) (rem z0 z1)
  div (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (div x0 x1) (div y0 y1) (div z0 z1)

instance Field Vector3D where

instance Floating Vector3D where
  fromFloat f                = Vector3D# f f f
  sqrt     (Vector3D# x y z) = Vector3D# (sqrt x) (sqrt y) (sqrt z)
  floor    (Vector3D# x y z) = Vector3D# (floor x) (floor y) (floor z)
  ceil     (Vector3D# x y z) = Vector3D# (ceil x) (ceil y) (ceil z)
  truncate (Vector3D# x y z) = Vector3D# (truncate x) (truncate y) (truncate z)
  round    (Vector3D# x y z) = Vector3D# (round x) (round y) (round z)

instance Semigroup Vector3D where
  append x y = x + y

instance Monoid Vector3D where
  mempty = 0

instance Default Vector3D where
  default = 0

instance Print Vector3D where
  print (Vector3D# x y z) w =
    print '(' w
    |> print x
    |> print ','
    |> print y
    |> print ','
    |> print z
    |> print ')'


--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Eq a => Eq (Maybe a) where
  eq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> True
          _       -> False

      Just x ->
        case my of
          Nothing -> False
          Just y  -> eq x y
  neq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> False
          _       -> True

      Just x ->
        case my of
          Nothing -> True
          Just y  -> neq x y

instance Default (Maybe a) where
  default = nothing

instance Semigroup a => Semigroup (Maybe a) where
  append mx my =
    case mx of
      Nothing -> my
      Just x  ->
        case my of
          Nothing -> mx
          Just y  -> Just (append x y)

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance UFunctor Maybe where
  umap f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> Nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)
  map3 f mx my mz =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            case mz of
              Nothing -> nothing
              Just z  ->
                Just (f x y z)
  map4 f mw mx my mz =
    case mw of
      Nothing -> nothing
      Just w  ->
        case mx of
          Nothing -> nothing
          Just x  ->
            case my of
              Nothing -> nothing
              Just y  ->
                case mz of
                  Nothing -> nothing
                  Just z  ->
                    Just (f w x y z)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

instance Alternative Maybe where
  empty           = nothing
  alternative x y =
    case x of
      Nothing -> y
      Just _  -> x

-- NOTE: Is this still wrong?
-- This is wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
maybe :: .b -> .(.a -> .b) -> Maybe .a -> .b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x

-- NOTE: Is this still wrong?
-- This is wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
unwrapOr :: .a -> Maybe .a -> .a
unwrapOr defaultValue m =
  case m of
    Nothing -> defaultValue
    Just x  -> x

unwrapOrDefault :: Default a => Maybe a -> a
unwrapOrDefault m =
  case m of
    Nothing -> default
    Just x  -> x

unwrapOrPanic :: Array n Char -> Maybe a -> a
unwrapOrPanic message mx =
  case mx of
    Nothing -> panicWithMessage message
    Just x  -> x

isNothing :: Maybe a -> Bool
isNothing m =
  case m of
    Nothing -> True
    _       -> False

--------------------
-- Either
--------------------
data Either a b = Left a | Right b

either :: .(.a -> .c) -> .(.b -> .c) -> Either .a .b -> .c
either lf rf e =
  case e of
    Left  lx -> lf lx
    Right rx -> rf rx


--------------------
-- Ptr
--------------------
ptrMalloc :: UInt -> *Ptr .a
ptrMalloc capacity =
  primUndefined

ptrRealloc :: UInt -> *Ptr .a -> *Ptr .a
ptrRealloc capacity ptr =
  primUndefined

ptrFree :: *Ptr .a -> *()
ptrFree ptr =
  primUndefined

unsafePtrPeek :: UInt -> Ptr a -> a
unsafePtrPeek index ptr =
  primUndefined

unsafePtrPeekU :: UInt -> .Ptr a -> (#a, .Ptr a#)
unsafePtrPeekU index ptr =
  primUndefined

unsafePtrPoke :: UInt -> .a -> *Ptr .a -> *Ptr .a
unsafePtrPoke index value ptr =
  primUndefined

unsafePtrSwapElement :: UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
unsafePtrSwapElement index element ptr =
  primUndefined

unsafePtrCast :: Ptr .a -> Ptr .b
unsafePtrCast p =
  primUndefined

--TODO: This is causing strange non-exhaustive case statements at runtime somehow...
ptrEq :: Ptr a -> Ptr a -> Bool
ptrEq x y =
  primUndefined

ptrIsNull :: Ptr a -> Bool
ptrIsNull x =
  ptrEq x primUndefined

-- unsafePtrPokeChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> Ptr *a
-- unsafePtrPokeChecked str capacity index value ptr =
--   unsafePtrPoke (boundsCheck str index capacity) value ptr

-- unsafePtrSwapElementChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
-- unsafePtrSwapElementChecked str capacity index element ptr =
--   unsafePtrSwapElement (boundsCheck str index capacity) element ptr

-- TODO: Checked readArray and writeArray!

----------------------
-- MutRef: A hack to allow for recursively owned types...
----------------------
-- data MutRef a = MutRef (Ptr (Maybe a))

-- HACK / NOTE: mutRef expects the first argument to be CONSTANT (Need to support this concept in the type system...)
mutRef :: Maybe *a -> Ptr (Maybe *a)
mutRef x =
  primUndefined

mutRefTake :: (() -> *a) -> (#*a, Ptr (Maybe *a)#)
mutRefTake mkFn =
  case unsafePtrSwapElement 0 Nothing (mutRef Nothing) of
    (#mx, ptr1#) ->
      case mx of
        Just x  -> (#x, ptr1#)
        Nothing -> (#mkFn (), ptr1#)

mutRefPut :: *a -> Ptr (Maybe *a) -> ()
mutRefPut x ptr =
  case unsafePtrPoke 0 (Just x) ptr of
    _ -> ()

mutRefPutAudioArrayPtr :: *Ptr Float -> Ptr (Maybe *(Ptr Float)) -> Maybe (Ptr Float)
mutRefPutAudioArrayPtr x ptr =
  unsafePtrPeek 0 px'
  where
    px :: *Ptr (Maybe *(Ptr Float))
    px = unsafePtrPoke 0 (Just x) ptr
    px' :: Ptr (Maybe (Ptr Float))
    px' = unsafePtrCast px


--------------------
-- Array
--------------------

-- TODO: Make range unboxed? Proper unboxed types? End constructor name with # to create unboxed type?
data Range   (n :: Nat)                       = Range# UInt UInt UInt
data Index   (n :: Nat)                       = Index UInt
data NatVal  (n :: Nat)                       = NatVal
data NatVal2 (n :: Nat) (m :: Nat)            = NatVal2
data NatVal3 (n :: Nat) (m :: Nat) (o :: Nat) = NatVal3

natVal :: NatVal n -> UInt
natVal n = primUndefined

natVal2ToNatVals :: NatVal2 w h -> (#NatVal w, NatVal h#)
natVal2ToNatVals _ = (#NatVal, NatVal#)

natVal3ToNatVals :: NatVal3 w h d -> (#NatVal w, NatVal h, NatVal d#)
natVal3ToNatVals _ = (#NatVal, NatVal, NatVal#)

mkRange :: UInt -> UInt -> NatVal n -> Range n
mkRange init inc end = Range# init inc (natVal end)

each :: Range n
each = mkRange 0 1 NatVal

-- TODO / HACK / NOTE: Ranges should really support this on their own
indexBackwards :: NatVal n -> Index n -> Index n
indexBackwards n i =
  unsafeUIntToIndex ((natVal n - 1) - (indexToUInt i))

unsafeIndexToIndex :: Index n -> Index m
unsafeIndexToIndex (Index i) =
  Index i

indexLength' :: Index n -> NatVal n -> UInt
indexLength' _ n =
  natVal n

indexLength :: Index n -> UInt
indexLength i =
  indexLength' i NatVal

indexZero :: Index n
indexZero =
  Index 0

indexAddWithWrap :: Index n -> UInt -> Index n
indexAddWithWrap i a =
  Index ((ui + a) % indexLength i)
  where
    Index ui = i

indexAddWithMin :: Index n -> UInt -> Index n
indexAddWithMin i a =
  Index (min (ui + a) (indexLength i - 1))
  where
    Index ui = i

uintToIndexWithWrap' :: UInt -> NatVal n -> Index n
uintToIndexWithWrap' ui n =
  Index (ui % natVal n)

uintToIndexWithWrap :: UInt -> Index n
uintToIndexWithWrap ui =
  uintToIndexWithWrap' ui NatVal

uintToIndexWithMin' :: UInt -> NatVal n -> Index n
uintToIndexWithMin' ui n =
  Index (min ui (natVal n - 1))

uintToIndexWithMin :: UInt -> Index n
uintToIndexWithMin ui =
  uintToIndexWithMin' ui NatVal

unsafeEmptyArray :: () -> *Array n a
unsafeEmptyArray u = primUndefined

freezeArray :: *Array n a -> .Array n a
freezeArray a = primUndefined

readArray :: Index n -> Array n a -> a
readArray i a = primUndefined

readArrayClamped :: UInt -> Array n a -> a
readArrayClamped ui a =
  readArray (uintToIndexWithMin ui) a

readArrayU :: Index n -> .Array n a -> (#a, .Array n a#)
readArrayU i a = primUndefined

writeArray :: Index n -> a -> *Array n a -> *Array n a
writeArray i x a = primUndefined

lookupArray :: UInt -> Array n a -> Maybe a
lookupArray i a =
  if i < arrayLength NatVal a then
    Just (readArray (unsafeUIntToIndex i) a)
  else
    Nothing

writeArrayChecked :: Index n -> a -> *Array n a -> *Array n a
writeArrayChecked ind x a =
  writeArray (Index (boundsCheck i capacity)) x a
  where
    capacity = arrayLengthFromIndex NatVal ind
    (Index i) = ind

readArrayChecked :: UInt -> Array n a -> a
readArrayChecked i a =
  readArray (Index (boundsCheck i capacity)) a
  where
    capacity = arrayLength NatVal a

readArrayUChecked :: Index n -> .Array n a -> (#a, .Array n a#)
readArrayUChecked ind a =
  readArrayU (Index (boundsCheck i capacity)) a
  where
    capacity = arrayLengthFromIndex NatVal ind
    (Index i) = ind

zip :: Array n a -> Array n b -> Array n (a, b)
zip a b = freezeArray <|
  loop c = unsafeEmptyArray () for i <- each do
    let
      va = readArray i a
      vb = readArray i b
    in
      writeArray i (va, vb) c

zipWith :: (a -> b -> c) -> Array n a -> Array n b -> Array n c
zipWith f a b = freezeArray <|
  loop c = unsafeEmptyArray () for i <- each do
    let
      va = readArray i a
      vb = readArray i b
    in
      writeArray i (f va vb) c

instance Default a => Default (Array n a) where
  default = arrayFrom default

arrayFrom :: a -> .Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i x a

arrayFromN :: NatVal n -> a -> .Array n a
arrayFromN _ x = arrayFrom x

mkArray :: (UInt -> a) -> .Array n a
mkArray f =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (f (indexToUInt i)) a

instance Foldable (Array n) where
  fold a =
    loop x = mempty for i <- each do
      x <> readArray i a
  foldl f init a0 =
    fst' <| loop (#x, a1#) = (#init, a0#) for i <- each do
      case readArrayU i a1 of
        (#y, a2#) ->
          (#f x y, a2#)

instance Functor (Array n) where
  map f a = freezeArray b
    where
      b =
        loop a' = unsafeEmptyArray () for i <- each do
          writeArray i (f (readArray i a)) a'

instance FunctorN (Array n) where
  map2 f a b =
    freezeArray <| loop c = unsafeEmptyArray () for i <- each do
      writeArray i (f (readArray i a) (readArray i b)) c
  map3 f a b c =
    freezeArray <| loop d = unsafeEmptyArray () for i <- each do
      writeArray i (f (readArray i a) (readArray i b) (readArray i c)) d
  map4 f a b c d =
    freezeArray <| loop e = unsafeEmptyArray () for i <- each do
      writeArray i (f (readArray i a) (readArray i b) (readArray i c) (readArray i d)) e

--------------------
-- Slice
--------------------

data Slice a = Slice# (Ptr a) UInt

subSlice :: Array n a -> UInt -> Slice a
subSlice array sliceSize =
  Slice# (unsafeArrayToPtr array) (min (arrayLength NatVal array) sliceSize)

instance Print a => Print (Slice a) where
  print (Slice# p n) w =
    print '}' <| print ' ' <| fst' <| loop (#w', i#) = (#print '{' w |> print ' ', 0#) while i < n do
      let
        printDelimiter w =
          if i < (n - 1)
            then print ',' w |> print ' '
            else w
      in
        (#print (unsafePtrPeek i p) w' |> printDelimiter, i + 1#)

toSlice :: Array n a -> Slice a
toSlice array =
  Slice# (unsafeArrayToPtr array) (arrayLength NatVal array)

instance Foldable Slice where
  fold (Slice# p n) =
    fst' <| loop (#x, i#) = (#mempty, 0#) while i < n do
      (#x <> (unsafePtrPeek i p), i + 1#)
  foldl f init (Slice# p n) =
    fst' <| loop (#x, i#) = (#init, 0#) while i < n do
      (#f x (unsafePtrPeek i p), i + 1#)

sliceReadClamped :: UInt -> Slice a -> a
sliceReadClamped index (Slice# ptr len) =
  unsafePtrPeek (min index len) ptr

sliceLookup :: UInt -> Slice a -> Maybe a
sliceLookup index (Slice# ptr len) =
  if index < len then
    Just (unsafePtrPeek index ptr)
  else
    Nothing

sliceLength :: Slice a -> UInt
sliceLength (Slice# _ len) =
  len

--------------------
-- Index
--------------------
-- TODO: Hide Index constructor outside of base.necro for safety
-- TODO: Use Max to restrict UInt to range?
unsafeUIntToIndex :: UInt -> Index n
unsafeUIntToIndex i =
  Index i

indexToUInt :: Index n -> UInt
indexToUInt (Index i) = i

indexToFloat :: Index n -> Float
indexToFloat (Index i) = fromUInt i

bitReverseIndex :: Index n -> Index n
bitReverseIndex (Index i) = Index (bitReverse i)

-- toIndexMultiple :: Index n -> Index (NatMul n (NatMax k 1))
-- toIndexMultiple (Index i) = Index i

sampleRate :: UInt
sampleRate = primUndefined

recipSampleRate :: Float
recipSampleRate = primUndefined

audioSampleRate :: UInt
audioSampleRate = 48000

audioBlockSize :: UInt
audioBlockSize = 256

audioBlockSizeMask :: UInt
audioBlockSizeMask = audioBlockSize - 1

audioOverSampleAmount :: UInt
audioOverSampleAmount = 24

audioRecipOverSampleRate :: Float
audioRecipOverSampleRate = recip <| fromUInt <| audioSampleRate * audioOverSampleAmount

-- audioBlockSize :: UInt
-- audioBlockSize = audioBlockSize' * audioOverSampleAmount

audioBlockSizeF :: Float
audioBlockSizeF = fromUInt audioBlockSize

-- audioSampleRate :: UInt
-- audioSampleRate = audioSampleRate' * audioOverSampleAmount

audioSampleRateF :: Float
audioSampleRateF = fromUInt audioSampleRate

audioBlocksPerSecond :: UInt
audioBlocksPerSecond = audioSampleRate / audioBlockSize

audioBlockDelta :: Rational
audioBlockDelta =
  recip (fromUInt audioSampleRate // fromUInt audioBlockSize)
  -- = 1 // fromUInt audioBlocksPerSecond

audioBlockDeltaF :: Float
audioBlockDeltaF = rationalToFloat audioBlockDelta

audioSampleDelta :: Rational
audioSampleDelta = audioBlockDelta / fromUInt audioBlockSize
-- audioSampleDelta = 1 // fromUInt audioSampleRate

-- -- NOTE: Assumes audioBlockSize is a power of 2!
-- audioBlockSizeLog2 :: UInt
-- audioBlockSizeLog2 =
--   fst' <| loop (#bits, n#) = (#0, audioBlockSize#) while n > 0 do
--     (#bits + 1, bitShiftRight n 1#)

audioSampleOffset :: UInt
audioSampleOffset = 0

-- Time starts at 0
currBlockTime :: Rational
currBlockTime =
  fromInt t * audioBlockDelta
  where
    t ~ -1 = t + 1

nextBlockTime :: Rational
nextBlockTime =
  currBlockTime + audioBlockDelta

localTimeR :: () -> Rational
localTimeR _ =
  t * audioBlockDelta
  where
    t ~ -1 = t + 1

localTime :: () -> Float
localTime _ =
  t * audioBlockDeltaF
  where
    t ~ -1 = t + 1

currBlockCount :: UInt
currBlockCount =
  fromInt t
  where
    t ~ -1 = t + 1

currSampleCount :: UInt
currSampleCount =
  t * audioBlockSize
  where
    t ~ -1 = t + 1


--------------------
-- Poly Voice Bank
--------------------

data VoiceID = VoiceID Int
data VoiceTimeStamp =
  VoiceTimeStamp_Rational Rational | -- Expected to fall within current block
  VoiceTimeStamp_Block | -- Fills entire block
  VoiceTimeStamp_StartStop_Rational Rational Rational -- Start Expected to fall within current block, Stop can extend arbitrarily into the future

data VoiceActivity =
  VoiceInactive |
  VoiceActive

data VoiceEvent = VoiceEvent VoiceID VoiceActivity VoiceTimeStamp Float

data VoiceState =
  VoiceStateSustaining |
  VoiceStateReleasing |
  VoiceStateInactive

data PolyVoiceStateOrderID = PolyVoiceStateOrderID UInt -- Used to track creation order for note stealing
data PolyVoiceLifetime = PolyVoiceLifetime# Rational Rational -- Start/End time
 -- First array is the start sample accurate version for onsets, second is block rate for faster updates regularly
data PolyVoiceState = PolyVoiceState# VoiceID PolyVoiceStateOrderID VoiceState PolyVoiceLifetime Float

data PolyVoiceBankCapacity = PolyVoiceBankCapacity UInt
data PolyVoiceBankNumActive = PolyVoiceBankNumActive UInt
data PolyVoiceBankOrderCounter = PolyVoiceBankOrderCounter UInt

data PolyVoiceBank numVoices = PolyVoiceBank# .(Array numVoices PolyVoiceState) PolyVoiceBankCapacity PolyVoiceBankNumActive PolyVoiceBankOrderCounter

instance Default PolyVoiceState where
  default =
    PolyVoiceState#
      (VoiceID 0)
      (PolyVoiceStateOrderID 0)
      VoiceStateInactive
      (PolyVoiceLifetime# 0 0)
      0

 -- Returns the index and previous params for the created/stolen voice
polyVoiceBank_CreateOrStealVoice ::
  VoiceID ->
  PolyVoiceLifetime ->
  Float ->
  *PolyVoiceBank numVoices ->
  (#*PolyVoiceBank numVoices, UInt, PolyVoiceState#)
polyVoiceBank_CreateOrStealVoice
  vid
  vlifetime
  vparams
  (PolyVoiceBank# a (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o)) =
    let
      VoiceID vidU = vid
      -- 1. First see if the current note is already playing, if so set back to sustain
      isElement (PolyVoiceState# (VoiceID vid2) _ _ _ _) = vidU == vid2
      updateElement _ =
        PolyVoiceState# vid (PolyVoiceStateOrderID o) VoiceStateSustaining vlifetime vparams
      (#maybeUpdatedIndex, (PolyVoiceBank# ua _ _ _)#) =
        if n > 0 then
          polyVoiceBank_UpdateFirstElementWhere
            isElement
            updateElement 
            (PolyVoiceBank# a (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o))
        else
          (#Nothing, PolyVoiceBank# a (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o)#)
    in
      case maybeUpdatedIndex of
        Just (#updatedIndex, prevState#) ->
          (#PolyVoiceBank# ua (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter (o + 1)), updatedIndex, prevState#)
        Nothing ->
          -- 2. Second try to fill an empty whole
          if n < c then
            (loop (#a', maybeCreatedIndex#) = (#ua, Nothing#) for i <- each do
              case maybeCreatedIndex of
                Just _ -> (#a', maybeCreatedIndex#)
                Nothing ->
                  let
                    (Index createdIndex) = i
                    (#prevState, readA#) = readArrayU i a'
                    (PolyVoiceState# _ _ voiceState _ _ ) = prevState
                  in
                    case voiceState of
                      VoiceStateInactive ->
                        (#writeArray i (PolyVoiceState# vid (PolyVoiceStateOrderID o) VoiceStateSustaining vlifetime vparams) readA, Just (#createdIndex, prevState#)#)
                      _ -> (#readA, Nothing#)
            ) |> \(#a', maybeCreatedIndex#) ->
              case maybeCreatedIndex of
                Just (#createdIndex, prevState#) ->
                  (#PolyVoiceBank# a' (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive (n + 1)) (PolyVoiceBankOrderCounter (o + 1)), createdIndex, prevState#)
                Nothing -> -- this should never happen!!
                  (#
                    PolyVoiceBank# a' (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o)
                      |> traceLn "polyVoiceBank_CreateOrStealVoice failed to create voice?!?!?",
                    0,
                    default
                  #)
          -- 3. Third, if none created then steal the oldest releasing voice
          else
            (loop (#a', maybeStolenId, soid, stolenIndex, stolenState#) = (#ua, Nothing, 0, 0, default#) for i <- each do
              let
                Index index = i
                (#prevState, readA#) = readArrayU i a'
                (PolyVoiceState# vid (PolyVoiceStateOrderID oid) voiceState _ prevParams) = prevState
                steal =
                  case voiceState of
                    VoiceStateReleasing -> True
                    _ -> False
              in
                if steal then
                  case maybeStolenId of
                    Nothing -> (#readA, Just vid, oid, index, prevState#)
                    Just svid ->
                      if oid < soid then
                        (#readA, Just vid, oid, index, prevState#)
                      else
                        (#readA, maybeStolenId, soid, stolenIndex, stolenState#)
                else
                  (#readA, maybeStolenId, soid, stolenIndex, stolenState#)
            ) |> \(#a', maybeStolenId, _, si, stolenState#) ->
              case maybeStolenId of
                Just svid ->
                  let
                    stolenIndex = unsafeUIntToIndex si
                    writeA =
                      writeArray
                        stolenIndex
                        (PolyVoiceState# vid (PolyVoiceStateOrderID o) VoiceStateSustaining vlifetime vparams)
                        a'
                  in
                    (#PolyVoiceBank# writeA (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter (o + 1)), si, stolenState#)
                _ ->
                  -- 4. Fourth, if no releasing voices, then steal the oldest voices
                  (loop (#a'', maybeStolenId, soid, stolenIndex, stolenState#) = (#a', Nothing, 0, 0, default#) for i <- each do
                    let
                      Index index = i
                      (#prevState, readA#) = readArrayU i a''
                      (PolyVoiceState# vid (PolyVoiceStateOrderID oid) voiceState _ prevParams) = prevState
                    in
                      case maybeStolenId of
                        Nothing -> (#readA, Just vid, oid, index, prevState#)
                        Just svid ->
                          if oid < soid then
                            (#readA, Just vid, oid, index, prevState#)
                          else
                            (#readA, maybeStolenId, soid, stolenIndex, stolenState#)
                  ) |> \(#a', maybeStolenId, _, si, stolenState#) ->
                    case maybeStolenId of
                      Nothing ->
                        (#
                          PolyVoiceBank# a' (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o)
                            |> traceLn "polyVoiceBank_CreateOrStealVoice failed to steal voice?!?!?",
                          0,
                          default
                        #)
                      Just svid ->
                        let
                          stolenIndex = unsafeUIntToIndex si
                          writeA =
                            writeArray
                              stolenIndex
                              (PolyVoiceState# vid (PolyVoiceStateOrderID o) VoiceStateSustaining vlifetime vparams)
                              a'
                        in
                          (#PolyVoiceBank# writeA (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter (o + 1)), si, stolenState#)

-- Returns Just (#foundIndex, prevState#) or Nothing if not found
polyVoiceBank_UpdateFirstElementWhere ::
  (PolyVoiceState -> Bool) ->
  (PolyVoiceState -> PolyVoiceState) ->
  *PolyVoiceBank numVoices ->
  (#Maybe (#UInt, PolyVoiceState#), *PolyVoiceBank numVoices#)
polyVoiceBank_UpdateFirstElementWhere f u (PolyVoiceBank# a c n o) =
  (loop (#maybeIndex, a'#) = (#Nothing, a#) for i <- each do
    case maybeIndex of
      Just _ -> (#maybeIndex, a'#)
      Nothing ->
        let
          (Index n) = i
          (#element, readA#) = readArrayU i a'
          found = f element
        in
          if found then
            (#Just (#n, element#), writeArray i (u element) readA#)
          else
            (#Nothing, readA#)
  ) -- ~loop
  |> \(#maybeIndex, a'#) ->
    (#maybeIndex, PolyVoiceBank# a' c n o#)

data PolyVoiceBank_VoiceBehavior =
  PolyVoiceBank_DeactivateAfterRelease |
  PolyVoiceBank_InfiniteRelease

polyVoiceBank_mkVoices :: NatVal numVoices -> .PolyVoiceBank numVoices
polyVoiceBank_mkVoices numVoices =
  PolyVoiceBank# (arrayFrom default) (PolyVoiceBankCapacity <| natVal numVoices) (PolyVoiceBankNumActive 0) (PolyVoiceBankOrderCounter 0)

-- -- Uses oldest note voice stealing
polyVoiceBank_WithBehavior ::
  (AudioFormat f) =>
  NatVal numVoices -> -- size of voice bank
  (VoiceID -> Mono Audio -> f Audio -> f Audio -> f Audio) -> -- (\voiceID voiceEventParameter envGenValue -> trigger -> audioOut)
  (f Audio -> f Audio -> f Audio -> f Audio) -> -- (\gate trigger audioIn -> audioOut)
  Slice VoiceEvent -> -- stream of voice events, timing should fall within current block
  PolyVoiceBank_VoiceBehavior ->
  f Audio
polyVoiceBank_WithBehavior numVoices voice envGen voiceEvents voiceBehavior =
  case mutRefTake (\_ -> polyVoiceBank_mkVoices numVoices) of
    (#voiceBank, mref#) ->
      let
        nothingAudioArray _ = arrayFrom Nothing
        foldEvents (#voices', onsetParamsArray, gateArray, triggerArray#) (VoiceEvent (VoiceID voiceID) activity ts newVoiceParams) =
          case activity of
            VoiceActive ->
              let
                (#start, stop#) =
                  case ts of
                    VoiceTimeStamp_Rational rt -> (#rt, 0#)
                    VoiceTimeStamp_Block -> (#currBlockTime, 0#)
                    VoiceTimeStamp_StartStop_Rational start stop -> (#start, stop#)
                (#updatedVoices, si, prevState#) =
                  polyVoiceBank_CreateOrStealVoice
                    (VoiceID voiceID)
                    (PolyVoiceLifetime# start stop)
                    newVoiceParams
                    voices'
                (PolyVoiceState# prVID prOID prVS (PolyVoiceLifetime# prStart prStop) prevParams) = prevState
                stolenIndex = unsafeUIntToIndex si
                -----------------------------------
                -- Voice params
                (#maybeCurrentVoiceOnsetParams, readOnsetParamsArray#) = readArrayU stolenIndex onsetParamsArray
                sampleAccurateOnsetParams =
                  if start <= currBlockTime then
                    arrayFrom newVoiceParams
                  else
                    case maybeCurrentVoiceOnsetParams of
                      Nothing ->
                          freezeArray
                          <| loop a = unsafeEmptyArray () for i <- each do
                            let
                              (Index n) = i
                              sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                              updatedSample =
                                if sampleTime >= start
                                  then newVoiceParams 
                                  else prevParams
                            in
                              writeArray i updatedSample a
                      Just cps ->
                        freezeArray
                        <| loop a = unsafeEmptyArray () for i <- each do
                          let
                            (Index n) = i
                            sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                            currentSample = readArray i cps
                            updatedSample =
                              if sampleTime >= start then
                                newVoiceParams
                              else
                                currentSample
                          in
                            writeArray i updatedSample a
                onsetParamsArray' = writeArray stolenIndex (Just sampleAccurateOnsetParams) readOnsetParamsArray
                -----------------------------------
                -- Gate params
                (#maybeCurrentVoiceGate, readGateArray#) = readArrayU stolenIndex gateArray
                sampleAccurateGate =
                  case maybeCurrentVoiceGate of
                    Nothing ->
                      (loop g = unsafeEmptyArray () for i <- each do
                        let
                          (Index n) = i
                          sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                          gateSample =
                            if stop > 0 && sampleTime >= stop then
                              0
                            else if sampleTime >= start then
                              1
                            else if sampleTime >= prStart && (prStop == 0 || sampleTime < prStop) then
                              1
                            else
                              0
                        in
                          writeArray i gateSample g
                      ) |> freezeArray
                    Just gateSamples ->
                      (loop g = unsafeEmptyArray () for i <- each do
                        let
                          (Index n) = i
                          sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                          currentGateSample = readArray i gateSamples
                          updatedGateSample =
                            if stop > 0 && sampleTime >= stop then
                              0
                            else if sampleTime >= start then
                              1
                            else
                              currentGateSample
                        in
                          writeArray i updatedGateSample g
                      ) |> freezeArray
                gateArray' = writeArray stolenIndex (Just sampleAccurateGate) readGateArray
                -----------------------------------
                -- Trigger params
                (#maybeCurrentVoiceTrigger, readTriggerArray#) = readArrayU stolenIndex triggerArray
                sampleAccurateTrigger =
                  case maybeCurrentVoiceTrigger of
                    Nothing ->
                      (loop t = unsafeEmptyArray () for i <- each do
                        let
                          (Index n) = i
                          sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                          triggerSample = if sampleTime == start then 1 else 0
                        in
                          writeArray i triggerSample t
                      ) |> freezeArray
                    Just triggerSamples ->
                      (loop t = unsafeEmptyArray () for i <- each do
                        let
                          (Index n) = i
                          sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                          currentTriggerSample = readArray i triggerSamples
                          updatedTriggerSample = if sampleTime == start then 1 else currentTriggerSample
                        in
                          writeArray i updatedTriggerSample t
                      ) |> freezeArray
                triggerArray' = writeArray stolenIndex (Just sampleAccurateTrigger) readTriggerArray
              in
                (#updatedVoices, onsetParamsArray', gateArray', triggerArray'#)
            VoiceInactive ->
              let
                isElement (PolyVoiceState# (VoiceID voiceID2) _ _ _ _) =  voiceID == voiceID2
                updateElement (PolyVoiceState# vid oid _ (PolyVoiceLifetime# start _) vparams) =
                  PolyVoiceState# vid oid VoiceStateReleasing (PolyVoiceLifetime# start' stop') vparams
                  where
                    (#start', stop'#) =
                      case ts of
                        VoiceTimeStamp_Rational rt -> (#start, rt#)
                        VoiceTimeStamp_Block -> (#start, currBlockTime#)
                        VoiceTimeStamp_StartStop_Rational _ stop' -> (#start, stop'#)
                (#maybeFoundIndex, voices''#) = polyVoiceBank_UpdateFirstElementWhere isElement updateElement voices'
              in
                case maybeFoundIndex of
                  Nothing -> (#voices'', onsetParamsArray, gateArray, triggerArray#) |> traceLn "FAILED TO UPDATE VOICE AFTER INACTIVE EVENT!!!!!!!!"
                  Just (#fi, PolyVoiceState# _ _ _ (PolyVoiceLifetime# prStart prStop) _#) ->
                    let
                      foundIndex = unsafeUIntToIndex fi
                      (PolyVoiceBank# v c n o) = voices''
                      (#(PolyVoiceState# _ _ _ (PolyVoiceLifetime# start stop) _), readVoiceBank#) = readArrayU foundIndex v
                      (#maybeCurrentVoiceGate, readGateArray#) = readArrayU foundIndex gateArray
                      sampleAccurateGate =
                        case maybeCurrentVoiceGate of
                          Nothing ->
                            arrayFrom 0
                          Just gateSamples ->
                            (loop g = unsafeEmptyArray () for i <- each do
                              let
                                (Index n) = i
                                sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
                                currentGateSample = readArray i gateSamples
                                updatedGateSample =
                                  if stop > 0 && sampleTime >= stop then
                                    0
                                  else if sampleTime >= start then
                                    1
                                  else
                                    currentGateSample
                              in
                                writeArray i updatedGateSample g
                            ) |> freezeArray
                    in
                      (#PolyVoiceBank# readVoiceBank c n o, onsetParamsArray, writeArray foundIndex (Just sampleAccurateGate) readGateArray, triggerArray#)

      in
        foldl foldEvents (#voiceBank, nothingAudioArray (), nothingAudioArray (), nothingAudioArray ()#) voiceEvents
        -- -- Uncomment this block for debug printing --------------------------------------------------------
        -- |> \(#PolyVoiceBank# vp cp (PolyVoiceBankNumActive np) op, onsetParamsArrayU, maybeGateArrayU, maybeTriggerArrayU#) ->
        --   (if sliceLength voiceEvents > 0 then
        --     ()
        --     |> traceLn "PolyVoiceBank"
        --     |> \_ ->
        --       (loop vp' = vp for i <- each do
        --         let
        --           (#element, readVoices#) = readArrayU i vp'
        --           (Index index) = i
        --           _ = (#traceLn2 " i " index, traceLn2 "element: " element#)
        --         in
        --           readVoices
        --       ) |> \vp' ->
        --         (#PolyVoiceBank# vp' cp (PolyVoiceBankNumActive (np |> traceLn2 "n: ")) op, onsetParamsArrayU, maybeGateArrayU, maybeTriggerArrayU#)
        --   else
        --     (#PolyVoiceBank# vp cp (PolyVoiceBankNumActive np) op, onsetParamsArrayU, maybeGateArrayU, maybeTriggerArrayU#)
        --   )
        -- -- Uncomment this block for debug printing --------------------------------------------------------
        |> \(#PolyVoiceBank# voices c (PolyVoiceBankNumActive n) o, onsetParamsArrayU, maybeGateArrayU, maybeTriggerArrayU#) ->
          let
            onsetParamsArray = onsetParamsArrayU |> freezeArray
            gateArray = maybeGateArrayU |> freezeArray
            triggerArray = maybeTriggerArrayU |> freezeArray
          in
            -- Generate voice output, and handle voice activity based on envGen output
            (loop (#voices', n', voiceAudio#) = (#voices, n, pure 0#) for i <- each do
              let
                (#(PolyVoiceState# vid oid vstate (PolyVoiceLifetime# vStartTime vEndTime) voiceParams), readA#) = readArrayU i voices'
                vEndTime' = if vEndTime == 0 then nextBlockTime else vEndTime
                lookupGateSamples i array =
                  case (readArray i array) of
                    Nothing -> pure <| genAudio (\sampleTime -> if sampleTime >= vStartTime && sampleTime < vEndTime' then 1 else 0)
                    Just samples -> pure <| AudioRate samples
                lookupTriggerSamples i array =
                  case (readArray i array) of
                    Nothing -> pure <| BlockRate 0
                    Just samples -> pure <| AudioRate samples
              in
                case vstate of
                  VoiceStateInactive -> (#readA, n', voiceAudio#)
                  _ ->
                    let
                      (#gate, trigger, sampleAccurateVoiceParams, isReleasing#) =
                        if vEndTime == 0 then
                          if vStartTime < currBlockTime then
                            (#pure <| BlockRate 1, pure <| BlockRate 0, Mono <| BlockRate voiceParams, False#)
                          else
                            let
                              onsetParams =
                                case (readArray i onsetParamsArray) of
                                  Nothing -> Mono <| BlockRate voiceParams
                                  Just o -> Mono <| AudioRate o
                            in
                              (#lookupGateSamples i gateArray, lookupTriggerSamples i triggerArray, onsetParams, False#)
                        else
                          if vEndTime' <= currBlockTime then
                            (#pure <| BlockRate 0, pure <| BlockRate 0, Mono <| BlockRate voiceParams, True#)
                          else if vStartTime < currBlockTime then
                            (#lookupGateSamples i gateArray, pure <| BlockRate 0, Mono <| BlockRate voiceParams, False#)
                          else
                            let
                              onsetParams =
                                case (readArray i onsetParamsArray) of
                                  Nothing -> Mono <| BlockRate voiceParams
                                  Just o -> Mono <| AudioRate o
                            in
                              (#lookupGateSamples i gateArray, lookupTriggerSamples i triggerArray, onsetParams, False#)
                      envOut = envGen gate trigger (pure <| BlockRate 1)
                      (#gateUpdatedA, vstate'#) =
                        if isReleasing then
                          case vstate of
                            VoiceStateSustaining ->
                              let
                                gateUpdatedA =
                                  writeArray
                                    i
                                    (PolyVoiceState# vid oid VoiceStateReleasing (PolyVoiceLifetime# vStartTime vEndTime) voiceParams)
                                    readA
                              in
                                (#gateUpdatedA, VoiceStateReleasing#)
                            _ -> (#readA, vstate#)
                        else
                          (#readA, vstate#)
                      (#writeA, n''#) =
                        case voiceBehavior of
                          PolyVoiceBank_InfiniteRelease -> (#gateUpdatedA, n'#)
                          PolyVoiceBank_DeactivateAfterRelease ->
                            case vstate' of
                              VoiceStateReleasing ->
                                let
                                  f acc c =
                                    case c of
                                      AudioRate ca ->
                                        if (readArray (unsafeUIntToIndex 0) ca) >= floatEpsilon then
                                          False
                                        else
                                          acc && True
                                      BlockRate c ->
                                        if c >= floatEpsilon then
                                          False
                                        else
                                          acc && True
                                      _ -> acc && True
                                in
                                  if foldl f True envOut then
                                    (#writeArray i default gateUpdatedA, n' - 1#) -- |> traceLn "Remove Voice!!!!"
                                  else
                                    (#gateUpdatedA, n'#)
                              _ -> (#gateUpdatedA, n'#)
                    in
                      (#writeA, n'', map2 (+) voiceAudio (voice vid sampleAccurateVoiceParams envOut trigger)#)
            ) -- ~loop
        |> \(#voices', n', voiceAudio#) ->
          case mutRefPut (PolyVoiceBank# voices' c (PolyVoiceBankNumActive n') o) mref of
            _ -> voiceAudio

-- Deactivates after release when the envGen reaches 0
polyVoiceBank ::
  (AudioFormat f) =>
  NatVal numVoices -> -- size of voice bank
  (VoiceID -> Mono Audio -> f Audio -> f Audio -> f Audio) -> -- (\voiceID voiceEventParameter envGenValue trigger -> audioOut)
  (f Audio -> f Audio -> f Audio -> f Audio) -> -- (\gate trigger audioIn -> audioOut)
  Slice VoiceEvent -> -- stream of voice events, timing should fall within current block
  f Audio
polyVoiceBank numVoices voice envGen voiceEvents =
  polyVoiceBank_WithBehavior numVoices voice envGen voiceEvents PolyVoiceBank_DeactivateAfterRelease

-- Never deactivates voices once they've been activated.
-- Good for fixed voices like piano keys or string instrument simulation
polyVoiceBank_InfiniteRelease ::
  (AudioFormat f) =>
  NatVal numVoices -> -- size of voice bank
  (VoiceID -> Mono Audio -> f Audio -> f Audio -> f Audio) -> -- (\voiceID voiceEventParameter envGenValue trigger -> audioOut)
  (f Audio -> f Audio -> f Audio -> f Audio) -> -- (\gate trigger audioIn -> audioOut)
  Slice VoiceEvent -> -- stream of voice events, timing should fall within current block
  f Audio
polyVoiceBank_InfiniteRelease numVoices voice envGen voiceEvents =
  polyVoiceBank_WithBehavior numVoices voice envGen voiceEvents PolyVoiceBank_InfiniteRelease

--------------------
-- Audio
--------------------
data Audio = AudioEnd | BlockRate Float | AudioRate (Array BlockSize Float)

silenceAtEnd :: AudioFormat f => f Audio -> f Audio
silenceAtEnd cs =
  map f cs
  where
    f c =
      case c of
        AudioEnd -> BlockRate 0
        _        -> c

valueAtEnd :: AudioFormat f => Float -> f Audio -> f Audio
valueAtEnd value cs =
  map f cs
  where
    f c =
      case c of
        AudioEnd -> BlockRate value
        _        -> c

outAudioBlock :: UInt -> Array BlockSize Float -> *World -> *World
outAudioBlock c a w = primUndefined

silentBlock :: Array BlockSize Float
silentBlock =
  fromFloatVecArray a
  where
    a :: Array (NatDiv BlockSize 32) (FloatVec 32)
    a = arrayFrom 0

outChannel :: UInt -> Audio -> *World -> *World
outChannel n c w =
  case c of
    AudioEnd    -> outAudioBlock n silentBlock w
    BlockRate _ -> outAudioBlock n silentBlock w
    AudioRate b -> outAudioBlock n b w

audioToFloatChannel :: Audio -> Float
audioToFloatChannel c =
  case c of
    AudioRate b -> readArray (unsafeUIntToIndex 0) b
    BlockRate a -> a
    _           -> 0

audioToFloat :: Mono Audio -> Float
audioToFloat (Mono a) =
  audioToFloatChannel a

blockRate :: AudioFormat f => f Audio -> f Audio
blockRate cs =
  map (audioToFloatChannel .> BlockRate) cs

-- TODO / NOTE:
--     Take care when creating arrays for usage as audio buffers, they must be 64 BYTE aligned to allow for proper simd usage,
--     Thus audio buffers should always be created in the form:
--         Array (NatDiv BlockSize 32) (FloatVec 32)
--     and then cast to:
--         Array BlockSize Float
--     This will insure that the audio buffer is aligned properly by the llvm back end
audioInitArray :: () -> *Array BlockSize Float
audioInitArray u =
  snd' <| loop (#i, a#) = (#0, fromFloatVecArray ia#) while i < audioSampleOffset do
    (#i + 1, writeArray (Index i) 0 a#)
  where
    ia :: *Array (NatDiv BlockSize 32) (FloatVec 32)
    ia = unsafeEmptyArray ()

mapAudio :: (Float -> Float) -> Audio -> Audio
mapAudio f c =
  case c of
    AudioEnd    -> AudioEnd
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = audioInitArray () for i <- offsetToEndRange do
        writeArray i (f (readArray i b)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal

mapAudio2 :: (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2 f cx cy =
  case cx of
    AudioEnd    -> AudioEnd
    BlockRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y -> BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f x (readArray i y)) a
    AudioRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) y) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) (readArray i y)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()

mapAudioVec :: (FloatVec 32 -> FloatVec 32) -> (Float -> Float) -> Audio -> Audio
mapAudioVec f ff cx =
  case cx of
    AudioEnd     -> AudioEnd
    BlockRate x' -> BlockRate (ff x')
    AudioRate x' ->
      let
        x = toFloatVecArray x'
      in
        AudioRate
        <| freezeArray
        <| fromFloatVecArray
        <| loop a = toFloatVecArray (audioInitArray ()) for i <- each do
          writeArray i (f (readArray i x)) a

mapAudio2Vec :: (FloatVec 32 -> FloatVec 32 -> FloatVec 32) -> (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2Vec f ff cx cy =
  case cx of
    AudioEnd     -> AudioEnd
    BlockRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' -> BlockRate (ff x' y')
        AudioRate y' ->
          let
            x = fromFloat x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f x (readArray i y)) a
    AudioRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' ->
          let
            x = toFloatVecArray x'
            y = fromFloat y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) y) a
        AudioRate y' ->
          let
            x = toFloatVecArray x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) (readArray i y)) a
  where
    ia = toFloatVecArray <| audioInitArray ()

foldAudio :: (a -> Float -> a) -> a -> Audio -> a
foldAudio f init c =
  case c of
    AudioEnd    -> init
    BlockRate x -> f init x
    AudioRate b -> foldl f init b

genAudio :: (Rational -> Float) -> Audio
genAudio f =
  AudioRate
    <| freezeArray
    <| loop a = audioInitArray () for i <- each do
      let
        (Index n) = i
        sampleTime = currBlockTime + ((Rational# (fromUInt n) 1) * audioSampleDelta)
      in
        writeArray i (f sampleTime) a

-- An impulse in the first sample of the audio buffer, the rest is 0s
singleImpulse :: Audio
singleImpulse =
  AudioRate
    <| freezeArray
    <| writeArray (unsafeUIntToIndex 0) 1
    <| audioInitArray ()

const :: .a -> .b -> .a
const x _ = x

constTrue :: a -> Bool
constTrue _ = True

constTrueU :: .a -> (#.a, Bool#)
constTrueU state = (#state, True#)

accumulateAudio1 :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio
accumulateAudio1 f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#s, a#) ->
          case isRunningFunc s of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio2 :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio
accumulateAudio2 f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#s, a#) ->
              case isRunningFunc s of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio3 :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3 f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#s, a#) ->
                  case isRunningFunc s of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio
accumulateAudio1U mkState f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#isRunning, a#) ->
          case isRunning of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)

accumulateAudio2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio
accumulateAudio2U mkState f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#isRunning, a#) ->
              case isRunning of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


accumulateAudio3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3U mkState f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#isRunning, a#) ->
                  case isRunning of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


instance Eq Audio where
  eq x y =
    case x of
      AudioEnd ->
        case y of
          AudioEnd -> True
          _        -> False

      BlockRate xv ->
        case y of
          BlockRate yv -> xv == yv
          _            -> False

      AudioRate xa ->
        case y of
          AudioRate ya ->
            loop cond = True for i <- each do
              cond && readArray i xa == readArray i ya
          _ -> False

  neq x y = not (eq x y)

instance Semiring Audio where
  zero    = BlockRate 0
  one     = BlockRate 1
  add x y = mapAudio2Vec add add x y
  mul x y = mapAudio2Vec mul mul x y

instance Ring Audio where
  sub x y   = mapAudio2Vec sub sub x y
  fromInt i = BlockRate (fromInt i)

instance EuclideanRing Audio where
  div x y = mapAudio2 div x y
  rem x y = mapAudio2 rem x y

instance DivisionRing Audio where
  recip x = mapAudio recip x

instance Num Audio where
  signum x  = mapAudio signum x
  abs x     = mapAudio abs x
  copysign x sign = mapAudio2 copysign x sign

instance Field Audio where

instance Floating Audio where
  fromFloat f = BlockRate (fromFloat f)
  sqrt x      = mapAudio sqrt x
  floor     x = mapAudio floor x
  ceil      x = mapAudio ceil x
  truncate  x = mapAudio truncate x
  round     x = mapAudio round x

instance Semigroup Audio where
  append x y = x + y

instance Monoid Audio where
  mempty = 0

instance Default Audio where
  default = 0


--------------------
-- FFT
--------------------
-- FFT bins are represented as complex numbers wherein phase is encoded as the angle of a 2D vector and amplitude is encoded as the magnitude of the 2D vector.
data FFT k       = FFT (Array (NatMul BlockSize (NatMul k 4)) Complex) | FFTInterval | FFTNone | FFTEnd
data FFTWindow k = FFTWindow (Array (NatMul BlockSize (NatMul k 2)) Float)

-- TODO: rename all FFT stuff to be prepended by namespace fft
-- TODO: Num instances for FFT or not?

fftSilence :: AudioFormat f => f (FFT k)
fftSilence =
  arrayFrom 0
  |> FFT
  |> pure

mapFFT :: (Complex -> Complex) -> FFT k -> FFT k
mapFFT f c =
  case c of
    FFTEnd      -> FFTEnd
    FFTNone     -> FFTNone
    FFTInterval -> FFTInterval
    FFT b       ->
      FFT
      <| freezeArray
      <| loop a = unsafeEmptyArray () for i <- each do
        writeArray i (f (readArray i b)) a

mapFFT2 :: (Complex -> Complex -> Complex) -> FFT k -> FFT k -> FFT k
mapFFT2 f cx cy =
  case cx of
    FFTEnd      -> FFTEnd
    FFTNone     -> FFTNone
    FFTInterval -> FFTInterval
    FFT x       ->
      case cy of
        FFTEnd      -> FFTEnd
        FFTNone     -> FFTNone
        FFTInterval -> FFTInterval
        FFT y       ->
          FFT
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (f (readArray i x) (readArray i y)) a

mapFFTBuffer ::
  AudioFormat f =>
  (Array (NatMul BlockSize (NatMul k 4)) Complex -> Array (NatMul BlockSize (NatMul k 4)) Complex) ->
  f (FFT k) ->
  f (FFT k)
mapFFTBuffer f c = map mf c
  where
    mf fftChannel =
      case fftChannel of
        FFTEnd -> FFTEnd
        FFTNone -> FFTNone
        FFTInterval -> FFTInterval
        FFT b ->  FFT (f b)

composeFFTBuffers ::
  AudioFormat f =>
  (Array (NatMul BlockSize (NatMul k 4)) Complex ->
    Array (NatMul BlockSize (NatMul k 4)) Complex ->
    Array (NatMul BlockSize (NatMul k 4)) Complex) ->
  f (FFT k) ->
  f (FFT k) ->
  f (FFT k)
composeFFTBuffers f fx fy =
  map2 go fx fy
  where
    go cx cy =
      case cx of
        FFTEnd      -> FFTEnd
        FFTNone     ->
          case cy of
            FFTEnd      -> FFTEnd
            FFTInterval -> FFTInterval
            _           -> FFTNone
        FFTInterval ->
          case cy of
            FFTEnd      -> FFTEnd
            _           -> FFTInterval
        FFT x ->
          case cy of
            FFTEnd      -> FFTEnd
            FFTNone     -> FFTNone
            FFTInterval -> FFTInterval
            FFT y       -> (FFT (f x y))

natValFrom :: NatVal k -> f k -> UInt
natValFrom n _ =
  natVal n

windowNone :: FFTWindow k
windowNone =
  FFTWindow (arrayFrom 1)

windowSine :: FFTWindow k
windowSine =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (sine (pi * fromUInt (indexToUInt i + 1) / fromUInt (natValFrom NatVal i + 1))) a

windowMLTSine :: FFTWindow k
windowMLTSine =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (sine ((fromUInt (indexToUInt i) + 0.5) * (pi / fromUInt (natValFrom NatVal i)))) a

windowHann :: FFTWindow k
windowHann =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (0.5 - 0.5 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt (natValFrom NatVal i))) a

windowHamming :: FFTWindow k
windowHamming =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (0.54 - 0.46 * cosine (tau * fromUInt (indexToUInt i) / fromUInt (natValFrom NatVal i))) a

----------------------
-- audioToTimeDomain
-- This preps audio data for FFT analysis
-- Currently uses a fixed hop size of 0.5
-- First it copies the data into a circular buffer (fft needs past audio data to perform overlay-add in ifft)
-- Next it performs zero-phase zero-padding
-- Then it multiplies the audio by the supplied window function
-- And lastly it stores this in a Complex valued array for the FFT algorithm
-- TODO: use NatNextPowerOfTwo for safer FFT sizes? It would mean even more hilariously large Array types
-- TODO: something is up, maybe with windowing?!?!?!?!?!?
-- TODO: Insure next power of two!

fftIndexIsZeroBin :: UInt -> UInt -> Index (NatMul BlockSize (NatMul k 4)) -> Bool
fftIndexIsZeroBin bufferSize fftHalfSize (Index i) =
  if i < fftHalfSize then
    False
  else if i >= (bufferSize - 0) - fftHalfSize then
    False
  else
    True

fftIndexToZeroPhaseIndex :: UInt -> UInt -> Index (NatMul BlockSize (NatMul k 4)) -> Index (NatMul BlockSize (NatMul k 2))
fftIndexToZeroPhaseIndex bufferSize fftHalfSize (Index i) =
  if i < fftHalfSize then
    Index (i + fftHalfSize)
  else if i >= (bufferSize - 0) - fftHalfSize then
    Index (i - ((bufferSize - 0) - fftHalfSize))
  else
    Index i

fftArraySizeGymnastics :: Index (NatMul BlockSize (NatMul k 4)) -> Index (NatMul BlockSize k) -> Index (NatMul BlockSize k)
fftArraySizeGymnastics _ i = i

----------------------
-- Useful values
----------------------
-- BufferSize     size: BufferSize
-- FFTSize        size: BufferSize / 2
-- timeDomain     size: BufferSize
-- cBuffer        size: FFTSize
-- prevTimeDomain size: FFTSize / 2
-- overflowBuffer size: FFTSize / 2
-- window buffer  size: FFTSize

audioToTimeDomain :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Array BlockSize Float -> Maybe (*Array (NatMul BlockSize (NatMul k 4)) Complex)
audioToTimeDomain n (FFTWindow window) audio =
  case mutRefPut (#cBufferEnd, cIndex1#) mref of
    _ -> timeDomainEnd
  where
    (#(#cBuffer0, cIndex0#), mref#) = mutRefTake (\_ -> (#arrayFrom 0, 0#))
    bufferSize                      = natVal n
    fftSize                         = bufferSize / 2
    fftHalfSize                     = fftSize / 2
    fftSizeMask                     = fftSize - 1
    fftScaleFactor                  = 1 / fromUInt fftSize
    cIndex1                         = bitAnd (cIndex0 + audioBlockSize) fftSizeMask
    cBuffer2                        =
      -- Copy data into circular buffer
      loop cBuffer1 = cBuffer0 for i <- each do
        writeArray (unsafeUIntToIndex (bitAnd (indexToUInt i + cIndex0) fftSizeMask)) (readArray i audio) cBuffer1
    (#timeDomainEnd, cBufferEnd#) =
      if cIndex1 == 0 || cIndex1 == fftHalfSize then
        -- Zero-phase zero-padding for FFT analysis
        let
          (#timeDomain, cBuffer5#) =
            loop (#timeDomain0, cBuffer3#) = (#unsafeEmptyArray (), cBuffer2#) for fftIndex <- each do
              if fftIndexIsZeroBin bufferSize fftHalfSize fftIndex then
                -- zero padding
                (#writeArray fftIndex (Complex# 0 0) timeDomain0, cBuffer3#)
              else
                let
                  windowIndex      = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  wx               = readArray windowIndex window
                  circularIndex    = asTypeOf (unsafeUIntToIndex (bitAnd (indexToUInt windowIndex + cIndex1) fftSizeMask)) windowIndex
                  (#ax, cBuffer4#) = readArrayU circularIndex cBuffer3
                  c                = Complex# (ax * wx * fftScaleFactor) 0
                  -- c                = Complex# (wx) 0
                  timeDomain1      = writeArray fftIndex c timeDomain0
                in
                  (#timeDomain1, cBuffer4#)
        in
          (#Just timeDomain, cBuffer5#)
          -- if currBlockCount == 2048 then
          --   case plotFFTChannelOnce "./data/timeDomainTest.dat" (FFT (freezeArray timeDomain)) primUndefined of
          --     _ -> primUndefined
          -- else
      else
        -- In between FFT blocks
        (#Nothing, cBuffer2#)


----------------------
-- timeDomainToAudio
-- Overlap-Add method: dspguide.com/ch18/1.htm
-- Use sine window for FFT and IFFT to combine for a Hann window?
-- This is the inverse of audioToTimeDomain
-- Performs overlay-add with a hop size of 2
-- Undoes zero phase buffering

-- TODO / NOTE: don't padd with zeroes!??!!?
timeDomainToAudio :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Maybe (Array (NatMul BlockSize (NatMul k 4)) Float) -> Audio
timeDomainToAudio n (FFTWindow window) maybeTimeDomain =
  case mutRefPut (#overflowBuffer2, prevTimeDomain1, overflowIndex1#) mref of
    _ -> AudioRate (freezeArray audio)
  where
    (#(#overflowBuffer0, prevTimeDomain0, overflowIndex0#), mref#) =
      mutRefTake (\_ -> (#arrayFrom 0, arrayFrom 0, 0#))

    bufferSize      = natVal n
    fftSize         = bufferSize / 2
    fftHalfSize     = fftSize / 2
    fftSizeMask     = fftSize - 1
    fftHalfSizeMask = fftHalfSize - 1
    overflowIndex1  = bitAnd (overflowIndex0 + audioBlockSize) fftHalfSizeMask
    -- TODO: statefulness in here is causing a crash....wtf???

    -- Resynthesize and fill overflow buffer
    (#overflowBuffer1, prevTimeDomain1#) =
      case maybeTimeDomain of
        Nothing         -> (#overflowBuffer0, prevTimeDomain0#)
        Just timeDomain ->
          loop (#overflowBuffer00, prevTimeDomain00#) = asTypeOfU overflowBuffer0 prevTimeDomain0 for fftIndex0 <- each do
            let
              fftIndex  = indexBackwards NatVal fftIndex0
              fftIndexU = indexToUInt fftIndex
            in
              if fftIndexU < fftHalfSize then
                -- write contents of first half of timeDomain buffer into prevTimeDomain buffer
                let
                  windowIndex      = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  windowSample     = readArray windowIndex window
                  timeDomainSample = readArray fftIndex timeDomain
                  sample           = timeDomainSample * windowSample
                  index            = fftArraySizeGymnastics fftIndex (unsafeUIntToIndex fftIndexU)
                  prevTimeDomain01 = writeArray index sample prevTimeDomain00
                in
                  (#overflowBuffer00, prevTimeDomain01#)
              else if fftIndexU >= (bufferSize - 0) - fftHalfSize then
                -- use contents of second half of timeDomain buffer for resynthesis windowed against prevTimeDomain
                let
                  windowIndex              = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  w0                       = readArray windowIndex window
                  t0                       = readArray fftIndex timeDomain
                  (#t1, prevTimeDomain01#) = readArrayU (unsafeIndexToIndex windowIndex) prevTimeDomain00
                  sample                   = t0 * w0 + t1
                  overflowBuffer01         = writeArray (unsafeIndexToIndex windowIndex) sample overflowBuffer00
                in
                  (#overflowBuffer01, prevTimeDomain01#)
              else
                -- zero padding
                (#overflowBuffer00, prevTimeDomain00#)

    -- Fill audio buffer from overflowBuffer
    (#audio, overflowBuffer2#) =
      loop (#audio0, overflowBuffer10#) = (#audioInitArray (), overflowBuffer1#) for i <- each do
        let
          overflowIndex                = unsafeUIntToIndex (bitAnd (indexToUInt i + overflowIndex1) fftHalfSizeMask)
          (#sample, overflowBuffer11#) = readArrayU overflowIndex overflowBuffer10
          audio1                       = writeArray i sample audio0
        in
          (#audio1, overflowBuffer11#)
    -- overflowBuffer2 =
    --   if currBlockCount == 2048 then
    --     case writePlot2DToFileOnce "./data/timeDomainTest.dat" (freezeArray overflowBuffer2') primUndefined of
    --       _ -> primUndefined
    --   else
    --     overflowBuffer2'

----------------------
-- DFT
-- Naive implementation

-- dftAudio :: NatVal (NatMul BlockSize (NatMax k 2)) -> Array BlockSize Float -> FFTWindow k -> FFT k
-- dftAudio n audio (FFTWindow window) =
--   FFT (freezeArray bins1)
--   where
--     numSamples   = natVal n
--     numSamplesF  = fromUInt numSamples
--     timeDomain   = audioToTimeDomain numSamples audio window |> freezeArray
--     bins1        =
--       loop bins0 = unsafeEmptyArray () for k <- each do
--         let
--           kr  = fromUInt (indexToUInt k)
--           bin =
--             loop (Complex# fr0 fi0) = Complex# 0 0 for i <- each do
--               let
--                 ir             = fromUInt (indexToUInt i)
--                 p              = 2 * pi * kr * ir / numSamplesF
--                 c              = cosine p
--                 s              = 0 - sine p
--                 Complex# tr ti = readArray (asTypeOf i k) timeDomain
--                 fr1            = fr0 + (tr * c - ti * s)
--                 fi1            = fi0 + (tr * s + ti * c)
--               in
--                 Complex# fr1 fi1
--         in
--           writeArray k bin bins0

----------------------
-- FFT
-- radix-2 with decimation in time

fftAudio :: NatVal (NatMul BlockSize (NatMul k 4)) -> *Array (NatMul BlockSize (NatMul k 4)) Complex -> FFT k
fftAudio n timeDomain =
  aout
  |> freezeArray
  |> FFT
  where
    numSamples   = natVal n
    numSamples1  = numSamples - 1
    halfSamples  = numSamples / 2
    shiftN       = bitShiftLeft halfSamples 1
    (#_, _, ar#) = -- bit reverse
      loop (#i, j, ar#) = (#1, 0, timeDomain#) while i < numSamples1 do
        let
          (#j', m#) =
            loop (#jj, mm#) = (#j, halfSamples#) while (jj >= mm) do
              (#jj - mm, bitShiftRight mm 1#)
          j1  = j' + m
          ar1 = if j1 > i then
            let
              (#ci, a1#) = readArrayU (unsafeUIntToIndex i) ar
              (#cj, a2#) = readArrayU (unsafeUIntToIndex j1) a1
            in
              writeArray (unsafeUIntToIndex j1) ci a2 |> writeArray (unsafeUIntToIndex i) cj
            else
              ar
        in
          (#i + 1, j1, ar1#)
    (#_, _, aout#) = -- FFT
      loop (#i, n0, a0#) = (#1, 1, ar#) while (i < shiftN) do
        let
          n1 = n0
          n2 = n1 + n1
          e  = negate (twoPi / fromUInt n2)
          (#_, _, a1#) =
            loop (#j, theta, a1#) = (#0, 0, a0#) while (j < n1) do
              let
                c = cosine theta
                s = sine theta
                (#_, a2#) =
                  loop (#k, a2#) = (#j, a1#) while (k < numSamples) do
                    let
                      kN1 = k + n1
                      (#Complex# kReal kImag, ar#) = readArrayU (unsafeUIntToIndex k) a2
                      (#Complex# nReal nImag, ar1#) = readArrayU (unsafeUIntToIndex kN1) ar
                      tempr = c * nReal - s * nImag
                      tempi = s * nReal + c * nImag
                      ck = Complex# (kReal + tempr) (kImag + tempi)
                      cn = Complex# (kReal - tempr) (kImag - tempi)
                      aw =
                        writeArray (unsafeUIntToIndex k) ck ar1 |>
                        writeArray (unsafeUIntToIndex kN1) cn
                    in
                      (#k + n2, aw#)
              in
                (#j + 1, theta + e, a2#)
        in
          (#bitShiftLeft i 1, n2, a1#)

ifftAudio :: Array (NatMul BlockSize (NatMul k 4)) Complex -> Array (NatMul BlockSize (NatMul k 4)) Float
ifftAudio freqDomain =
  ifftOut
  where
    numSamples   = arrayLength NatVal freqDomain
    numSamplesF  = fromUInt numSamples
    numSamples1  = numSamples - 1
    halfSamples  = numSamples / 2
    shiftN       = bitShiftLeft halfSamples 1
    (#_, _, ar#) = -- bit reverse
      loop (#i, j, ar#) = (#1, 0, deepCopyArray freqDomain#) while i < numSamples1 do
        let
          (#j', m#) =
            loop (#jj, mm#) = (#j, halfSamples#) while (jj >= mm) do
              (#jj - mm, bitShiftRight mm 1#)
          j1  = j' + m
          ar1 = if j1 > i then
            let
              (#ci, a1#) = readArrayU (unsafeUIntToIndex i) ar
              (#cj, a2#) = readArrayU (unsafeUIntToIndex j1) a1
            in
              writeArray (unsafeUIntToIndex j1) ci a2 |> writeArray (unsafeUIntToIndex i) cj
            else
              ar
        in
          (#i + 1, j1, ar1#)
    (#_, _, aout#) = -- IFFT
      loop (#i, n0, a0#) = (#1, 1, ar#) while (i < shiftN) do
        let
          n1 = n0
          n2 = n1 + n1
          e  = (twoPi / fromUInt n2)
          (#_, _, a1#) =
            loop (#j, theta, a1#) = (#0, 0, a0#) while (j < n1) do
              let
                c = cosine theta
                s = sine theta
                (#_, a2#) =
                  loop (#k, a2#) = (#j, a1#) while (k < numSamples) do
                    let
                      kN1 = k + n1
                      (#Complex# kReal kImag, ar#) = readArrayU (unsafeUIntToIndex k) a2
                      (#Complex# nReal nImag, ar1#) = readArrayU (unsafeUIntToIndex kN1) ar
                      tempr = c * nReal - s * nImag
                      tempi = s * nReal + c * nImag
                      ck = Complex# (kReal + tempr) (kImag + tempi)
                      cn = Complex# (kReal - tempr) (kImag - tempi)
                      aw =
                        writeArray (unsafeUIntToIndex k) ck ar1 |>
                        writeArray (unsafeUIntToIndex kN1) cn
                    in
                      (#k + n2, aw#)
              in
                (#j + 1, theta + e, a2#)
        in
          (#bitShiftLeft i 1, n2, a1#)
    ifftOut = map realPart (freezeArray aout)

-- idftAudio :: Array (NatMul BlockSize (NatMax k 2)) Complex -> Audio
-- idftAudio freqDomain =
--   timeDomainToAudio numSamples windowSine (freezeArray bins1)
--   where
--     numSamples   = arrayLength NatVal freqDomain
--     numSamplesF  = fromUInt numSamples
--     bins1        =
--       loop bins0 = unsafeEmptyArray () for k <- each do
--         let
--           kr  = fromUInt (indexToUInt k)
--           bin =
--             loop (Complex# tr0 ti0) = Complex# 0 0 for i <- each do
--               let
--                 ir             = fromUInt (indexToUInt (asTypeOf i k))
--                 p              = 2 * pi * kr * ir / numSamplesF
--                 c              = cosine p
--                 s              = 0 - sine p
--                 Complex# fr fi = readArray i freqDomain
--                 tr1            = tr0 + (fr * c + fi * s)
--                 ti1            = ti0 + (fr * s - fi * c)
--               in
--                 Complex# tr1 ti1
--         in
--           writeArray k (realPart bin / numSamplesF) bins0

-- dft :: AudioFormat f => f Audio -> f (FFT k)
-- dft cs =
--   map f cs
--   where
--     f c =
--       case c of
--         AudioEnd    -> FFTEnd
--         BlockRate _ -> FFTNone
--         AudioRate a -> dftAudio NatVal a windowSine

fft :: AudioFormat f => f Audio -> f (FFT k)
fft cs =
  map f cs
  where
    f c =
      case c of
        AudioEnd        -> FFTEnd
        BlockRate _     -> FFTNone
        AudioRate audio ->
          case audioToTimeDomain NatVal windowSine audio of
            Nothing -> FFTInterval
            Just t  ->
              fftAudio NatVal t

fft' :: AudioFormat f => NatVal k -> f Audio -> f (FFT k)
fft' _ cs =
  fft cs

-- idft :: AudioFormat f => f (FFT k) -> f Audio
-- idft cs =
--   map f cs
--   where
--     f c =
--       case c of
--         FFTEnd   -> AudioEnd
--         FFTNone  -> BlockRate 0
--         FFT bins -> idftAudio bins

data IFFTResult a
  = IFFTEnd
  | IFFTNone
  | IFFTResult (Maybe a)

ifft :: AudioFormat f => f (FFT k) -> f Audio
ifft cs =
  map f cs
  where
    f c =
      case result of
        IFFTEnd               -> AudioEnd
        IFFTNone              -> BlockRate 0
        IFFTResult ifftResult -> timeDomainToAudio NatVal windowSine ifftResult
      where
        result =
          case c of
            FFTEnd      -> IFFTEnd
            FFTNone     -> IFFTNone
            FFTInterval -> IFFTResult Nothing
            FFT bins    -> IFFTResult (Just (ifftAudio bins))

--------------------------
-- FFT Effects

convolve :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
convolve a b = map2 (\ca cb -> mapFFT2 (*) ca cb) a b

fftCrossCorrelate :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftCrossCorrelate a b = map2 (\ca cb -> mapFFT2 cc ca cb) a b
  where
    cc ca cb = ca * conjugate cb

fftAutoCorrelate :: AudioFormat f => f (FFT k) -> f (FFT k)
fftAutoCorrelate a = map (\ca -> mapFFT cc ca) a
  where
    cc ca = ca * conjugate ca

fftCovariance :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftCovariance a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        numSamplesF = fromUInt <| arrayLength NatVal ba
        (#Complex# aSumR aSumI, Complex# bSumR bSumI#) =
          loop (#aSum, bSum#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
            in
              (#aSum + u, bSum + v#)
        aMean = Complex# (aSumR / numSamplesF) (aSumI / numSamplesF)
        bMean = Complex# (bSumR / numSamplesF) (bSumI / numSamplesF)
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              w = (u - aMean) * (v - bMean)
            in
              writeArray i w bc

fftAutoCovariance :: AudioFormat f => f (FFT k) -> f (FFT k)
fftAutoCovariance a = mapFFTBuffer compose a
  where
    compose ba = bb |> freezeArray
      where
        numSamplesF :: Float
        numSamplesF = fromUInt <| arrayLength NatVal ba
        (Complex# aSumR aSumI) =
          loop aSum = Complex# 0 0 for i <- each do
            let
              u = readArray i ba
            in
              aSum + u
        aMean = Complex# (aSumR / numSamplesF) (aSumI / numSamplesF)
        bb =
          loop bb = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              w = (u - aMean) * (u - aMean)
            in
              writeArray i w bb

fftAutoCrossCovariance :: AudioFormat f => f (FFT k) -> f (FFT k)
fftAutoCrossCovariance a = mapFFTBuffer compose a
  where
    compose ba = bb |> freezeArray
      where
        numSamplesF :: Float
        numSamplesF = fromUInt <| arrayLength NatVal ba
        (Complex# aSumR aSumI) =
          loop aSum = Complex# 0 0 for i <- each do
            let
              u = readArray i ba
            in
              aSum + u
        aMean = Complex# (aSumR / numSamplesF) (aSumI / numSamplesF)
        bb =
          loop bb = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              w = (u - aMean) * conjugate (u - aMean)
            in
              writeArray i w bb

fftCrossCovariance :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftCrossCovariance a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        numSamplesF = fromUInt <| arrayLength NatVal ba
        (#Complex# aSumR aSumI, Complex# bSumR bSumI#) =
          loop (#aSum, bSum#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
            in
              (#aSum + u, bSum + v#)
        aMean = Complex# (aSumR / numSamplesF) (aSumI / numSamplesF)
        bMean = Complex# (bSumR / numSamplesF) (bSumI / numSamplesF)
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              w = (u - aMean) * conjugate (v - bMean)
            in
              writeArray i w bc

-- I don't really know what this is, but it sounds cool
-- Note: very large magnitudes!
-- TODO: normalize intermediate values?
fftChaos :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftChaos a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              vj = conjugate v
              upsd = u * conjugate u
              vpsd = v * vj
              cpsd = u * vj
              w = (cpsd * cpsd) / (upsd * vpsd)
            in
              writeArray i w bc

-- spectral coherence of two signals
-- maintains phase of signal a
-- TODO: normalize intermediate values?
fftMagCoherence :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagCoherence a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              vj = conjugate v
              upsd = magnitude <| u * conjugate u
              vpsd = magnitude <| v * vj
              cpsd = magnitude <| u * vj
              w = (cpsd * cpsd) / (upsd * vpsd)
            in
              writeArray i (mkPolar w (phase u)) bc

-- phase coherence of two signals
-- maintains magnitude of signal a
-- TODO: normalize intermediate values?
fftPhaseCoherence :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftPhaseCoherence a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              vj = conjugate v
              upsd = u * conjugate u
              vpsd = v * vj
              cpsd = u * vj
              w = (cpsd * cpsd) / (upsd * vpsd)
            in
              writeArray i (mkPolar (magnitude u) (phase w)) bc

fftConjugate :: AudioFormat f => f (FFT k) -> f (FFT k)
fftConjugate c = mapFFTAudio conjugate c

-- Question: Would this be better named as fftMapBins?
mapFFTAudio :: AudioFormat f => (Complex -> Complex) -> f (FFT k) -> f (FFT k)
mapFFTAudio f c = map (\cc -> mapFFT f cc) c

mapFFTAudio2 :: AudioFormat f => (Complex -> Complex -> Complex) -> f (FFT k) -> f (FFT k) -> f (FFT k)
mapFFTAudio2 f a b = map2 (\ca cb -> mapFFT2 f ca cb) a b

-- negate bins of fft
fftNegate :: AudioFormat f => f (FFT k) -> f (FFT k)
fftNegate a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl (Complex# ar ai) = Complex# (negate ar) (negate ai)

-- Map the supplied function onto the magnitude of the bins, but maintain phase
fftMapMag :: AudioFormat f => (Float -> Float) -> f (FFT k) -> f (FFT k)
fftMapMag f a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl cma = mkPolar (f <| magnitude cma) (phase cma)

-- Map the supplied function using the magnitude of the bins of the two inputs,
-- while maintaining the phase of the first input
fftMapMag2 :: AudioFormat f => (Float -> Float -> Float) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftMapMag2 f a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (f mA mB) (phase cma)
      where
        mA = magnitude cma
        mB = magnitude cmb

-- Multiply magnitudes of a and b, but keep phase of a
fftMagMul :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMul a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (mA * mB) <| phase cma
      where
        mA = magnitude cma
        mB = magnitude cmb

-- Add magnitudes of a and b, but keep phase of a
fftMagAdd :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagAdd a b = fftMapMag2 (+) a b

-- max of magnitudes of a and b, but keep phase of a
fftMagMax :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMax a b = fftMapMag2 max a b

-- min of magnitudes of a and b, but keep phase of a
fftMagMin :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMin a b = fftMapMag2 min a b

-- square of magnitudes of fft
fftMagSquared :: AudioFormat f => f (FFT k) -> f (FFT k)
fftMagSquared a = fftMapMag sqr a

-- square root of magnitudes of fft
fftMagSqrRoot :: AudioFormat f => f (FFT k) -> f (FFT k)
fftMagSqrRoot a = fftMapMag sqrt a

fftLerp :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerp delta x y =
  mapFFTAudio2 (\cx cy -> lerpComplex cx cy delta) x y

fftLerpPolar :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerpPolar delta x y =
  mapFFTAudio2 f x y
  where
    f cx cy =
      mkPolar m p
      where
        (#mx, px#) = polar' cx
        (#my, py#) = polar' cy
        m          = lerp mx my delta
        p          = lerpTheta px py delta

fftLerpMag :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerpMag delta x y =
  fftMapMag2 (\mx my -> lerp mx my delta) x y

fftLerpPhase :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerpPhase delta x y =
  fftMapPhase2 (\px py -> lerpTheta px py delta) x y

fftMulPolar :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMulPolar x y =
  mapFFTAudio2 f x y
  where
    f cx cy =
      mkPolar m p
      where
        (#mx, px#) = polar' cx
        (#my, py#) = polar' cy
        m          = mx * my
        p          = px * py

-- Keeps the magnitudes of a, but takes the phase of b
fftCopyPhase :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftCopyPhase a b = mapFFTAudio2 (copyphase) a b
  where
    copyphase cma cmb = Complex# (magnitude cma) (phase cmb)

-- Map the supplied function using the phase of the bins of the two inputs,
-- while maintaining the magnitude of the first input
fftMapPhase2 :: AudioFormat f => (Float -> Float -> Float) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftMapPhase2 f a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (magnitude cma) (f pA pB)
      where
        pA = phase cma
        pB = phase cmb

-- TODO / NOTE: Why can we only shift bins by UInt and not Int?
-- shifts bins by offset
fftShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              bin = readArray index a
            in
              writeArray i bin b
      in
        freezeArray b

-- shift magnitudes of bins
fftMagShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftMagShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              r = readArray index a
              u = readArray i a
              result     = mkPolar (magnitude r) (phase u)
            in
              writeArray i result b
      in
        freezeArray b

-- shift magnitudes of bins, clamped, taking into account negative frequency bins
fftMagShift' :: AudioFormat f => Int -> f (FFT k) -> f (FFT k)
fftMagShift' n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        midPoint   = numSamples / 2
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              n'     = if indexToUInt i >= midPoint / 2 then n else negate n
              index  = unsafeUIntToIndex (clamp (fromInt (fromUInt (indexToUInt i) + n')) 0 numSamples)
              r      = readArray index a
              u      = readArray i a
              result = mkPolar (magnitude r) (phase u)
            in
              if (indexToUInt index < midPoint && indexToUInt i < midPoint) || (indexToUInt index >= midPoint && indexToUInt i >= midPoint) then
                writeArray i result b
              else
                b
      in
        freezeArray b

-- shift phases of bins
fftPhaseShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftPhaseShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              r = readArray index a
              u = readArray i a
              result     = mkPolar (magnitude u) (phase r)
            in
              writeArray i result b
      in
        freezeArray b

-- shift phases of bins, clamped, taking into account negative frequency bins
fftPhaseShift' :: AudioFormat f => Int -> f (FFT k) -> f (FFT k)
fftPhaseShift' n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        midPoint   = numSamples / 2
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              n'     = if indexToUInt i >= midPoint / 2 then n else negate n
              index  = unsafeUIntToIndex (clamp (fromInt (fromUInt (indexToUInt i) + n')) 0 numSamples)
              r      = readArray index a
              u      = readArray i a
              result = mkPolar (magnitude u) (phase r)
            in
              if (indexToUInt index < midPoint && indexToUInt i < midPoint) || (indexToUInt index >= midPoint && indexToUInt i >= midPoint) then
                writeArray i result b
              else
                b
      in
        freezeArray b

-- use a lambda to map phases (index -> phase -> new phase)
fftMapPhase :: AudioFormat f => (UInt -> Float -> Float) -> f (FFT k) -> f (FFT k)
fftMapPhase p f = mapFFTBuffer mapping f
  where
    mapping a = freezeArray <|
      loop b = unsafeEmptyArray () for i <- each do
        let
          c = readArray i a
          bin = mkPolar (magnitude c) (p (indexToUInt i) (phase c))
        in
          writeArray i bin b

freezeImpl ::
  AudioFormat f =>
  (TriggerState ->
    Array (NatMul BlockSize (NatMul k 4)) Complex ->
    Array (NatMul BlockSize (NatMul k 4)) Complex) ->
  f TriggerState ->
  f (FFT k) ->
  f (FFT k)
freezeImpl f trigger input = map2 doFreeze trigger input
  where
    doFreeze ctrigger cinput =
      case cinput of
        FFTEnd -> FFTEnd
        FFTNone -> FFTNone
        FFTInterval -> FFTInterval
        FFT b -> f (fst' intervalTrigger) b |> FFT
      where
        intervalTrigger ~ (#TriggerInactive, TriggerInactive#) =
          case cinput of
            FFTInterval ->
              if (ctrigger == TriggerActive)
                then (#TriggerActive, TriggerActive#)
                else (#TriggerInactive, snd' intervalTrigger#)
            _ -> if snd' intervalTrigger == TriggerActive
              then (#TriggerActive, TriggerInactive#)
              else (#ctrigger, TriggerInactive#)

freezeTick ::
  TriggerState ->
  Array (NatMul BlockSize (NatMul k 4)) Complex ->
  Array (NatMul BlockSize (NatMul k 4)) Complex
freezeTick trigger buffer = buffer2
  where
    buffer2 ~ (arrayFrom 0) =
      case trigger of
        TriggerInactive -> deepCopyArray buffer2
        TriggerActive -> deepCopyArray buffer -- HACK for array deep copy bug with state

fftFreeze :: AudioFormat f => f TriggerState -> f (FFT k) -> f (FFT k)
fftFreeze trigger input = freezeImpl freezeTick trigger input

magFreezeTick ::
  TriggerState ->
  Array (NatMul BlockSize (NatMul k 4)) Complex ->
  Array (NatMul BlockSize (NatMul k 4)) Complex
magFreezeTick trigger buffer = buffer2
  where
    buffer2 ~ (arrayFrom 0) =
      case trigger of
        TriggerInactive -> freezeArray <|
          loop b3 = unsafeEmptyArray () for i <- each do
            let
              m = readArray i buffer2 |> magnitude
              p = readArray i buffer |> phase
            in
              writeArray i (mkPolar m p) b3
        TriggerActive -> deepCopyArray buffer -- HACK for array deep copy bug with state

fftMagFreeze :: AudioFormat f => f TriggerState -> f (FFT k) -> f (FFT k)
fftMagFreeze trigger input = freezeImpl magFreezeTick trigger input

phaseFreezeTick ::
  TriggerState ->
  Array (NatMul BlockSize (NatMul k 4)) Complex ->
  Array (NatMul BlockSize (NatMul k 4)) Complex
phaseFreezeTick trigger buffer = buffer2
  where
    buffer2 ~ (arrayFrom 0) =
      case trigger of
        TriggerInactive -> freezeArray <|
          loop b3 = unsafeEmptyArray () for i <- each do
            let
              p = readArray i buffer2 |> phase
              m = readArray i buffer |> magnitude
            in
              writeArray i (mkPolar m p) b3
        TriggerActive -> deepCopyArray buffer -- HACK for array deep copy bug with state

fftPhaseFreeze :: AudioFormat f => f TriggerState -> f (FFT k) -> f (FFT k)
fftPhaseFreeze trigger input = freezeImpl phaseFreezeTick trigger input

-- (magnitude -> phase) (phase -> magnitude) mapping
fftMagPhaseFlip :: AudioFormat f => f (FFT k) -> f (FFT k)
fftMagPhaseFlip a = mapFFTBuffer doFlip a
  where
    doFlip a = freezeArray <|
      loop b = unsafeEmptyArray () for i <- each do
        let
          (#m, p#) = readArray i a |> polar'
          bin = mkPolar p m
        in
          writeArray i bin b

data SpliceType = SpliceFirst | SpliceSecond

instance Enum SpliceType where
  toEnum   x = if x == 0 then SpliceFirst else SpliceSecond
  fromEnum x =
    case x of
      SpliceFirst -> 0
      _    -> 1

instance Eq SpliceType where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

-- splice bins from two sources using selector function
fftSplice :: AudioFormat f => (UInt -> SpliceType) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftSplice f a b = composeFFTBuffers splice a b
  where
    splice ba bb = bc |> freezeArray
      where
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              c = if (f <| indexToUInt i) == SpliceFirst
                then readArray i ba
                else readArray i bb
            in
              writeArray i c bc

-- project the entire buffer of A onto B,
-- interpretting the buffers as higher dimensional vectors of complex numbers
fftProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftProjection a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        (#sqrNorm, dot#) =
          loop (#sqrNorm, dot#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              cv = conjugate v
              uv = u * cv
              vv = v * cv
            in
              (#sqrNorm + vv, dot + uv#)
        norm = sqrt sqrNorm
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              v = readArray i bb
            in
              writeArray i (v / norm * dot) bc

-- project the entire buffer of A onto B,
-- interpretting the buffers as higher dimensional vectors of complex numbers
fftPerpendicularProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftPerpendicularProjection a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        (#sqrNorm, dot#) =
          loop (#sqrNorm, dot#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              cv = conjugate v
              uv = u * cv
              vv = v * cv
            in
              (#sqrNorm + vv, dot + uv#)
        norm = sqrt sqrNorm
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
            in
              writeArray i (u - (v / norm * dot)) bc

-- projection of the complex bins of a onto b, interpretting each bin as real 2D vectors
fftBinProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = Complex# (nbr * d) (nbi * d)
      where
        mb = magnitude (Complex# br bi)
        (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
        d = (ar * br + ai * bi)

-- projection of the mag/phase of the bins of a onto b,
-- interpretting polar coordinates as real 2D vectors
fftBinPolarProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinPolarProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = mkPolar (nmb * d) (npb * d)
      where
        ca = Complex# ar ai
        cb = Complex# br bi
        ma = magnitude ca
        mb = magnitude cb
        pa = phase ca
        pb = phase cb
        sqa = ma * ma + pa * pa
        pma = if sqa /= 0 then sqrt sqa else 0
        sqb = mb * mb + pb * pb
        pmb = if sqb /= 0 then sqrt (mb * mb + pb * pb) else 0
        (#nmb, npb#) = if pmb > 0 then (#(mb / pmb), (pb / pmb)#) else (#0, 0#)
        d = (ma * mb + pa * pb)

-- Perpendicular projection of the complex bins of a onto b, interpretting each bin as real 2D vectors
fftBinPerpendicularProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinPerpendicularProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = Complex# (ar - nbr * d) (ai - nbi * d)
      where
        mb = magnitude (Complex# br bi)
        (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
        d = (ar * br + ai * bi)

-- Perpendicular projection of the mag/phase of the bins of a onto b,
-- interpretting polar coordinates as real 2D vectors
fftBinPolarPerpendicularProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinPolarPerpendicularProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = mkPolar (ma - (nmb * d)) (pa - (npb * d))
      where
        ca = Complex# ar ai
        cb = Complex# br bi
        ma = magnitude ca
        mb = magnitude cb
        pa = phase ca
        pb = phase cb
        smb = mb * mb + pb * pb
        pmb = if smb /= 0 then sqrt smb else 0
        (#nmb, npb#) = if pmb > 0 then (#(mb / pmb), (pb / pmb)#) else (#0, 0#)
        d = (ma * mb + pa * pb)

-- projection the complex bins of a onto b, interpretting each bin as real 2D vectors
fftComplexProjection :: AudioFormat f => Complex -> f (FFT k) -> f (FFT k)
fftComplexProjection (Complex# br bi) a = mapFFTAudio dot a
  where
    (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
    mb = magnitude (Complex# br bi)
    dot (Complex# ar ai) = Complex# (nbr * d) (nbi * d)
      where
        d = (ar * br + ai * bi)

-- rotate phases by radians
fftPhaseRotate :: AudioFormat f => Float -> f (FFT k) -> f (FFT k)
fftPhaseRotate f a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl cma = mkPolar (magnitude cma) (phase cma |> add f)

fftComplexPlaneAttack :: AudioFormat f => Complex -> f (FFT k) -> f (FFT k)
fftComplexPlaneAttack z f = mapFFTAudio mapping f
  where
    mapping a = (z - a) / (1 - (z * conjugate a))

fftIsogonalMapA :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapA f = mapFFTAudio mapping f
  where
    sqrt2 = sqrt 2
    mapping z = sqrt2 * (conjugate <| sqrt (1 / z))

fftIsogonalMapB :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapB f = mapFFTAudio mapping f
  where
    mapping z = (pow z 2) / 2

fftIsogonalMapC :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapC f = mapFFTAudio mapping f
  where
    sqrt2 = sqrt 2
    mapping z = sqrt2 * sqrt z

fftIsogonalMapD :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapD f = mapFFTAudio mapping f
  where
    mapping z = 1 / z

fftIsogonalMapE :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapE f = mapFFTAudio mapping f
  where
    mapping z = exp z

fftIsogonalMapF :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapF f = mapFFTAudio mapping f
  where
    mapping z = sine z

fftIsogonalMapG :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapG f = mapFFTAudio mapping f
  where
    mapping z = cosine z

fftIsogonalMapH :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapH f = mapFFTAudio mapping f
  where
    mapping z = sqrt (2 / z)

fftNormalizeMags :: AudioFormat f => f (FFT k) -> f (#FFT k, Float#)
fftNormalizeMags fx =
  map f fx
  where
    f x =
      case x of
        FFTEnd      -> (#FFTEnd, 0#)
        FFTNone     -> (#FFTNone, 0#)
        FFTInterval -> (#FFTInterval, 0#)
        FFT buffer  ->
          let
            highestMag =
              loop hm = 0 for i <- each do
                max (magnitude (readArray i buffer)) hm
            rHighestMag = 1 / highestMag
            normalizedBuffer =
              loop nb = unsafeEmptyArray () for i <- each do
                let
                  (#m, p#) = polar' (readArray i buffer)
                  newBin   = mkPolar (m * rHighestMag) p
                in
                  writeArray i newBin nb
          in
            (#FFT (freezeArray normalizedBuffer), highestMag#)

-- TODO: Iterating after midpoint is fuxored
-- TODO: This doesn't handle pitch shifting up currently! Only pitch shifting down
fftPitchShiftCrude :: AudioFormat f => Float -> f (FFT k) -> f (FFT k)
fftPitchShiftCrude pitchRatio ffft =
  map f ffft
  where
    f cfft =
      case cfft of
        FFTEnd      -> FFTEnd
        FFTNone     -> FFTNone
        FFTInterval -> FFTInterval
        FFT bins    ->
          let
            numBins       = arrayLength NatVal bins
            numBinsHalf   = numBins / 2
            binFreqWidth  = audioSampleRateF / fromUInt numBins
            pitchRatioInv = 1 / pitchRatio
          in
            FFT <| freezeArray <| loop bins0 = unsafeEmptyArray () for i0 <- each do
              let
                i                  = if pitchRatio < 1.0 then unsafeUIntToIndex (indexToUInt i0) else indexBackwards NatVal i0 -- We iteratre backwards if we're shift bins upwards, Also some weird shit with type checking in core for i0 in the then branch here
                shiftF             = if indexToUInt i < numBinsHalf then fromUInt (indexToUInt i) * pitchRatio else ((fromUInt (indexToUInt i) - fromUInt numBinsHalf) * pitchRatioInv) + fromUInt numBinsHalf
                shiftI             = unsafeUIntToIndex (floatToUInt shiftF)
                (#m, p#)           = readArray i bins |> polar'
                bins1              = writeArray i (Complex# 0 0) bins0
                (#prevBin, bins2#) = readArrayU shiftI bins1 -- NOTE: Should we add overlapping shifted bins together? Replace them? Average them?
                bin'               = mkPolar (magnitude prevBin + m) p
                bins3              =
                  if (indexToUInt shiftI < numBinsHalf && indexToUInt i < numBinsHalf) || (indexToUInt shiftI >= numBinsHalf && indexToUInt i >= numBinsHalf) then
                    writeArray shiftI bin' bins2
                  else
                    bins2
              in
                bins3

fftBinOpWithNormMag :: AudioFormat f => (f (FFT k) -> f (FFT k) -> f (FFT k)) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinOpWithNormMag op fx fy =
  op nxs nys
  |> map3 magAdjustf mxs mys
  where
    nmax           = fftNormalizeMags fx
    nmay           = fftNormalizeMags fy
    nxs            = map fst' nmax
    nys            = map fst' nmay
    mxs            = map snd' nmax
    mys            = map snd' nmay
    mf magAdjust c =
      mkPolar (m * magAdjust) p
      where
        (#m, p#) = polar' c
    magAdjustf magAdjustX magAdjustY fftx =
      mapFFT (mf ((magAdjustX + magAdjustY) * 0.5)) fftx
      -- mapFFT (mf (max magAdjustX magAdjustY)) fftx

--------------------------

plotAudioOnce :: Array n Char -> Mono Audio -> *World -> *World
plotAudioOnce name (Mono a) w =
    case a of
      AudioEnd    -> w
      BlockRate _ -> w
      AudioRate audioBuffer -> writePlot2DToFileOnce name audioBuffer w

plotFFTChannelOnce :: Array n Char -> FFT k -> *World -> *World
plotFFTChannelOnce name f w =
  case f of
    FFT fftBuffer ->
      let
        realBuffer =
          freezeArray
          <| loop realBuffer0 = unsafeEmptyArray () for i <- each do
            writeArray i (magnitude (readArray i fftBuffer)) realBuffer0
      in
        writePlot2DToFileOnce name realBuffer w
    _ -> w

plotFFTOnce :: Array n Char -> Mono (FFT k) -> *World -> *World
plotFFTOnce name (Mono fftBuffer) w =
  plotFFTChannelOnce name fftBuffer w


--------------------
-- AudioFormat
--------------------
data Mono a             = Mono a
data Stereo a           = Stereo# a a
data Quad a             = Quad# a a a a
data Ambisonic a        = Ambisonic# a a a a
data Seconds (n :: Nat) = Seconds

oneSecondInSeconds :: Seconds 1
oneSecondInSeconds = Seconds

oneMinuteInSeconds :: Seconds 60
oneMinuteInSeconds = Seconds

oneHourInSeconds :: Seconds 3600
oneHourInSeconds = Seconds

-- TODO: Equal power panning
class (Functor f, FunctorN f, Applicative f, Foldable f) => AudioFormat f where
  accumulate1  :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio
  accumulate2  :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio
  accumulate3  :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio -> f Audio
  accumulate1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio
  accumulate2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio
  accumulate3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio -> f Audio
  pan          :: Mono Audio -> f Audio -> Stereo Audio
  mixMono      :: Num a => f a -> Mono a
  mixStereo    :: Num a => f a -> Stereo a
  outAudio     :: UInt -> f Audio -> *World -> *World
  numChannels  :: f a -> UInt
  channelNums  :: f UInt

stereo :: Mono a -> Mono a -> Stereo a
stereo (Mono l) (Mono r) = Stereo# l r

stereoSpread :: Floating a => Mono a -> Mono a -> a -> Stereo a
stereoSpread (Mono l) (Mono r) spread =
  Stereo# (l * spread' + r * spread) (l * spread + r * spread')
  where
    spread' = 1 - spread

stereoSplit :: Stereo a -> (Mono a, Mono a)
stereoSplit (Stereo# l r) = (Mono l, Mono r)

stereoReMix :: Floating a => a -> Stereo a -> Stereo a
stereoReMix spread (Stereo# l r) =
  stereoSpread (Mono l) (Mono r) spread

left :: Stereo a -> Mono a
left (Stereo# l _) = Mono l

right :: Stereo a -> Mono a
right (Stereo# _ r) = Mono r

stereoFlip :: Stereo a -> Stereo a
stereoFlip (Stereo# l r) = Stereo# r l

instance Functor Mono where
  map f (Mono x) = Mono (f x)

instance FunctorN Mono where
  map2 f (Mono x) (Mono y)                   = Mono (f x y)
  map3 f (Mono x) (Mono y) (Mono z)          = Mono (f x y z)
  map4 f (Mono w) (Mono x) (Mono y) (Mono z) = Mono (f w x y z)

instance Applicative Mono where
  pure x               = Mono x
  ap (Mono f) (Mono x) = Mono (f x)

instance Foldable Mono where
  fold (Mono x)      = x
  foldl f i (Mono x) = f i x

instance AudioFormat Mono where
  outAudio  n (Mono c)  w                                = outChannel n c w
  accumulate1 f isRunning (Mono c)                       = Mono (accumulateAudio1 f isRunning c)
  accumulate2 f isRunning (Mono x) (Mono y)              = Mono (accumulateAudio2 f isRunning x y)
  accumulate3 f isRunning (Mono x) (Mono y) (Mono z)     = Mono (accumulateAudio3 f isRunning x y z)
  accumulate1U mk f isRunning (Mono c)                   = Mono (accumulateAudio1U mk f isRunning c)
  accumulate2U mk f isRunning (Mono x) (Mono y)          = Mono (accumulateAudio2U mk f isRunning x y)
  accumulate3U mk f isRunning (Mono x) (Mono y) (Mono z) = Mono (accumulateAudio3U mk f isRunning x y z)
  pan (Mono amount) (Mono input)                         = Stereo# (input * (1 - amount)) (input * amount)
  mixMono x                                              = x
  mixStereo (Mono x)                                     = Stereo# x x
  numChannels _                                          = 1
  channelNums                                            = Mono 0

instance Functor Stereo where
  map f (Stereo# x y) = Stereo# (f x) (f y)

instance FunctorN Stereo where
  map2 f (Stereo# x1 x2) (Stereo# y1 y2)                                 = Stereo# (f x1 y1) (f x2 y2)
  map3 f (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2)                 = Stereo# (f x1 y1 z1) (f x2 y2 z2)
  map4 f (Stereo# w1 w2) (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2) = Stereo# (f w1 x1 y1 z1) (f w2 x2 y2 z2)

instance Applicative Stereo where
  pure x                             = Stereo# x x
  ap (Stereo# f1 f2) (Stereo# x1 x2) = Stereo# (f1 x2) (f2 x2)

instance Foldable Stereo where
  fold (Stereo# l r)      = l <> r
  foldl f i (Stereo# l r) = f (f i l) r

instance AudioFormat Stereo where
  outAudio  n (Stereo# l r) w                                                 = outChannel (n + 1) r (outChannel n l w)
  accumulate1 f isRunning (Stereo# l r)                                       = Stereo# (accumulateAudio1 f isRunning l) (accumulateAudio1 f isRunning r)
  accumulate2 f isRunning (Stereo# xl xr) (Stereo# yl yr)                     = Stereo# (accumulateAudio2 f isRunning xl yl) (accumulateAudio2 f isRunning xr yr)
  accumulate3 f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr)     = Stereo# (accumulateAudio3 f isRunning xl yl zl) (accumulateAudio3 f isRunning xr yr zr)
  accumulate1U mk f isRunning (Stereo# l r)                                   = Stereo# (accumulateAudio1U mk f isRunning l) (accumulateAudio1U mk f isRunning r)
  accumulate2U mk f isRunning (Stereo# xl xr) (Stereo# yl yr)                 = Stereo# (accumulateAudio2U mk f isRunning xl yl) (accumulateAudio2U mk f isRunning xr yr)
  accumulate3U mk f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr) = Stereo# (accumulateAudio3U mk f isRunning xl yl zl) (accumulateAudio3U mk f isRunning xr yr zr)
  pan (Mono amount) (Stereo# l r)                                             = Stereo# (l * (1 - amount)) (r * amount)
  mixMono (Stereo# l r)                                                       = Mono (l + r)
  mixStereo x                                                                 = x
  numChannels _                                                               = 2
  channelNums                                                                 = Stereo# 0 1

-- Mono
instance Eq a => Eq (Mono a) where
  eq  (Mono x) (Mono y) = eq  x y
  neq (Mono x) (Mono y) = neq x y

instance Ord a => Ord (Mono a) where
  lt  (Mono x) (Mono y) = lt  x y
  gt  (Mono x) (Mono y) = gt  x y
  lte (Mono x) (Mono y) = lte x y
  gte (Mono x) (Mono y) = gte x y
  max (Mono x) (Mono y) = Mono (max x y)
  min (Mono x) (Mono y) = Mono (min x y)

instance Semiring a => Semiring (Mono a) where
  zero                  = Mono zero
  one                   = Mono one
  add (Mono x) (Mono y) = Mono (x + y)
  mul (Mono x) (Mono y) = Mono (x * y)

instance Ring a => Ring (Mono a) where
  fromInt i             = Mono (fromInt i)
  sub (Mono x) (Mono y) = Mono (x - y)

instance EuclideanRing a => EuclideanRing (Mono a) where
  div (Mono x) (Mono y) = Mono (x / y)
  rem (Mono x) (Mono y) = Mono (rem x y)

instance DivisionRing a => DivisionRing (Mono a) where
  recip (Mono c) = Mono (recip c)

instance Num a => Num (Mono a) where
  signum (Mono c) = Mono (signum c)
  abs    (Mono c) = Mono (abs c)
  copysign (Mono x) (Mono sign) = Mono (copysign x sign)

instance Field a => Field (Mono a) where

instance Floating a => Floating (Mono a) where
  fromFloat f       = Mono (fromFloat f)
  sqrt     (Mono c) = Mono (sqrt c)
  floor    (Mono x) = Mono (floor x)
  ceil     (Mono x) = Mono (ceil x)
  truncate (Mono x) = Mono (truncate x)
  round    (Mono x) = Mono (round x)

instance Semigroup a => Semigroup (Mono a) where
  append (Mono x) (Mono y) = Mono (append x y)

instance Monoid a => Monoid (Mono a) where
  mempty = Mono mempty

-- TODO: Eq and Ord instances Audio!

-- Stereo
instance Eq a => Eq (Stereo a) where
  eq  (Stereo# xl xr) (Stereo# yl yr) = eq  xl yl && eq  xr yr
  neq (Stereo# xl xr) (Stereo# yl yr) = neq xl yl || neq xr yr

instance Ord a => Ord (Stereo a) where
  lt  (Stereo# xl xr) (Stereo# yl yr) = lt  xl yl && lt  xr yr
  gt  (Stereo# xl xr) (Stereo# yl yr) = gt  xl yl && gt  xr yr
  lte (Stereo# xl xr) (Stereo# yl yr) = lte xl yl && lte xr yr
  gte (Stereo# xl xr) (Stereo# yl yr) = gte xl yl && gte xr yr
  min (Stereo# xl xr) (Stereo# yl yr) = Stereo# (min xl yl) (min xr yr)
  max (Stereo# xl xr) (Stereo# yl yr) = Stereo# (max xl yl) (max xr yr)

instance Semiring a => Semiring (Stereo a) where
  zero                                = Stereo# zero zero
  one                                 = Stereo# one one
  add (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl + yl) (xr + yr)
  mul (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl * yl) (xr * yr)

instance Ring a => Ring (Stereo a) where
  fromInt i                           = let c = fromInt i in Stereo# c c
  sub (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl - yl) (xr - yr)

instance EuclideanRing a => EuclideanRing (Stereo a) where
  div (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl / yl) (xr / yr)
  rem (Stereo# xl xr) (Stereo# yl yr) = Stereo# (rem xl yl) (rem xr yr)

instance DivisionRing a => DivisionRing (Stereo a) where
  recip (Stereo# l r) = Stereo# (recip l) (recip r)

instance Num a => Num (Stereo a) where
  signum (Stereo# l r) = Stereo# (signum l) (signum r)
  abs    (Stereo# l r) = Stereo# (abs l) (abs r)
  copysign (Stereo# lx rx) (Stereo# ly ry) = Stereo# (copysign lx ly) (copysign rx ry)

instance Field a => Field (Stereo a) where

instance Floating a => Floating (Stereo a) where
  fromFloat f            = let c = (fromFloat f) in Stereo# c c
  sqrt     (Stereo# l r) = Stereo# (sqrt l) (sqrt r)
  floor    (Stereo# l r) = Stereo# (floor l) (floor r)
  ceil     (Stereo# l r) = Stereo# (ceil l) (ceil r)
  truncate (Stereo# l r) = Stereo# (truncate l) (truncate r)
  round    (Stereo# l r) = Stereo# (round l) (round r)

instance Semigroup a => Semigroup (Stereo a) where
  append (Stereo# xl xr) (Stereo# yl yr)  = Stereo# (append xl yl) (append xr yr)

instance Monoid a => Monoid (Stereo a) where
  mempty = Stereo# mempty mempty



--------------------
-- Audio File
--------------------

data LoopType = Loop | DontLoop

-- TODO: Derive enum with efficient implementations
instance Enum LoopType where
  toEnum   x = if x == 0 then Loop else DontLoop
  fromEnum x =
    case x of
      Loop -> 0
      _    -> 1

instance Eq LoopType where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

data AudioFile =
  AudioFile#
    UInt        -- numChannels
    UInt        -- numSamples
    (Ptr Float) -- data

silentAudioFile :: AudioFile
silentAudioFile =
  AudioFile# 0 0 primUndefined

unsafeAudioFileOpen :: Ptr Char -> UInt -> Ptr ()
unsafeAudioFileOpen fileNamePtr fileNameLength =
  primUndefined

audioFileOpen' :: Ptr Char -> UInt -> Maybe AudioFile
audioFileOpen' fileName fileNameLength =
  snd' maybeMaybeAudioFile
  where
    maybeMaybeAudioFile ~ (#0, Nothing#) =
      if fst' maybeMaybeAudioFile > 0 then
        maybeMaybeAudioFile
      else
        let
          AudioFile# numChannels numSamples dataPtr =
            unsafeAudioFileOpen fileName fileNameLength
            |> unsafePtrCast
            |> unsafePtrPeek 0
        in
          if numSamples == 0 then
            (#1, Nothing#)
          else
            (#1, Just (AudioFile# numChannels numSamples dataPtr)#)

audioFileOpen :: Array n Char -> Maybe AudioFile
audioFileOpen fileName =
  audioFileOpen' (unsafeArrayToPtr fileName) (arrayLength NatVal fileName)


-- TODO: Loop type!
audioFilePlayTick :: UInt -> LoopType -> UInt -> UInt -> Ptr Float -> Float -> Float -> (#Float, Float#)
audioFilePlayTick channelNum loopType numChannels numSamples dataPtr freq phase0 =
  (#phase1, out#)
  where
    numFrames = numChannels * numSamples
    phase1    = fma freq recipSampleRate phase0
    findex    = phase1 * audioSampleRateF
    delta     = (floor findex + 1) - findex
    index1    = floatToUInt findex * numChannels + channelNum
    index0    = index1 - numChannels
    index2    = index1 + numChannels
    index3    = index2 + numChannels
    out       =
      if (loopType == DontLoop) && (index0 >= numSamples || index1 >= numSamples || index2 >= numSamples || index3 >= numSamples) then
        0
      else
        let
          sample0 = unsafePtrPeek (index0 % numSamples) dataPtr
          sample1 = unsafePtrPeek (index1 % numSamples) dataPtr
          sample2 = unsafePtrPeek (index2 % numSamples) dataPtr
          sample3 = unsafePtrPeek (index3 % numSamples) dataPtr
        in
          cubicInterpolation sample0 sample1 sample2 sample3 delta

-- TODO: data folder?
-- TODO: Sum type for AudioFile instead of manually checking against members for validity
-- TODO / HACK: Punting and doing mono audio files for now. In the future figure out how to map audio files to AudioFormat (maybe stick in class definition?)
audioFilePlay :: LoopType -> Mono Audio -> AudioFile -> Mono Audio
audioFilePlay loopType freq (AudioFile# numChannels numSamples dataPtr) =
  if numChannels == 0 || numSamples == 0 then
    0
  else
    accumulate1 (audioFilePlayTick 0 loopType numChannels numSamples dataPtr) constTrue freq


----------------------
-- AudioBuffer
-- Represents a non-interleaved single channel of audio data inside a dynamically sized array of data
----------------------

data AudioBuffer = AudioBuffer# (.Ptr Float) UInt
-- TODO: audioBufferFromFile  :: AudioFormat f => AudioFile -> f AudioBuffer
-- TODO: audioBufferRecord    :: AudioFormat f => Nat s -> LoopType -> f Audio -> f AudioBuffer
-- TODO: Ensure power of 2 and use bitAnd + sizeMask instead of % (which is stupid slow)
-- TODO: Double check playback with negative rates, perhaps delta would be off?
-- TODO: TEEEECCCCHNNNICALLY we should buffer the audio files across the tick such that the file value would be the same across the entirety of the tick. This is required to maintain referential transparency

silentAudioBuffer :: AudioFormat f => f (AudioBuffer)
silentAudioBuffer =
  pure (AudioBuffer# primUndefined 0)

audioBufferDuration :: AudioFormat f => f (AudioBuffer) -> Float
audioBufferDuration audioBuffers =
  foldl f 0 audioBuffers
  where
    f _ (AudioBuffer# _ numSamples) = fromUInt numSamples / audioSampleRateF

-- NOTE: This dynamically allocates memory which IS NOT reclaimed by the memory management system!!!
audioBufferFromFileGo :: AudioFormat f => AudioFile -> f AudioBuffer
audioBufferFromFileGo (AudioFile# fileNumChannels numSamples audioData) =
  if numSamples == 0 then
    silentAudioBuffer
  else
    let
      nChannels    = numChannels channelNums
      f channelNum =
        AudioBuffer# (unsafePtrCast bufferData) numSamples
        where
          numFrames            = fileNumChannels * numSamples
          (#_, _, bufferData#) =
            -- Deep copy interleaved data
            loop (#fileIndex, bufferIndex, bufferData0#) = (#0, 0, ptrMalloc numSamples#) while fileIndex < numFrames do
              let
                sample      = unsafePtrPeek (fileIndex + (channelNum % nChannels)) audioData
                bufferData1 = unsafePtrPoke bufferIndex sample bufferData0
              in
                (#fileIndex + fileNumChannels, bufferIndex + 1, bufferData1#)
    in
      map f channelNums

audioBufferFromFile :: AudioFormat f => AudioFile -> f AudioBuffer
audioBufferFromFile af =
  doOnce audioBufferFromFileGo af

audioBufferOpen :: Array n Char -> Mono AudioBuffer
audioBufferOpen name =
  audioFileOpen name
  |> unwrapOr silentAudioFile
  |> audioBufferFromFile

audioBufferFromArray :: AudioFormat f => f (Array n Float) -> f AudioBuffer
audioBufferFromArray arrays =
  map f arrays
  where
    f array =
      AudioBuffer# (unsafeArrayToPtr array) (arrayLength NatVal array)

data AudioArray s = AudioArray# ()

mkAudioArray :: Seconds s -> .Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) Float
mkAudioArray _ =  (arrayFrom 0)

mkAudioArrayPtr :: Seconds s -> .Ptr Float
mkAudioArrayPtr durationSeconds = unsafeArrayToPtr (mkAudioArray durationSeconds)

mkAudioArrayUnsafeEmpty :: Seconds s -> .Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) Float
mkAudioArrayUnsafeEmpty _ = unsafeEmptyArray () |> freezeArray

audioBufferEmpty :: AudioFormat f => Seconds n -> f AudioBuffer
audioBufferEmpty durationSeconds =
  mkAudioArray durationSeconds |> pure |> audioBufferFromArray

audioBufferUnsafeEmpty :: AudioFormat f => Seconds n -> f AudioBuffer
audioBufferUnsafeEmpty durationSeconds =
  mkAudioArrayUnsafeEmpty durationSeconds |> pure |> audioBufferFromArray

audioBufferWrite :: AudioFormat f =>  Seconds n -> f Audio -> f AudioBuffer
audioBufferWrite durationSeconds a =
  map f a
  where
    f ac =
      case mutRefTake (\_ -> mkAudioArrayPtr durationSeconds) of
        (#ptrA, mref#) ->
          let
            ptrA' :: *Ptr Float
            ptrA' =
              case ac of
                AudioEnd -> ptrA
                BlockRate b ->
                  fst' <|
                  loop (#loopPtrA, i#) = (#ptrA, 0#) while i < audioBlockSize do
                    (#unsafePtrPoke (sampleIndex + i) b loopPtrA, i + 1#)
                AudioRate as ->
                  loop loopPtrA = ptrA for i <- each do
                    let
                      v = readArray i as
                    in
                      unsafePtrPoke (sampleIndex + indexToUInt i) v loopPtrA
            ptrA'' = case mutRefPutAudioArrayPtr ptrA' mref of
              Just jPtrA -> jPtrA
              Nothing -> primUndefined -- Should never happen?
          in
            AudioBuffer# ptrA'' durationSamples
      where
        durationSamples = natSecondsToNatBufferSamples durationSeconds |> natValGetFrom |> natVal
        sampleIndexRaw ~ 0 = sampleIndexRaw + audioBlockSize
        sampleIndex =  (sampleIndexRaw - audioBlockSize) % durationSamples

audioBufferPlayTick :: AudioBuffer -> LoopType -> Float -> Float -> (#Float, Float#)
audioBufferPlayTick (AudioBuffer# audioBuffer numSamples) loopType freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    findex = phase1 * audioSampleRateF
    delta  = (floor findex + 1) - findex
    index1 = floatToUInt findex
    index0 = index1 - 1
    index2 = index1 + 1
    index3 = index2 + 1
    out    =
      if (loopType == DontLoop) && (index0 >= numSamples || index1 >= numSamples || index2 >= numSamples || index3 >= numSamples) then
        0
      else
        let
          sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
          sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
          sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
          sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
        in
          cubicInterpolation sample0 sample1 sample2 sample3 delta

audioBufferPlay :: AudioFormat f => LoopType -> f Audio -> f AudioBuffer -> f Audio
audioBufferPlay loopType freq audioBuffers =
  map2 f audioBuffers freq
  where
    f ab fc =
      accumulateAudio1 (audioBufferPlayTick ab loopType) constTrue fc

audioBufferPlayTick' :: AudioBuffer -> LoopType -> Float -> Float -> Float -> (#Float, Float#)
audioBufferPlayTick' (AudioBuffer# audioBuffer numSamples) loopType freq phaseOffset phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    findex = (phase1 + phaseOffset) * audioSampleRateF
    delta  = (floor findex + 1) - findex
    index1 = floatToUInt findex
    index0 = index1 - 1
    index2 = index1 + 1
    index3 = index2 + 1
    out    =
      if (loopType == DontLoop) && (index0 >= numSamples || index1 >= numSamples || index2 >= numSamples || index3 >= numSamples) then
        0
      else
        let
          sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
          sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
          sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
          sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
        in
          cubicInterpolation sample0 sample1 sample2 sample3 delta

audioBufferPlay' :: AudioFormat f => LoopType -> f Audio -> f Audio -> f AudioBuffer -> f Audio
audioBufferPlay' loopType freq phaseOffset audioBuffers =
  map3 f audioBuffers freq phaseOffset
  where
    f ab fc pc =
      accumulateAudio2 (audioBufferPlayTick' ab loopType) constTrue fc pc

audioBufferPlayAtRatioTick :: AudioBuffer -> Float -> Float -> (#Float, Float#)
audioBufferPlayAtRatioTick (AudioBuffer# audioBuffer numSamples) phaseOffset _ =
  (#phase, out#)
  where
    phase1  = rem phaseOffset 1
    phase11 = 1 + phase1
    phase   = if phase1 < 0 then phase11 else phase1
    findex  = phase * fromUInt numSamples
    delta   = (floor findex + 1) - findex
    index1  = floatToUInt findex
    index0  = index1 - 1
    index2  = index1 + 1
    index3  = index2 + 1
    out     =
      let
        sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
        sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
        sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
        sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
      in
        cubicInterpolation sample0 sample1 sample2 sample3 delta

-- durationRatio is wrapped to buffer duration, normalized as 0.0 - 1.0
audioBufferPlayAtRatio :: AudioFormat f => f AudioBuffer -> f Audio -> f Audio
audioBufferPlayAtRatio audioBuffers durationRatio =
  map2 f audioBuffers durationRatio
  where
    f ab pc =
      accumulateAudio1 (audioBufferPlayAtRatioTick ab) constTrue pc

audioBufferPlayAtTimeTick :: AudioBuffer -> Float -> Float -> (#Float, Float#)
audioBufferPlayAtTimeTick (AudioBuffer# audioBuffer numSamples) inTime _ =
  (#inTime, out#)
  where
    numSamplesF = fromUInt numSamples
    findex1 = (inTime * audioSampleRateF) % numSamplesF
    findex11 = findex1 + numSamplesF
    findex  = if findex1 < 0 then findex11 else findex1
    delta   = (floor findex + 1) - findex
    index1  = floatToUInt findex % numSamples
    index0  = index1 - 1
    index2  = index1 + 1
    index3  = index2 + 1
    out     =
      let
        sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
        sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
        sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
        sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
      in
        cubicInterpolation sample0 sample1 sample2 sample3 delta

-- Time is wrapped to buffer duration
audioBufferPlayAtTime :: AudioFormat f => f AudioBuffer -> f Audio -> f Audio
audioBufferPlayAtTime audioBuffers time =
  map2 f audioBuffers time
  where
    f ab pc =
      accumulateAudio1 (audioBufferPlayAtTimeTick ab) constTrue pc

audioBufferPlayAtRateTick :: AudioBuffer -> Float -> Float -> Float -> Float -> (#Float, Float#)
audioBufferPlayAtRateTick (AudioBuffer# audioBuffer numSamples) timeTrigger inTime rate currentIndex =
  (#nextIndex, out#)
  where
    numSamplesF = fromUInt numSamples
    timeSample = (inTime * audioSampleRateF) % numSamplesF
    findex1 = if timeTrigger > 0 then timeSample else currentIndex
    findex11 = findex1 + numSamplesF
    findex  = if findex1 < 0 then findex11 else findex1
    nextIndex = findex + rate
    delta   = (floor findex + 1) - findex
    index1  = floatToUInt findex % numSamples
    index0  = index1 - 1
    index2  = index1 + 1
    index3  = index2 + 1
    out     =
      let
        sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
        sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
        sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
        sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
      in
        if abs delta /= 1.0 then cubicInterpolation sample0 sample1 sample2 sample3 delta else sample1

-- Guarantees sample accurate playback as long as rate is 1 or -1 (or an integral multiple thereof) AND timeTrigger is never used
-- When timeTrigger is greater than 0 then play head is set to time input
-- rate is samples per second, can be positive or negative
audioBufferPlayAtRate :: AudioFormat f => f AudioBuffer -> f Audio -> f Audio -> f Audio -> f Audio
audioBufferPlayAtRate audioBuffers timeTrigger time rate =
  map4 f audioBuffers timeTrigger time rate
  where
    f ab ttc tc rc =
      accumulateAudio3 (audioBufferPlayAtRateTick ab) constTrue ttc tc rc

audioBufferPlayAtRateTick' :: AudioBuffer -> Float -> Float -> Float -> Float -> (#Float, Float#)
audioBufferPlayAtRateTick' (AudioBuffer# audioBuffer numSamples) sampleTrigger inSample rate currentIndex =
  (#nextIndex, out#)
  where
    numSamplesF = fromUInt numSamples
    timeSample = floor inSample % numSamplesF
    findex1 = if sampleTrigger > 0 then timeSample else currentIndex
    findex11 = findex1 + numSamplesF
    findex  = if findex1 < 0 then findex11 else findex1
    nextIndex = findex + rate
    delta   = (floor findex + 1) - findex
    index1  = floatToUInt findex % numSamples
    index0  = index1 - 1
    index2  = index1 + 1
    index3  = index2 + 1
    out     =
      let
        sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
        sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
        sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
        sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
      in
        if abs delta /= 1.0 then cubicInterpolation sample0 sample1 sample2 sample3 delta else sample1

-- Guarantees sample accurate playback as long as rate is 1 or -1 (or an integral multiple thereof)
-- When sampleTrigger is greater than 0 then play head is set to sample index (wrapped to numsamples)
-- rate is samples per second, can be positive or negative
audioBufferPlayAtRate' :: AudioFormat f => f AudioBuffer -> f Audio -> f Audio -> f Audio -> f Audio
audioBufferPlayAtRate' audioBuffers sampleTrigger sample rate =
  map4 f audioBuffers sampleTrigger sample rate
  where
    f ab stc sc rc =
      accumulateAudio3 (audioBufferPlayAtRateTick ab) constTrue stc sc rc

-- NOTE: Slightly corrected version
apertureMapPhase :: Float -> Float -> Float -> Float -> Float -> Float
apertureMapPhase phase length start end direction =
  if direction > 0 && ((start < end && phase > start && phase > end)) then
    ((phase - end) + start) % length
  else if direction > 0 && ((start > end && phase < start && phase > end)) then
    (end - (start - phase)) % length
  else
    phase

-- TODO: Finish!
audioBufferPlayWithApertureTick :: AudioBuffer -> Float -> Float -> Float -> Float -> (#Float, Float#)
audioBufferPlayWithApertureTick (AudioBuffer# audioBuffer numSamples) freq start0 end0 phase0 =
  (#phase1, out#)
  where
    numSamplesF = fromUInt numSamples
    start       = start0 * numSamplesF
    end         = end0 * numSamplesF
    direction   = signum freq
    phase00     = phase0 + freq
    phase000    = apertureMapPhase phase00 numSamplesF start end direction
    delta       = 1 - ((floor phase000 + 1) - phase000)
    phase1      = phase000
    phase_      = apertureMapPhase (phase1 - direction) numSamplesF start end direction
    phase2      = apertureMapPhase (phase1 + direction) numSamplesF start end direction
    phase3      = apertureMapPhase (phase2 + direction) numSamplesF start end direction
    sample0     = unsafePtrPeek (floatToUInt phase_ % numSamples) audioBuffer
    sample1     = unsafePtrPeek (floatToUInt phase1 % numSamples) audioBuffer
    sample2     = unsafePtrPeek (floatToUInt phase2 % numSamples) audioBuffer
    sample3     = unsafePtrPeek (floatToUInt phase3 % numSamples) audioBuffer
    out         = cubicInterpolation sample0 sample1 sample2 sample3 delta

audioBufferPlayWithAperture :: AudioFormat f => f Audio -> f Audio -> f Audio -> f AudioBuffer -> f Audio
audioBufferPlayWithAperture freq start end audioBuffers =
  map4 f audioBuffers freq start end
  where
    f (AudioBuffer# audioBuffer numSamples) fc sc ec =
      if numSamples == 0 then 0 else
        accumulateAudio3 (audioBufferPlayWithApertureTick (AudioBuffer# audioBuffer numSamples)) constTrue fc sc ec


----------------------
-- Sample Bank
----------------------

-- TODO:
-- Tuning play back for scalar sample sets, with pitch shift for pitches outside the sample set
-- Tuning mapping, to take a set of samples in one tuning and pitch shift them to fit a different tuning (for example: equal to 7-limit)

data SampleData a = SampleData (Stereo AudioBuffer) a
data SampleBank n a = SampleBank (Array n (SampleData a)) -- a is user metadata, passed through for use with sampleSeq

sampleBank :: Array n ((Slice Char), a) -> SampleBank n a
sampleBank filePathsAndMetadata =
  doOnce (map' loadSample) filePathsAndMetadata |> SampleBank
  where
    loadSample ((Slice# pFilePath filePathSize), metadata) =
      SampleData buffer metadata
      where
        buffer =
          audioFileOpen' pFilePath filePathSize
          |> unwrapOr silentAudioFile
          |> audioBufferFromFileGo
    map' f a = freezeArray b
      where
        b =
          loop a' = unsafeEmptyArray () for i <- each do
            writeArray i (f (readArray i a)) a'

-- Wrapped indexing into sample bank
selectSample :: SampleBank n a -> Int -> SampleData a
selectSample (SampleBank bank) index =
  readArray (unsafeUIntToIndex index') bank
  where
    bankLength = arrayLength NatVal bank |> uintToInt
    modIndex = index % bankLength
    index' = if modIndex < 0 then fromInt (modIndex + bankLength) else fromInt modIndex

-- Generate audio from a sample bank and sequence of integers
sampleSeq :: SampleBank n a -> (Stereo Audio -> a -> Stereo Audio) -> Seq Int -> Stereo Audio
sampleSeq bank modifier seq =
  poly sampleSynth seq
  where
    sampleSynth index =
      playFor duration synth
      where
        (SampleData buffer metadata) = selectSample bank index
        duration = audioBufferDuration buffer
        synth _ = modifier (audioBufferPlay DontLoop 1 buffer) metadata

----------------------
-- Record Audio
----------------------
-- TODO: Sprinkle World around a bit more in here!

data ScratchBuffer = ScratchBuffer (Ptr (.Ptr ()))

recordAudioBlock :: UInt -> UInt -> Array BlockSize Float -> *ScratchBuffer -> *ScratchBuffer
recordAudioBlock channelIndex channelCount audio scratchBuffer =
  primUndefined

recordAudioBlockFinalize :: Ptr Char -> UInt -> UInt -> *ScratchBuffer -> *ScratchBuffer
recordAudioBlockFinalize name nameLength channelCount scratchBuffer =
  primUndefined

recordAudioChannel :: Array n Char -> UInt -> UInt -> (#UInt, *ScratchBuffer#) -> Audio -> (#UInt, *ScratchBuffer#)
recordAudioChannel name nameLength channelCount (#i, sbuffer#) channel =
  case channel of
    AudioRate abuffer -> (#i + 1, recordAudioBlock i channelCount abuffer sbuffer#)
    BlockRate _       -> (#i + 1, sbuffer#)
    AudioEnd          -> (#i + 1, recordAudioBlockFinalize (unsafeArrayToPtr name) nameLength channelCount sbuffer#)

recordAudio :: AudioFormat f => Array n Char -> f Audio -> *World -> *World
recordAudio name audio world =
  case mutRefTake (\_ -> ScratchBuffer (unsafePtrPoke 0 primUndefined (ptrMalloc 1))) of
    (#scratchBuffer0, mref#) ->
      let
        nameLength            = arrayLength NatVal name
        channelCount          = numChannels audio
        (#_, scratchBuffer1#) =
          foldl (recordAudioChannel name nameLength channelCount) (#0, scratchBuffer0#) audio
      in
        case mutRefPut scratchBuffer1 mref of
          _ -> world



--------------------
-- UGens
--------------------

--------------------
-- bitCrush

-- TODO: Finish!
bitCrush :: AudioFormat f => f Audio -> f Audio -> f Audio
bitCrush crushFactor input =
  map2 (mapAudio2 f) crushFactor input
  where
    f crush x =
      floor (x / crush) * crush

----------------------
-- Randomness

-- TODO: Random class ?

linearCongruentialGenerator :: UInt -> UInt -> UInt -> UInt -> UInt
linearCongruentialGenerator a c m seed =
  (a * seed + c) % m

lcg :: UInt -> UInt
lcg seed =
  s
  where
    a = 1664525
    c = 1013904223
    m = 4294967296
    s = linearCongruentialGenerator a c m seed

randLCG :: Float -> Float -> UInt -> (#UInt, Float#)
randLCG mn mx seed =
  (#s, r#)
  where
    s = lcg seed
    m = 4294967296
    r = ((fromUInt s / fromUInt m) * (mx - mn)) + mn

-- This is quick'n'dirty linear congruential randomness. Replace with something higher quality!
noiseF :: UInt -> Float -> Float -> Float
noiseF iseed mn mx =
  r2
  where
    seed = 123456789
    s    = seed + iseed
    a    = 1664525
    c    = 1013904223
    m    = 4294967296
    r0   = fromUInt ((a * s + c) % m)
    r1   = (r0 / fromUInt m) * (mx - mn)
    r2   = r1 + mn

randOnceF :: UInt -> Float -> Float -> Float
randOnceF iseed mn mx =
  doOnce3 noiseF iseed mn mx

tnoiseF :: UInt -> Float -> Float -> Float
tnoiseF iseed mn mx =
  noiseF tseed mn mx
  where
    tseed = bitShiftLeft (bitOr (t * 37) (iseed * 37)) 1
    t     = currSampleCount + audioSampleOffset

randT :: UInt -> Float -> Float -> Float
randT iseed mn mx =
  r2
  where
    seed             = 123456789 + iseed
    a                = 1664525
    c                = 1013904223
    m                = 4294967296
    r0               = fromUInt (snd' s)
    r1               = (r0 / fromUInt m) * (mx - mn)
    r2               = r1 + mn
    s ~ (#True, 0#) =
      if fst' s then
        (#False, linearCongruentialGenerator a c m seed#)
      else
        (#False, linearCongruentialGenerator a c m (snd' s)#)

-- TODO: Rand class
trandOnceF :: UInt -> Float -> Float -> Float
trandOnceF iseed mn mx =
  doOnce3 tnoiseF iseed mn mx

trandOnce :: UInt -> Float -> Float -> Mono Audio
trandOnce iseed mn mx =
  fromFloat (trandOnceF iseed mn mx)

tcoinOnce :: UInt -> Mono Audio -> Mono Audio -> Mono Audio
tcoinOnce iseed x y =
  if trandOnceF iseed 0 1 < 0.5 then x else y

tcoinOnce' :: UInt -> Float -> Mono Audio -> Mono Audio -> Mono Audio
tcoinOnce' iseed probability x y =
  if trandOnceF iseed 0 1 <= probability then x else y

-- TODO: Polymorphic version is crashing for some reason?
tcoinOnceF' :: UInt -> Float -> Float -> Float -> Float
tcoinOnceF' iseed probability x y =
  if trandOnceF iseed 0 1 <= probability then x else y

chooseOnceT :: UInt -> Array n Float -> Float
chooseOnceT seed arr =
  readArrayChecked ix arr
  where
    len = arrayLength NatVal arr
    ix  = trandOnceF seed 0 (fromUInt len) |> floatToUInt |> min (len - 1)

whiteNoise :: () -> Mono Audio
whiteNoise _ =
  Mono <| AudioRate <| freezeArray <| fst' <|
  loop (#a, s#) = (#audioInitArray (), seed#) for i <- offsetToEndRange do
    (#writeArray i (noiseF s -1 1) a, s + 1#)
  where
    seed ~ 0 = seed + audioBlockSize
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal

----------------------
-- Chaos
----------------------

----------------------
-- Logistic Map

data LogisticMapState = LogisticMapState# Float

instance Default LogisticMapState where
    default = LogisticMapState# 0.5

logisticMapTick :: Float -> LogisticMapState -> (#LogisticMapState, Float#)
logisticMapTick r (LogisticMapState# xn) = (#LogisticMapState# xn1, xn1#)
  where
    xn1 = (r * xn) * (1 - xn)

-- Simple chaotic function, r expected to be in the range of 0 - 4
-- outputs values in the range of 0 - 1
logisticMap :: AudioFormat f => f Audio -> f Audio
logisticMap r =
  map f r
  where
    f rc = accumulateAudio1 logisticMapTick constTrue rc

----------------------
-- FNV1A

data FNV1aState = FNV1aState# UInt

instance Default FNV1aState where
  default = FNV1aState# 14695981039346656037

fnv1aTick :: Float -> FNV1aState -> (#FNV1aState, Float#)
fnv1aTick v (FNV1aState# hash) = (#FNV1aState# hash, fromBits hash'#)
  where
    vu = toBits v
    mask = 255
    prime = 1099511628211
    (#hash', _#) =
      loop (#hash', i#) = (#hash, 0#) while i < 4 do
        (#bitXor hash' (bitAnd (bitShiftRight vu i) mask) |> mul prime, i + 1#)

-- Instantaneous hash, doesn't accumulate hash over time
-- input is hashed as the IEEE float binary format, interpretted as octet array
-- output values will be across the entire floating point range!
fnv1a :: AudioFormat f => f Audio -> f Audio
fnv1a v =
  map f v
  where
    f vc = accumulateAudio1 fnv1aTick constTrue vc

fnv1aTick' :: Float -> FNV1aState -> (#FNV1aState, Float#)
fnv1aTick' v (FNV1aState# hash) = (#FNV1aState# hash', fromBits hash'#)
  where
    vu = toBits v
    mask = 255
    prime = 1099511628211
    (#hash', _#) =
      loop (#hash', i#) = (#hash, 0#) while i < 4 do
        (#bitXor hash' (bitAnd (bitShiftRight vu i) mask) |> mul prime, i + 1#)

-- Accumulates hash over time
-- input is hashed as the IEEE float binary format, interpretted as octet array
-- output values will be across the entire floating point range!
fnv1a' :: AudioFormat f => f Audio -> f Audio
fnv1a' v =
  map f v
  where
    f vc = accumulateAudio1 fnv1aTick' constTrue vc


----------------------
-- noise

data NoiseState = NoiseState Float Float UInt

noiseTick :: Float -> Float -> Float -> *NoiseState -> (#*NoiseState, Float#)
noiseTick mn mx freq (NoiseState phase0 prev0 hash0) =
  if phase1 < 1 then
    (#NoiseState phase2 prev0 hash0, prev0#)
  else
    let
      (#hash1, out#) = randLCG mn mx hash0
    in
      (#NoiseState phase2 out hash1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1

mkNoiseState :: UInt -> Float -> Float -> () -> *NoiseState
mkNoiseState seed mn mx _ =
  NoiseState 0 out hash1
  where
    hash0          = bitShiftLeft (bitOr (t * 37) (seed * 37)) 1
    t              = currSampleCount + audioSampleOffset
    (#hash1, out#) = randLCG mn mx hash0

-- SC "LFNoise" style noise audio combinator
noise :: AudioFormat f => UInt -> f Audio -> f Audio -> f Audio -> f Audio
noise iseed mn mx freq =
  accumulate3U (mkNoiseState iseed (audioToFloat (mixMono mn)) (audioToFloat (mixMono mx))) noiseTick constTrueU mn mx freq


--------------------
-- downsample oversampled audio
sinc :: Float -> Float
sinc x =
  if x > -0.000001 && x < 0.000001 then 1.0 else
    sine x / x

bessel :: Float -> Float
bessel x =
  add 1 <| snd'<|
    loop (#i, sum#) = (#1, 0#) while i < 10 do
      let
        xpow = pow (x / 2) (fromUInt i)
        fac  =
          fromUInt <| snd' <|
            loop (#j, fac'#) = (#1, 1#) while j <= i do
              (#j + 1, fac' * j#)
      in
        (#i + 1, sum + pow (xpow / fac) 2#)

kaiserBesselWindowFunction :: Float -> Float -> Float -> Float
kaiserBesselWindowFunction i windowSize beta =
  window
  where
    warg   = beta * sqrt (1 - pow (((2 * i + 2) - windowSize) / windowSize) 2)
    window = bessel warg / bessel beta

hannWindowFunction :: Float -> Float -> Float
hannWindowFunction i windowSize =
  0.5 - (0.5 * cosine (tau * (i + 1) / windowSize))

hammingWindowFunction :: Float -> Float -> Float
hammingWindowFunction i windowSize =
  0.54 - (0.46 * cosine (tau * (i + 1) / windowSize))

nuttallBlackmanWindowFunction :: Float -> Float -> Float
nuttallBlackmanWindowFunction i windowSize =
  0.355768 -
  (0.487396 * cosine ((2.0 * pi * i) / windowSize)) +
  (0.144232 * cosine ((4.0 * pi * i) / windowSize)) -
  (0.012604 * cosine ((6.0 * pi * i) / windowSize))

-- downsampleCoefficients :: Array 32 Float
-- downsampleCoefficients =
--   freezeArray coeff3
--   where
--     windowSize = 32
--     freqCutoff = 20000
--     omega      = freqCutoff / (audioSampleRateF * fromUInt audioOverSampleAmount)
--     coeff1     =
--       loop a = unsafeEmptyArray () for i <- each do
--         let
--           iReal       = fromUInt (indexToUInt i)
--           iOffset     = iReal - ((windowSize - 1) / 2)
--           window      = kaiserBesselWindowFunction iReal windowSize 3
--           coefficient = omega * sinc (omega * iOffset * pi) * window
--         in
--           writeArray i coefficient a
--     (#gainSum, coeff2#) =
--       loop (#sum, a0#) = (#0, coeff1#) for i <- each do
--         case readArrayU i a0 of
--           (#x, a1#) ->
--             (#sum + x, a1#)
--     gainAdjust = 1.25 -- (1 / gainSum) * (1 / windowSize)
--     coeff3     =
--       loop a0 = coeff2 for i <- each do
--         case readArrayU i a0 of
--           (#x, a1#) ->
--             writeArray i (x * gainAdjust) a1

-----------
-- saw

-- Oversampling saw wave, Some reading:
--   * PHASESHAPING OSCILLATOR ALGORITHMS FOR MUSICAL SOUND SYNTHESIS:
--       https://eprints.maynoothuniversity.ie/4100/1/SMC2010.pdf
--   * Antialiasing Oscillators in Subtractive Synthesis
--   * Audible Aliasing Distortion in Digital Audio Synthesis
--       https://www.researchgate.net/publication/268382833_Audible_Aliasing_Distortion_in_Digital_Audio_Synthesis

-- data OverSampleSawState = OverSampleSawState# Float UInt (.Array 32 Float)

-- mkOverSampleSawState :: () -> *OverSampleSawState
-- mkOverSampleSawState _ = OverSampleSawState# 0 0 (arrayFrom 0)

-- -- TODO: Replace FIR filter with IIR filter?
-- -- Oversampling saw oscillator, with FIR downsampling
-- accumulateSawFIR :: Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulateSawFIR freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 63)) (fma (phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 63)) (fma (phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 63)) (fma (phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 63)) (fma (phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 63)) (fma (phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 63)) (fma (phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 63)) (fma (phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 63)) (fma (phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 63, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 64 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 63)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 63)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 63)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 63)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 63)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 63)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 63)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 63)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 63, d8, firResult#)
--
-- sawFIR :: AudioFormat f => f Audio -> f Audio
-- sawFIR freq =
--   accumulate1U mkOverSampleSawState accumulateSawFIR constTrueU freq

-- data OverSampleSawStateIIR = OverSampleSawStateIIR# Float Float Float Float Float

-- instance Default OverSampleSawStateIIR where
--   default = OverSampleSawStateIIR# 0 0 0 0 0

-- -- Brickwall filter constants
-- ffreqBrickWall = 20000
-- gainBrickWall  = -28
-- slopeBrickWall = 1
-- bigaBrickWall  = pow 10 (gainBrickWall / 40)
-- omegaBrickWall = ffreqBrickWall * audioRecipOverSampleRate * tau
-- csoBrickWall   = cosine omegaBrickWall
-- alphaBrickWall = sine omegaBrickWall * 0.5 * sqrt (((bigaBrickWall + (1 / bigaBrickWall)) * ((1 / slopeBrickWall) - 1)) + 2)
-- betaBrickWall  = 2 * sqrt bigaBrickWall * alphaBrickWall

-- -- Oversampling saw wave with IIR brickwall filter
-- -- TODO: Upsample frequency?!?!!?
-- accumulateSaw :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateSaw freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (phase1 - floor phase1) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (phase2 - floor phase2) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (phase3 - floor phase3) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (phase4 - floor phase4) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (phase5 - floor phase5) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (phase6 - floor phase6) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (phase7 - floor phase7) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (phase8 - floor phase8) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)

----------------------
-- minBLEP
--
-- Hard Sync Without Aliasing:
--   http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf
--
-- ExperimentalScene article on MinBLEPs with nice code examples
-- https://www.experimentalscene.com/articles/minbleps.php
--
-- Minimum phase filters
--   https://ccrma.stanford.edu/~jos/fp/Creating_Minimum_Phase_Filters.html
----------------------

data MinBlepBuffer z o = MinBlepBuffer (.Array (NatMul (NatMul z 2) o) Float)
data MinBlepFFT    z o = MinBlepFFT (.Array (NatMul (NatMul z 2) o) Complex)

-- Slow n' dirty fft
minBlepFFT :: UInt -> MinBlepFFT z o -> *MinBlepFFT z o
minBlepFFT n (MinBlepFFT timeDomain) =
  MinBlepFFT bins1
  where
    rn           = fromUInt n
    bins0        = arrayFrom (Complex# 0 0)
    (#_, bins1#) =
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = 0 - sine p
                (#Complex# fr fi, b3#) = readArrayU (Index k) b2
                Complex# tr ti         = readArray (Index i) timeDomain
                yr                     = fr + ((tr * sr) - (ti * si))
                yi                     = fi + ((tr * si) + (ti * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          (#k + 1, b4#)

-- Slow n' dirty ifft
minBlepIFFT :: UInt -> MinBlepFFT z o -> MinBlepFFT z o
minBlepIFFT n (MinBlepFFT freqDomain) =
  MinBlepFFT <| freezeArray bins1
  where
    rn    = fromUInt n
    bins0 =
      loop b = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# 0 0) b
    bins1 = snd' <|
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = negate (sine p)
                (#Complex# tr ti, b3#) = readArrayU (Index k) b2
                Complex# fr fi         = readArray (Index i) freqDomain
                yr                     = tr + ((fr * sr) + (fi * si))
                yi                     = ti + ((fr * si) - (fi * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          case readArrayU (Index k) b4 of
            (#Complex# xr xi, b5#) ->
              (#k + 1, writeArray (Index k) (Complex# (xr / rn) (xi / rn)) b5#)

-- Compute real cepstrum
minBlepCepstrum :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepCepstrum n (MinBlepBuffer signal) =
  MinBlepBuffer <| freezeArray realCepstrum
  where
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# (readArray i signal) 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          lcabs                   = log (sqrt ((xr * xr) + (xi * xi)))
          c                       = Complex# lcabs 0
        in
          writeArray i c fd1

    realCepstrum =
      loop rc = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) rc

-- Minimum phase reconstruction
minBlepMinimumPhase :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepMinimumPhase n (MinBlepBuffer realCepstrum) =
  MinBlepBuffer <| freezeArray minimumPhase
  where
    n2                    = n / 2
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        if indexToUInt i == 0 then
          writeArray i (Complex# (readArray i realCepstrum) 0) td
        else if indexToUInt i < n2 then
          writeArray i (Complex# (readArray i realCepstrum * 2) 0) td
        else
          writeArray i (Complex# 0 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          rexp                    = exp xr
          c                       = Complex# (rexp * cosine xi) (rexp * sine xi)
        in
          writeArray i c fd1

    minimumPhase =
      loop mp = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) mp

minBlepN :: NatVal z -> NatVal o -> NatVal (NatMul (NatMul z 2) o)
minBlepN _ _ = NatVal

-- Start with z = 16, o = 32, which should create 1024 table
generateMinBLEP :: NatVal z -> NatVal o -> MinBlepBuffer z o
generateMinBLEP z o =
  minBlep1
  where
    n            = minBlepN z o |> natVal
    rn           = fromUInt n
    b            = natVal z |> fromUInt
    a            = negate b
    windowedSinc = MinBlepBuffer <| freezeArray <|
      loop wsb = unsafeEmptyArray () for i <- each do
        let
          ri = fromUInt (indexToUInt i)
          r  = ri / (rn - 1)
          s  = (a + (r * (b - a))) * pi |> sinc
          ws = hannWindowFunction ri rn * s
        in
          writeArray i ws wsb

    MinBlepBuffer minPhase =
      minBlepCepstrum n windowedSinc
      |> minBlepMinimumPhase n

    (#minBlep0, m#) =
      loop (#mb, m0#) = (#unsafeEmptyArray (), 0#) for i <- each do
        let
          m1 = m0 + readArray i minPhase
        in
          (#writeArray i m1 mb, m1#)

    rm       = 1 / m
    minBlep1 = MinBlepBuffer <| freezeArray <|
      loop mb0 = minBlep0 for i <- each do
        let
          (#x, mb1#) = readArrayU i mb0
        in
          writeArray i (x * rm) mb1

minBLEP :: MinBlepBuffer 16 32
minBLEP =
  generateMinBLEP NatVal NatVal

debugPlotMinBlepBuffer :: Array n Char -> MinBlepBuffer z o -> MinBlepBuffer z o
debugPlotMinBlepBuffer name (MinBlepBuffer buffer) =
  case writePlot2DToFileOnce name buffer primUndefined of
    _ -> MinBlepBuffer buffer

-- NOTE: Circular buffer size is equal to 2 * zcrossings
data MinBlepState = MinBlepState# Float UInt (.Array 32 Float)

mkMinBlepState :: () -> *MinBlepState
mkMinBlepState _ = MinBlepState# 0 0 (arrayFrom 0)

-- NOTE:
--   * zcrossings   = 16
--   * oversampling = 32
--   * buffer size  = 16 * 2 * 32 = 1024
-- TODO: fmin, or branchless min primop
addMinBlep :: Float -> Float -> UInt -> *Array 32 Float -> *Array 32 Float
addMinBlep polarity offset index buffer0 =
  buffer1
  where
    MinBlepBuffer mBuffer = minBLEP
    delta                 = offset % 1
    offsetu               = floorToInt offset |> fromInt
    mOffset               = 0 - polarity
    (#_, buffer1#) =
      loop (#i, b0#) = (#0, buffer0#) while i < 32 do
        let
          ci         = Index (bitAnd (i + index) 31)
          mi         = min 1022 ((i * 32) + offsetu)
          (#cx, b1#) = readArrayU ci b0
          m0         = readArray (Index mi) mBuffer
          m1         = readArray (Index (mi + 1)) mBuffer
          mx         = fma (m0 + (delta * (m1 - m0))) polarity mOffset
        in
          (#i + 1, writeArray ci (cx + mx) b1#)

----------------------
-- minBLEP saw
----------------------

fselect :: Bool -> Float -> Float -> Float
fselect c x y =
  (fc * x) + ((1 - fc) * y)
  where
    fc = fromInt <| boolToInt c

uselect :: Bool -> UInt -> UInt -> UInt
uselect c x y =
  (fc * x) + ((1 - fc) * y)
  where
    fc = fromInt <| boolToInt c

accumulateMinBlepSaw :: Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepSaw freq (MinBlepState# phase0 cIndex0 cBuffer0) =
  (#MinBlepState# phase2 cIndex1 cBuffer3, out#)
  where
    cIndex1   = bitAnd (cIndex0 + 1) 31
    freqDelta = freq * recipSampleRate
    phase1    = phase0 + freqDelta
    (#phase2, cBuffer1#) =
      if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0#)
      else
        (#phase1, cBuffer0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    out              = fma (phase2 + cx) 2 -1

saw :: AudioFormat f => f Audio -> f Audio
saw freq =
  accumulate1U mkMinBlepState accumulateMinBlepSaw constTrueU freq


-----------
-- lfSaw
accumulateLFSaw :: Float -> Float -> Float -> (#Float, Float#)
accumulateLFSaw freq phaseOffset phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phaseO = phase1 + (phaseOffset * freq * recipSampleRate)
    phase2 = phase1 - floor phase1
    out    = fma phase2 2 -1

lfSaw :: AudioFormat f => f Audio -> f Audio -> f Audio
lfSaw freq phaseOffset =
  accumulate2 accumulateLFSaw constTrue freq phaseOffset

-----------
-- pulse

-- -- Oversampling pulse oscillator, with FIR downsampling
-- accumulatePulseFIR :: Float -> Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulatePulseFIR width freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 31)) (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 31)) (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 31)) (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 31)) (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 31)) (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 31)) (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 31)) (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 31)) (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 31, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 32 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 31)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 31)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 31)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 31)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 31)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 31)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 31)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 31)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 31, d8, firResult#)

-- -- Oversampling pulse oscillator, with FIR downsampling
-- accumulatePulseFIR :: Float -> Float -> Float -> (#Float, Float#)
-- accumulatePulseFIR width freq phaseIn =
--   (#phase, out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, out#) =
--       loop (#i, phase0, out0#) = (#0, phaseIn, 0#) while i < 32 do
--         let
--           phase1  = freqDelta + phase0
--           out1    = fma (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) (readArray (Index i) downsampleCoefficients) out0
--           phase2  = freqDelta + phase1
--           out2    = fma (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) (readArray (Index i) downsampleCoefficients) out1
--           phase3  = freqDelta + phase2
--           out3    = fma (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) (readArray (Index i) downsampleCoefficients) out2
--           phase4  = freqDelta + phase3
--           out4    = fma (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) (readArray (Index i) downsampleCoefficients) out3
--           phase5  = freqDelta + phase4
--           out5    = fma (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) (readArray (Index i) downsampleCoefficients) out4
--           phase6  = freqDelta + phase5
--           out6    = fma (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) (readArray (Index i) downsampleCoefficients) out5
--           phase7  = freqDelta + phase6
--           out7    = fma (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) (readArray (Index i) downsampleCoefficients) out6
--           phase8  = freqDelta + phase7
--           out8    = fma (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) (readArray (Index i) downsampleCoefficients) out7
--         in
--           (#i + 8, phase8, out8#)

-- pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
-- pulse width freq =
--   accumulate2 accumulatePulseFIR constTrue width freq

-----------
-- Oversampling saw wave with IIR brickwall filter

-- b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
-- b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
-- b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
-- a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
-- a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
-- a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
-- ra0       = 1 / a0

-- accumulatePulse :: Float -> Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulatePulse width freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, fma (negate y1Out) 2 -1#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fromInt (boolToInt (gt width (phase1 - floor phase1)))
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fromInt (boolToInt (gt width (phase2 - floor phase2)))
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fromInt (boolToInt (gt width (phase3 - floor phase3)))
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fromInt (boolToInt (gt width (phase4 - floor phase4)))
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fromInt (boolToInt (gt width (phase5 - floor phase5)))
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fromInt (boolToInt (gt width (phase6 - floor phase6)))
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fromInt (boolToInt (gt width (phase7 - floor phase7)))
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fromInt (boolToInt (gt width (phase8 - floor phase8)))
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)

-----------
-- minBLEP pulse

accumulateMinBlepPulse :: Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepPulse width freq (MinBlepState# phase0 indexAndMode0 cBuffer0) =
  (#MinBlepState# phase2 indexAndMode1 cBuffer3, out#)
  where
    mode0     = bitAnd 32 indexAndMode0
    cIndex0   = bitAnd 31 indexAndMode0
    cIndex1   = bitAnd (cIndex0 + 1) 31
    freqDelta = freq * recipSampleRate
    phase1    = phase0 + freqDelta
    (#phase2, cBuffer1, mode1#) =
      if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
          mode1    = uselect (phase2 <= width) 0 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else if (mode0 == 0 && phase1 >= width && freq > 0) || (mode0 == 32 && phase1 < width && freq < 0) then
        let
          polarity = fselect (mode0 == 0) 1 -1
          offset   = ((abs (phase1 - width)) / abs freqDelta) * 32
          mode1    = uselect (mode0 == 0) 32 0
        in
          (#phase1, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else
        (#phase1, cBuffer0, mode0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    y                = fselect (mode1 == 0) 0 1
    out              = fma (y + cx) 2 -1
    indexAndMode1    = bitOr mode1 cIndex1

pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
pulse width freq =
  accumulate2U mkMinBlepState accumulateMinBlepPulse constTrueU width freq

-----------
-- lfPulse
accumulateLFPulse :: Float -> Float -> Float -> (#Float, Float#)
accumulateLFPulse width freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    out    = fma (fromInt (boolToInt (phase2 > width))) 2 -1

lfPulse :: AudioFormat f => f Audio -> f Audio -> f Audio
lfPulse width freq =
  accumulate2 accumulateLFPulse constTrue width freq

-- -----------
-- -- Oversampling saw wave with IIR brickwall filter
-- accumulateTri :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateTri freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (abs (fma (phase1 - floor phase1) 2 -1)) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (abs (fma (phase2 - floor phase2) 2 -1)) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (abs (fma (phase3 - floor phase3) 2 -1)) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (abs (fma (phase4 - floor phase4) 2 -1)) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (abs (fma (phase5 - floor phase5) 2 -1)) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (abs (fma (phase6 - floor phase6) 2 -1)) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (abs (fma (phase7 - floor phase7) 2 -1)) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (abs (fma (phase8 - floor phase8) 2 -1)) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)
--
-- tri' :: AudioFormat f => f Audio -> f Audio
-- tri' freq =
--   accumulate1 accumulateTri constTrue freq

-----------
-- lfTri
accumulateLFTri :: Float -> Float -> (#Float, Float#)
accumulateLFTri freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    saw    = fma phase2 2 -1
    out    = fma (abs saw) 2 -1

tri :: AudioFormat f => f Audio -> f Audio
tri freq =
  accumulate1 accumulateLFTri constTrue freq

-----------
-- perc
-- TODO: Switch to EnvState
data PercState = PercState# Float Float Float Float

mkPercState :: Float -> Float -> Float -> Float -> Float -> () -> *PercState
mkPercState level endLevel length curve currTime _ =
  PercState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

accumulatePerc :: (#Float, Float, Float, Float#) -> Float -> *PercState -> (#*PercState, Float#)
accumulatePerc (#attackTime, decayTime, totalTime, curve#) input (PercState# a20 b10 grow0 currTime0) =
  (#PercState# a2 b12 grow currTime, out#)
  where
    currTime1 = currTime0 + recipSampleRate
    PercState# a2 b1 grow currTime =
      if currTime1 > attackTime && currTime0 <= attackTime then
        mkPercState (a20 - b10) 0 decayTime curve currTime1 ()
      else if currTime1 > totalTime then
        PercState# 0 0 0 currTime1
      else
        PercState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

percIsRunning :: Float -> *PercState -> (#*PercState, Bool#)
percIsRunning totalTime (PercState# a2 b1 grow currTime) =
  (#PercState# a2 b1 grow currTime, currTime < totalTime#)

perc :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
perc attackTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + decayTime
    mk        = mkPercState 0 1 attackTime curve 0
    update    = accumulatePerc (#attackTime, decayTime, totalTime, curve#)
    isRunning = percIsRunning totalTime

-----------
-- Env

data EnvState = EnvState# Float Float Float Float

envMk :: Float -> Float -> Float -> Float -> Float -> () -> *EnvState
envMk level endLevel length curve currTime _ =
  EnvState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF |> max 1
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

-- Adjusted version that truncates to sample, possibly addresses overshooting issue?
envMk' :: Float -> Float -> Float -> Float -> Float -> () -> .EnvState
envMk' level endLevel length curve currTime _ =
  EnvState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF |> floor |> max 1
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

envIsRunning :: Float -> .EnvState -> (#.EnvState, Bool#)
envIsRunning totalTime (EnvState# a2 b1 grow currTime) =
  (#EnvState# a2 b1 grow currTime, currTime < totalTime#)

-----------
-- asr

asrTick :: Float -> Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
asrTick attackTime sustainTime decayTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    attackAndSustainTime          = attackTime + sustainTime
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to sustain
      if currTime1 > attackTime && currTime0 <= attackTime then
        envMk (a20 - b10) 1.0 sustainTime curve currTime1 () -- |> traceLn "Attack -> Sustain"
      -- Switch to decay
      else if currTime1 > attackAndSustainTime && currTime0 <= attackAndSustainTime then
        envMk (a20 - b10) 0 decayTime curve currTime1 () -- |> traceLn "Sustain -> Release"
      -- End
      else if currTime1 > totalTime then
        EnvState# 0 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

asr :: AudioFormat f => Float -> Float -> Float -> Float -> f Audio -> f Audio
asr attackTime sustainTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + sustainTime + decayTime
    mk        = \_ -> envMk 0 1 attackTime curve 0 () -- |> traceLn "mk"
    update    = asrTick attackTime sustainTime decayTime totalTime curve
    isRunning = envIsRunning totalTime

asr' :: AudioFormat f => Float -> Float -> Float -> Float -> f Audio -> f Audio
asr' attackTime sustainTime decayTime curve input =
  silenceAtEnd (asr attackTime sustainTime decayTime curve input)

-----------
-- ADSR

data ADSRState =
  ADSRState_Attack      |
  ADSRState_Decay       |
  ADSRState_Sustain     |
  ADSRState_Release     |
  ADSRState_End

data ADSRAccumulateState = ADSRAccumulateState# ADSRState EnvState

instance Default ADSRAccumulateState where
  default = ADSRAccumulateState# ADSRState_End (EnvState# 0 0 0 0)

adsrTick :: Float -> Float -> Float -> Float -> Float -> Float -> Float -> Float -> Float -> ADSRAccumulateState -> (#ADSRAccumulateState, Float#)
adsrTick attackTime decayTime sustainLevel releaseTime totalTime curve gate trigger input (ADSRAccumulateState# adsrState (EnvState# a20 b10 grow0 currTime0)) =
  (#ADSRAccumulateState# state2 (EnvState# a2 b12 grow currTime), out#)
  where
    attackAndDecayTime = attackTime + decayTime
    currTime1 = currTime0 + recipSampleRate -- |> traceLn2 "ADSR currTime1: "
    (ADSRAccumulateState# state2 (EnvState# a2 b1 grow currTime)) =
      let
        mkReAttack lastState =
          ADSRAccumulateState# ADSRState_Attack (envMk' currentLevel 1 reAttackLength curve currTime2 ()) -- |> traceLn2 debugText
            where
              currentLevel = (a20 - b10) -- |> traceLn2 "value: "
              reAttackLength = min attackTime (((currTime1 - attackTime) / releaseTime) * attackTime) -- |> traceLn2 "reAttackLength: "
              currTime2 = attackTime - reAttackLength + recipSampleRate -- |> traceLn2 "currTime2: "
      in
        case adsrState of
          ADSRState_Attack ->
            if currTime1 > attackTime then
              ADSRAccumulateState# ADSRState_Decay (envMk' (a20 - b10) sustainLevel decayTime curve currTime1 ()) -- |> traceLn2 "Attack -> Decay: "
            else
              ADSRAccumulateState# ADSRState_Attack (EnvState# a20 b10 grow0 currTime1)
          ADSRState_Decay ->
            if trigger > 0 then
              mkReAttack ADSRState_Decay
            else if currTime1 > attackAndDecayTime then
              if gate > 0 then
                ADSRAccumulateState# ADSRState_Sustain (EnvState# sustainLevel b10 0 currTime1) -- |> traceLn2 "Decay -> Sustain: "
              else
                ADSRAccumulateState# ADSRState_Release (envMk' (a20 - b10) 0 releaseTime curve currTime1 ()) -- |> traceLn2 "Decay -> Release: "
            else
              ADSRAccumulateState# ADSRState_Decay (EnvState# a20 b10 grow0 currTime1)
          ADSRState_Sustain ->
            if trigger > 0 then
              mkReAttack ADSRState_Sustain
            else if gate == 0 then
              ADSRAccumulateState# ADSRState_Release (envMk' (a20 - b10) 0 releaseTime curve attackAndDecayTime ()) -- |> traceLn2 "Sustain -> Release: "
            else
              ADSRAccumulateState# ADSRState_Sustain (EnvState# a20 b10 0 currTime0)
          ADSRState_Release ->
            if gate > 0 || trigger > 0 then
              mkReAttack ADSRState_Release
            else if currTime1 > totalTime then
                ADSRAccumulateState# ADSRState_End (EnvState# 0 0 0 totalTime) -- |> traceLn2 "Release -> End: "
            else
              ADSRAccumulateState# ADSRState_Release (EnvState# a20 b10 grow0 currTime1)
          ADSRState_End ->
            if gate > 0 || trigger > 0 then
              ADSRAccumulateState# ADSRState_Attack (envMk' 0 1 attackTime curve recipSampleRate ()) -- |> traceLn2 "End -> Attack: "
            else
              ADSRAccumulateState# ADSRState_End (EnvState# 0 0 0 totalTime) -- |> trace "end"
    b12   = b1 * grow
    level = a2 - b12 -- |> traceLn2 "ADSR level: "
    out   = level * input

-- gate param will trigger and sustain, trigger param can retrigger the env from a sustained state (will move back to attack then decay then sustain)
adsrMultiTrigger :: AudioFormat f => Float -> Float -> Float -> Float -> Float -> f Audio -> f Audio -> f Audio -> f Audio
adsrMultiTrigger attackTime decayTime sustainLevel releaseTime curve gate trigger input =
  accumulate3 update constTrue gate trigger input
  where
    totalTime = attackTime + decayTime + releaseTime
    update    = adsrTick attackTime decayTime (clamp sustainLevel 0 1) releaseTime totalTime curve

-- gate triggers the envelope when changing from 0 to positive and will hold the env to the sustain level while the gate remains open
adsr :: AudioFormat f => Float -> Float -> Float -> Float -> Float -> f Audio -> f Audio -> f Audio
adsr attackTime decayTime sustainLevel releaseTime curve gate input =
  adsrMultiTrigger attackTime decayTime sustainLevel releaseTime curve gate (pure 0) input

-----------
-- sustainRelease
sustainReleaseTick :: Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
sustainReleaseTick sustainTime decayTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to decay
      if currTime1 > sustainTime && currTime0 <= sustainTime then
        envMk (a20 - b10) 0 decayTime curve currTime1 ()
      -- End
      else if currTime1 > totalTime then
        EnvState# 0 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

sustainRelease :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
sustainRelease sustainTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = sustainTime + decayTime
    mk        = envMk 1 1 sustainTime curve 0
    update    = sustainReleaseTick sustainTime decayTime totalTime curve
    isRunning = envIsRunning totalTime

-----------
-- attackSustain

attackSustainTick :: Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
attackSustainTick attackTime sustainTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to sustain
      if currTime1 > attackTime && currTime0 <= attackTime then
        envMk (a20 - b10) 1 sustainTime curve currTime1 ()
      -- End
      else if currTime1 > totalTime then
        EnvState# a20 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

attackSustain :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
attackSustain attackTime sustainTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + sustainTime
    mk        = envMk 0 1 attackTime curve 0
    update    = attackSustainTick attackTime sustainTime totalTime curve
    isRunning = envIsRunning totalTime

attackSustain' :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
attackSustain' attackTime sustainTime curve input =
  accumulate1U mk update constTrueU input
  where
    totalTime = attackTime + sustainTime
    mk        = envMk 0 1 attackTime curve 0
    update    = attackSustainTick attackTime sustainTime totalTime curve


-----------
-- Scheduling

playFor :: AudioFormat f => Float -> (() -> f Audio) -> f Audio
playFor length faudio =
  if t > length then
    pure AudioEnd
  else
    faudio ()
  where
    t = localTime ()

waitFor :: AudioFormat f => Float -> (() -> f Audio) -> f Audio
waitFor length faudio =
  if t <= length then
    pure (BlockRate 0)
  else
    faudio ()
  where
    t = localTime ()

waitThenPlayFor :: AudioFormat f => Float -> Float -> (() -> f Audio) -> f Audio
waitThenPlayFor waitLength playLength faudio =
  if t <= waitLength then
    pure (BlockRate 0)
  else if t <= totalLength then
    faudio ()
  else
    pure AudioEnd
  where
    totalLength = waitLength + playLength
    t           = localTime ()


-----------
-- Wave tables

data WaveTable = WaveTable (Array 65536 Float)

sinTable :: WaveTable
sinTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (sine ((fromInt (uintToInt i) / 65536) * tau)) a

cosTable :: WaveTable
cosTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (cosine ((fromInt (uintToInt i) / 65536) * tau)) a

-- sinhTable :: WaveTable
-- sinhTable =
--   WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
--     case ix of
--       Index i ->
--         writeArray ix (sinh ((fromInt (uintToInt i) / 65536) * tau)) a

-- TODO: Accumulator will grow very large, reducing precision?
-- TODO: need ceil

accumulateWaveTable :: WaveTable -> Float -> Float -> (#Float, Float#)
accumulateWaveTable (WaveTable buffer) freq phase0 =
  (#phase1, out#)
  where
    phase1  = fma freq recipSampleRate phase0
    findex  = phase1 * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer
    out     = sample1 * delta + sample2 * (1 - delta)

wave :: AudioFormat f => WaveTable -> f Audio -> f Audio
wave buffer freq =
  accumulate1 (accumulateWaveTable buffer) constTrue freq

sin :: AudioFormat f => f Audio -> f Audio
sin freq =
  wave sinTable freq

accumulateWaveTable' :: WaveTable -> Float -> Float -> Float -> (#Float, Float#)
accumulateWaveTable' (WaveTable buffer) freq phaseOffset phase0 =
  (#phase1, out#)
  where
    phase1  = fma freq recipSampleRate phase0
    findex  = (phase1 + phaseOffset * freq * recipSampleRate) * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer
    out     = sample1 * delta + sample2 * (1 - delta)

wave' :: AudioFormat f => WaveTable -> f Audio -> f Audio -> f Audio
wave' buffer freq phaseOffset =
  accumulate2 (accumulateWaveTable' buffer) constTrue freq phaseOffset

sin' :: AudioFormat f => f Audio -> f Audio -> f Audio
sin' freq phaseOffset =
  wave' sinTable freq phaseOffset


-------------
-- Range conversion

-- TODO: SIMD version, need to more tools for FloatVec conversion
-- linLin :: AudioFormat f => Float -> Float -> Float -> Float -> f Audio
-- linLin low high newLow newHigh cs =
--   map (mapAudioVec f ff) cs
--   where
--     f  x = ((x - low) * (newHigh - newLow) / (high - low)) + newLow
--     ff x = ((x - low) * (newHigh - newLow) / (high - low)) + newLow

linLin :: AudioFormat f => Float -> Float -> Float -> Float -> f Audio -> f Audio
linLin low high newLow newHigh cs =
  map (mapAudio f) cs
  where
    scale = (newHigh - newLow) / (high - low)
    f  x = ((x - low) * scale) + newLow

linCurve :: AudioFormat f => Float -> Float -> Float -> Float -> Float -> f Audio -> f Audio
linCurve low high newLow newHigh curve cs =
  map (mapAudio f) cs
  where
    nHminNl = newHigh - newLow
    hminl = high - low
    curve' = if curve < 0 then 1 / ((curve * -1) + 1) else curve + 1
    f  x   = nHminNl * pow ((x - low) / hminl) curve' + newLow


-------------
-- Wave Terrain

data WaveTable2D n = WaveTable2D (Array (NatMul (NatNextPowerOfTwo n) (NatNextPowerOfTwo n)) Float)
data WaveTable3D n = WaveTable3D (Array (NatMul (NatNextPowerOfTwo n) (NatMul (NatNextPowerOfTwo n) (NatNextPowerOfTwo n))) Float)

audioVector2DX :: AudioVector2D -> Audio
audioVector2DX (AudioVector2D# x _) = x

audioVector2DY :: AudioVector2D -> Audio
audioVector2DY (AudioVector2D# _ y) = y

audioVector3DX :: AudioVector3D -> Audio
audioVector3DX (AudioVector3D# x _ _) = x

audioVector3DY :: AudioVector3D -> Audio
audioVector3DY (AudioVector3D# _ y _) = y

audioVector3DZ :: AudioVector3D -> Audio
audioVector3DZ (AudioVector3D# _ _ z) = z

accumulateWave2F :: AudioFormat f => (Vector2D -> Float) -> f AudioVector2D -> f Audio
accumulateWave2F f a =
  map (\v -> mapAudio2 (\x y -> f (Vector2D# x y)) (audioVector2DX v) (audioVector2DY v)) a

-- accumulateWave3F :: (Default s, AudioFormat f) => (Vector3D -> s -> (#s, Float#)) -> f AudioVector3D -> f Audio
-- accumulateWave3F f v =
--   accumulate3 (\x y z -> f (Vector3D# x y z)) constTrue (map audioVector3DX v) (map audioVector3DY v) (map audioVector3DZ v)


----------------------
-- Attractor2D
----------------------

data AttractorState2D w h s = AttractorState2D# (.Array (NatMul w h) (#Vector2D, s#)) Float

mkAttractorState2D :: NatVal w -> NatVal h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> () -> *AttractorState2D w h s
mkAttractorState2D wv hv mkArrayFn _ =
  AttractorState2D# a1 0
  where
    width  = natVal wv
    height = natVal hv
    hw     = fromUInt width * 0.5
    hh     = fromUInt height * 0.5
    a1     =
      loop a0 = unsafeEmptyArray () for i <- each do
        let
          ui       = indexToUInt i
          x        = fromUInt (ui % width) - hw
          y        = fromUInt (ui / width) - hh
          (#v, s#) = mkArrayFn ui (Vector2D# x y)
        in
          writeArray i (#v, s#) a0

accumulateAttractor2D :: (p -> Float -> Vector2D -> Vector2D) ->
                         (UInt -> Vector2D -> s -> (#s, Float#)) ->
                         Float -> p -> Float ->
                         *AttractorState2D w h s -> (#*AttractorState2D w h s, Float#)
accumulateAttractor2D attractorF mapF recipSize param speed (AttractorState2D# a0 phase0) =
  (#AttractorState2D# a3 phase1, out#)
  where
    delta       = speed * recipSampleRate
    phase1      = phase0 + delta
    (#a3, out#) =
      loop (#a1, out0#) = (#a0, 0#) for i <- each do
        let
          ui                 = indexToUInt i
          (#(#v0, s0#), a2#) = readArrayU i a1
          v1                 = v0 + (Vector2D# delta delta * attractorF param phase0 v0)
          (#s1, x#)          = mapF ui v1 s0
          out1               = out0 + (x * recipSize)
        in
          (#writeArray i (#v1, s1#) a2, x#)

attractor2D :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (p -> Float -> Vector2D -> Vector2D) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> p -> f Audio -> f Audio
attractor2D size initF attractorF mapF p speed =
  accumulate1U (mkAttractorState2D wv hv initF) (accumulateAttractor2D attractorF mapF recipSize p) constTrueU speed
  where
    (#wv, hv#) = natVal2ToNatVals size
    recipSize  = 1 / (fromUInt (natVal wv) * fromUInt (natVal hv))

----------------------
-- duffingAttractor
duffing :: (#Float, Float, Float#) -> Float -> Vector2D -> Vector2D
duffing (#a, b, w#) t (Vector2D# x y) =
  Vector2D# dx dy
  where
    dx = y
    dy = x - (x * x * x) - (a * y) + (b * cosine (w * t))

duffingAttractor :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> Float -> Float -> Float -> f Audio -> f Audio
duffingAttractor size initF mapF a b w speed =
  attractor2D size initF duffing mapF (#a, b, w#) speed

----------------------
-- ikedaAttractor
ikeda :: Float -> Float -> Vector2D -> Vector2D
ikeda u t (Vector2D# x0 y0) =
  Vector2D# x1 y1
  where
    t  = 0.4 - 6 / (1 + (x0 * x0) + (y0 * y0))
    x1 = 1 + (u * ((x0 * cosine t) - (y0 * sine t)))
    y1 = u * ((x0 * sine t) + (y0 * cosine t))

ikedaAttractor :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> Float -> f Audio -> f Audio
ikedaAttractor size initF mapF u speed =
  attractor2D size initF ikeda mapF u speed

----------------------
-- Attractor3D
----------------------

data AttractorState3D w h d s = AttractorState3D# (.Array (NatMul (NatMul w h) d) (#Vector3D, s#)) Float

mkAttractorState3D :: NatVal w -> NatVal h -> NatVal d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> () -> *AttractorState3D w h d s
mkAttractorState3D wv hv dv mkArrayFn _ =
  AttractorState3D# a1 0
  where
    width  = natVal wv
    height = natVal hv
    depth  = natVal dv
    hw     = fromUInt width  * 0.5
    hh     = fromUInt height * 0.5
    hd     = fromUInt depth  * 0.5
    a1     =
      loop a0 = unsafeEmptyArray () for i <- each do
        let
          ui       = indexToUInt i
          x        = fromUInt (ui % width) - hw
          y        = fromUInt ((ui / width) % height) - hh
          z        = fromUInt ((ui / width) / height) - hd
          (#v, s#) = mkArrayFn ui (Vector3D# x y z)
        in
          writeArray i (#v, s#) a0

-- -- Euler method
-- accumulateAttractor3D :: (p -> Float -> Vector3D -> Vector3D) ->
--                          (UInt -> Vector3D -> s -> (#s, Float#)) ->
--                          Float -> p -> Float ->
--                          *AttractorState3D w h d s -> (#*AttractorState3D w h d s, Float#)
-- accumulateAttractor3D attractorF mapF recipSize param speed (AttractorState3D# a0 phase0) =
--   (#AttractorState3D# a3 phase1, out#)
--   where
--     delta       = speed * recipSampleRate
--     phase1      = phase0 + delta
--     (#a3, out#) =
--       loop (#a1, out0#) = (#a0, 0#) for i <- each do
--         let
--           ui                 = indexToUInt i
--           (#(#v0, s0#), a2#) = readArrayU i a1
--           v1                 = v0 + (Vector3D# delta delta delta * attractorF param phase0 v0)
--           (#s1, x#)          = mapF ui v1 s0
--           out1               = out0 + (x * recipSize)
--         in
--           (#writeArray i (#v1, s1#) a2, x#)


-- TODO: 4th order Runge-Kutta method
accumulateAttractor3D :: (p -> Float -> Vector3D -> Vector3D) ->
                         (UInt -> Vector3D -> s -> (#s, Float#)) ->
                         Float -> p -> Float ->
                         *AttractorState3D w h d s -> (#*AttractorState3D w h d s, Float#)
accumulateAttractor3D attractorF mapF recipSize param speed (AttractorState3D# a0 time0) =
  (#AttractorState3D# a3 time1, out#)
  where
    delta       = speed * recipSampleRate
    hdelta      = delta / 2
    deltav      = Vector3D# delta delta delta
    time1       = time0 + delta
    oneSixth    = Vector3D# (1/6) (1/6) (1/6)
    (#a3, out#) =
      loop (#a1, out0#) = (#a0, 0#) for i <- each do
        let
          ui                 = indexToUInt i
          (#(#v0, s0#), a2#) = readArrayU i a1
          k1                 = deltav * attractorF param time0 v0
          k2                 = deltav * attractorF param (time0 + hdelta) (v0 + (k1 * 0.5))
          k3                 = deltav * attractorF param (time0 + hdelta) (v0 + (k2 * 0.5))
          k4                 = deltav * attractorF param time1 (v0 + k3)
          v1                 = v0 + (oneSixth * (k1 + (2 * k2) + (2 * k3) + k4))
          (#s1, x#)          = mapF ui v1 s0
          out1               = out0 + (x * recipSize)
        in
          (#writeArray i (#v1, s1#) a2, x#)

attractor3D :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (p -> Float -> Vector3D -> Vector3D) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> p -> f Audio -> f Audio
attractor3D size initF attractorF mapF p speed =
  accumulate1U (mkAttractorState3D wv hv dv initF) (accumulateAttractor3D attractorF mapF recipSize p) constTrueU speed
  where
    (#wv, hv, dv#) = natVal3ToNatVals size
    recipSize      = 1 / (fromUInt (natVal wv) * fromUInt (natVal hv) * fromUInt (natVal dv))

----------------------
-- Lorenz Attractor

-- lorenz 10 28 (8/3) (Vector3D# 0.0001 0.0001 0.0001)
lorenz :: (#Float, Float, Float#) -> Float -> Vector3D -> Vector3D
lorenz (#a, b, c#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = a * (y - x)
    dy = (x * (b - z)) - y
    dz = (x * y) - (c * z)

lorenzAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> Float -> f Audio -> f Audio
lorenzAttractor size initF mapF a b c speed =
  attractor3D size initF lorenz mapF (#a, b, c#) speed

----------------------
-- Rabinovich-Fabrikant Attractor

-- rabinovichFabrikant 0.87 1.1
rabinovichFabrikant :: (#Float, Float#) -> Float -> Vector3D -> Vector3D
rabinovichFabrikant (#a, g#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = (y * (z - 1 + (x * x))) + (g * x)
    dy = (x * ((3 * z) + 1 - (x * x))) + (g * y)
    dz = -2 * z * (a + (x * y))

rabinovichFabrikantAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> f Audio -> f Audio
rabinovichFabrikantAttractor size initF mapF a g speed =
  attractor3D size initF rabinovichFabrikant mapF (#a, g#) speed

----------------------
-- Lu Chen Attractor

-- luChen 36 3 20 -15.5
-- initV: 0.1 0.3 -0.6
luChen :: (#Float, Float, Float, Float#) -> Float -> Vector3D -> Vector3D
luChen (#a, b, c, u#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = a * (y - x)
    dy = x - (x * z) + (c * y) + u
    dz = (x * y) - (b * z)

luChenAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> Float -> Float -> f Audio -> f Audio
luChenAttractor size initF mapF a b c u speed =
  attractor3D size initF luChen mapF (#a, b, c, u#) speed


-----------
-- Sync
-----------

-- TODO: default instance instead of accumulate3U
data SyncState = SyncState# Float Float Float

mkSyncState :: () -> *SyncState
mkSyncState _ = SyncState# 0 1 1

-- Kick Sync
accumulateSyncSaw :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncSaw sync kick freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    posSync = fromInt <| boolToInt <| (prevSync <= 0 && sync > 0)
    negSync = fromInt <| boolToInt <| (prevSync >= 0 && sync < 0)
    delta   = freq * recipSampleRate
    kicks   = posSync * kick + negSync * negate kick
    phase1  = delta + phase0 + kicks
    phase2  = phase1 - floor phase1
    out     = fma phase2 2.0 -1.0

syncSaw :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncSaw sync kickAmount freq =
  accumulate3U mkSyncState accumulateSyncSaw constTrueU sync kickAmount freq

-- Reverse sync
accumulateSyncTri :: Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncTri sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    phase2     = phase1 - floor phase1
    saw        = fma phase2 2.0 -1.0
    out        = fma (abs saw) 2.0 -1.0

syncTri :: AudioFormat f => f Audio -> f Audio -> f Audio
syncTri sync freq =
  accumulate2U mkSyncState accumulateSyncTri constTrueU sync freq

-- TODO: Branchless
-- Hard Sync
accumulateSyncPulse :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncPulse sync width freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    phase1  =
      if prevSync <= 0 && sync > 0 then
        0
      else if prevSync >= 0 && sync < 0 then
        width
      else
        fma freq recipSampleRate phase0
    phase2  = phase1 - floor phase1
    out     = fma (fromInt (boolToInt (phase2 >= width))) 2.0 (-1.0)

syncPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncPulse sync width freq =
  accumulate3U mkSyncState accumulateSyncPulse constTrueU sync width freq

-- Reverse Sync
accumulateSyncWave :: WaveTable -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncWave (WaveTable buffer) sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    findex     = phase1 * 65536
    delta      = (floor findex + 1) - findex
    index1     = bitAnd (floatToUInt findex) 65535
    index2     = bitAnd (index1 + 1) 65535
    sample1    = readArray (Index index1) buffer
    sample2    = readArray (Index index2) buffer
    out        = sample1 * delta + sample2 * (1 - delta)

syncWave :: AudioFormat f => WaveTable -> f Audio -> f Audio -> f Audio
syncWave buffer sync freq =
  accumulate2U mkSyncState (accumulateSyncWave buffer) constTrueU sync freq

syncSin :: AudioFormat f => f Audio -> f Audio -> f Audio
syncSin sync freq = syncWave sinTable sync freq

-----------
-- minBLEP hard sync saw

accumulateMinBlepSawHardSync :: Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepSawHardSync sync freq (MinBlepState# phase0 state0 cBuffer0) =
  (#MinBlepState# phase2 state1 cBuffer3, out#)
  where
    syncPolarity0 = bitAnd 64 state0
    cIndex0       = bitAnd 31 state0
    cIndex1       = bitAnd (cIndex0 + 1) 31
    syncPolarity1 = bitShiftLeft (fromInt <| boolToInt <| sync >= 0) 6
    freqDelta     = freq * recipSampleRate
    phase1        = phase0 + freqDelta
    (#phase2, cBuffer1#) =
      if syncPolarity0 > 0 && syncPolarity1 == 0 then
        (#0, addMinBlep (0 - phase1) 0 cIndex0 cBuffer0#)
      else if syncPolarity0 == 0 && syncPolarity1 > 0 then
        (#0.5, addMinBlep (0.5 - phase1) 0 cIndex0 cBuffer0#)
      else if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0#)
      else
        (#phase1, cBuffer0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    out              = fma (phase2 + cx) 2 -1
    state1           = bitOr syncPolarity1 cIndex1

hardSyncSaw :: AudioFormat f => f Audio -> f Audio -> f Audio
hardSyncSaw sync freq =
  accumulate2U mkMinBlepState accumulateMinBlepSawHardSync constTrueU sync freq

-----------
-- minBLEP hard sync pulse

accumulateMinBlepPulseHardSync :: Float -> Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepPulseHardSync sync width freq (MinBlepState# phase0 state0 cBuffer0) =
  (#MinBlepState# phase2 state1 cBuffer3, out#)
  where
    syncPolarity0 = bitAnd 64 state0
    mode0         = bitAnd 32 state0
    cIndex0       = bitAnd 31 state0
    cIndex1       = bitAnd (cIndex0 + 1) 31
    syncPolarity1 = bitShiftLeft (fromInt <| boolToInt <| sync >= 0) 6
    freqDelta     = freq * recipSampleRate
    phase1        = phase0 + freqDelta
    (#phase2, cBuffer1, mode1#) =
      if syncPolarity0 > 0 && syncPolarity1 == 0 then
        let
          phase2   = 0
          mode1    = 0
          cBuffer1 = if mode0 == 0 then cBuffer0 else addMinBlep -1 0 cIndex0 cBuffer0
        in
          (#phase2, cBuffer1, mode1#)
      else if syncPolarity0 == 0 && syncPolarity1 > 0 then
        let
          phase2   = width
          mode1    = 32
          cBuffer1 = if mode0 == 32 then cBuffer0 else addMinBlep 1 0 cIndex0 cBuffer0
        in
          (#phase2, cBuffer1, mode1#)
      else if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
          mode1    = uselect (phase2 <= width) 0 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else if (mode0 == 0 && phase1 >= width && freq > 0) || (mode0 == 32 && phase1 < width && freq < 0) then
        let
          polarity = fselect (mode0 == 0) 1 -1
          offset   = ((abs (phase1 - width)) / abs freqDelta) * 32
          mode1    = uselect (mode0 == 0) 32 0
        in
          (#phase1, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else
        (#phase1, cBuffer0, mode0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    y                = fselect (mode1 == 0) 0 1
    out              = fma (y + cx) 2 -1
    state1           = bitOr syncPolarity1 (bitOr mode1 cIndex1)

hardSyncPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
hardSyncPulse sync width freq =
  accumulate3U mkMinBlepState accumulateMinBlepPulseHardSync constTrueU sync width freq

-----------
-- Super Osc
-- Based on Roland JP-8000 super saw oscillator design
data SuperSawState = SuperSawState# Float Float Float Float Float Float Float

-- TODO: Make default instance for SuperSawState instead of relying on accumulate3U, now that init weirdness has been fixed
mkSuperSawState :: () -> *SuperSawState
mkSuperSawState _ = SuperSawState# 0.260786585 0.087023334 0.866947809 0.392499353 0.728213602 0.122864975 0.167605335

accumulateSuperSaw :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperSaw freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (phaseA1 - floor phaseA1) 2 -1 * sideMix
    oscB    = fma (phaseB1 - floor phaseB1) 2 -1 * sideMix
    oscC    = fma (phaseC1 - floor phaseC1) 2 -1 * sideMix
    oscD    = fma (phaseD1 - floor phaseD1) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (phaseE1 - floor phaseE1) 2 -1 * sideMix
    oscF    = fma (phaseF1 - floor phaseF1) 2 -1 * sideMix
    oscG    = fma (phaseG1 - floor phaseG1) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: superoscs are specifically NOT bandlimited,
-- instead the aliasing combined with phase cancelation is considered part of the sound of the oscillator
-- A hpf is put in place to eliminate low frequency aliased frequencies
-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superSaw :: (AudioFormat f, Num (f Audio)) => f Audio -> f Audio -> f Audio -> f Audio
superSaw freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperSaw constTrueU freq depth mix
  |> hpf freq 6

accumulateSuperPulse :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperPulse freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    width   = 0.5 -- need accumulate4U to make this another parameter
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (fromInt <| boolToInt <| (phaseA1 - floor phaseA1) > width) 2 -1 * sideMix
    oscB    = fma (fromInt <| boolToInt <| (phaseB1 - floor phaseB1) > width) 2 -1 * sideMix
    oscC    = fma (fromInt <| boolToInt <| (phaseC1 - floor phaseC1) > width) 2 -1 * sideMix
    oscD    = fma (fromInt <| boolToInt <| (phaseD1 - floor phaseD1) > width) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (fromInt <| boolToInt <| (phaseE1 - floor phaseE1) > width) 2 -1 * sideMix
    oscF    = fma (fromInt <| boolToInt <| (phaseF1 - floor phaseF1) > width) 2 -1 * sideMix
    oscG    = fma (fromInt <| boolToInt <| (phaseG1 - floor phaseG1) > width) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superPulse freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperPulse constTrueU freq depth mix
  |> hpf freq 2

accumulateSuperTri :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperTri freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (abs (fma (phaseA1 - floor phaseA1) 2 -1)) 2 -1 * sideMix
    oscB    = fma (abs (fma (phaseB1 - floor phaseB1) 2 -1)) 2 -1 * sideMix
    oscC    = fma (abs (fma (phaseC1 - floor phaseC1) 2 -1)) 2 -1 * sideMix
    oscD    = fma (abs (fma (phaseD1 - floor phaseD1) 2 -1)) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (abs (fma (phaseE1 - floor phaseE1) 2 -1)) 2 -1 * sideMix
    oscF    = fma (abs (fma (phaseF1 - floor phaseF1) 2 -1)) 2 -1 * sideMix
    oscG    = fma (abs (fma (phaseG1 - floor phaseG1) 2 -1)) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superTri :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superTri freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperTri constTrueU freq depth mix
  |> hpf freq 2

----------------------
-- Biquad
----------------------

data Biquad      = Biquad# Float Float Float Float Float Float
data BiquadState = BiquadState# Float Float Float Float

instance Default BiquadState where
  default = BiquadState# 0 0 0 0

biquadMk :: Float -> Float -> Float -> Biquad
biquadMk freq radius gain =
  Biquad# b0 b1 b2 a1 a2 gain
  where
    a1   = -2 * radius * cosine (tau * freq * recipSampleRate)
    a2   = radius * radius
    b0   = 1
    b1   = 0
    b2   = -1

biquadTick :: Biquad -> Float -> BiquadState -> (#BiquadState, Float#)
biquadTick (Biquad# b0 b1 b2 a1 a2 gain) input (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 y0 y1, y0#)
  where
    x0 = input * gain
    y0 =
      (b0 * x0 + b1 * x1 + b2 * x2) -
      (a2 * y2 + a1 * y1)

biquadTick' :: Biquad -> Float -> BiquadState -> (#BiquadState, Float#)
biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 y0 y1, y0#)
  where
    ra0 = 1 / a0
    y0  =
      fma (b0 * ra0) x0 (fma (b1 * ra0) x1 (b2 * ra0 * x2)) - (a1 * ra0 * y1) - (a2 * ra0 * y2)


----------------------
-- RBJ Filters, Audio EQ Cookbook
----------------------

-- fi range: 0 - 1
waveTableFunction :: WaveTable -> Float -> Float
waveTableFunction (WaveTable buffer) fi =
  sample1 * (1 - delta) + sample2 * delta
  where
    findex  = fi * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer

-----------
-- lpf
accumulateLPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLPF freq q x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 - cso) * 0.5
    b1    =  1 - cso
    b2    = (1 - cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha

lpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
lpf freq q input =
  accumulate3 accumulateLPF constTrue freq q input

-----------
-- hpf
accumulateHPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHPF freq q x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 + cso) * 0.5
    b1    = negate (1 + cso)
    b2    = (1 + cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha

hpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
hpf freq q input =
  accumulate3 accumulateHPF constTrue freq q input

-----------
-- bpf
accumulateBPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateBPF freq q x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = alpha
    b1    = 0
    b2    = negate alpha
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha

bpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
bpf freq q input =
  accumulate3 accumulateBPF constTrue freq q input

-----------
-- lowShelf
accumulateLowShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLowShelf slope freq gain x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    biga  = pow 10 (gain * 0.025)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) - ((biga - 1) * cso) + beta)
    b1    = 2 * biga * ((biga - 1) - ((biga + 1) * cso))
    b2    = biga * ((biga + 1) - ((biga - 1) * cso) - beta)
    a0    = (biga + 1) + ((biga - 1) * cso) + beta
    a1    = -2 * ((biga - 1) + ((biga + 1) * cso))
    a2    = (biga + 1) + ((biga - 1) * cso) - beta

lowShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
lowShelf freq gain slope input =
  accumulate3 (accumulateLowShelf slope) constTrue freq gain input

-----------
-- highShelf
accumulateHighShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHighShelf slope freq gain x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    biga  = pow 10 (gain * 0.025)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) + ((biga - 1) * cso) + beta)
    b1    = -2 * biga * ((biga - 1) + ((biga + 1) * cso))
    b2    = biga * ((biga + 1) + ((biga - 1) * cso) - beta)
    a0    = (biga + 1) - ((biga - 1) * cso) + beta
    a1    = 2 * ((biga - 1) - ((biga + 1) * cso))
    a2    = (biga + 1) - ((biga - 1) * cso) - beta

highShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
highShelf freq gain slope input =
  accumulate3 (accumulateHighShelf slope) constTrue freq gain input

-----------
-- peakEQ

peakEQTick :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
peakEQTick bandWidthInOctaves freq gain x0 state =
  biquadTick' (Biquad# b0 b1 b2 a0 a1 a2) x0 state
  where
    biga  = pow 10 (gain * 0.025)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    so    = waveTableFunction sinTable omega
    alpha = so * sineh (log 2 * 0.5 * bandWidthInOctaves * (omega / so))
    b0    =  1 + alpha * biga
    b1    = -2 * cso
    b2    =  1 - alpha * biga
    a0    =  1 + (alpha / biga)
    a1    = -2 * cso
    a2    =  1 - (alpha / biga)

peakEQ :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
peakEQ freq gain bandWidthInOctaves input =
  accumulate3 (peakEQTick bandWidthInOctaves) constTrue freq gain input

----------
-- OnePole
data OnePole = OnePole Float

instance Default OnePole where
  default = OnePole 0

-- Note: expected pole range: 0 - 1
onePoleTick :: Float -> Float -> Float -> OnePole -> (#OnePole, Float#)
onePoleTick pole gain input (OnePole z0) =
  (#OnePole z1, z1#)
  where
    a  = 0 - pole
    b  = if pole < 0 then 1 + pole else 1 - pole
    x  = input * gain
    z1 = b * x - a * z0


-----------
-- lag
accumulateLag :: Float -> Float -> Float -> (#Float, Float#)
accumulateLag lagTime input z =
  (#out, out#)
  where
    a   = exp ((-2 * pi) / (lagTime * audioSampleRateF))
    b   = 1 - a
    out = (input * b) + (z * a)

lag :: AudioFormat f => f Audio -> f Audio -> f Audio
lag lagTime input =
  accumulate2 accumulateLag constTrue lagTime input

data LagState = LagState Float

accumulateLag' :: Float -> Float -> *LagState -> (#*LagState, Float#)
accumulateLag' lagTime input (LagState z) =
  (#LagState out, out#)
  where
    a   = exp ((-2 * pi) / (lagTime * audioSampleRateF))
    b   = 1 - a
    out = (input * b) + (z * a)

lag' :: AudioFormat f => Float -> f Audio -> f Audio -> f Audio
lag' initialValue lagTime input =
  accumulate2U (\_ -> LagState initialValue) accumulateLag' constTrueU lagTime input

-----------
-- range

-- TODO: mapAudio3, mapAudio3Vec
-- mapRange3 :: Float -> Float
-- mapRange3 x =


-----------
-- delay
data DelayState s = DelayState# (.Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) Float) UInt Float

natSecondsToNatBufferSamples :: Seconds n -> NatVal (NatNextPowerOfTwo (NatMul SampleRate (NatMax n 1)))
natSecondsToNatBufferSamples _ = NatVal

-- TODO: Interpolate delayTime!
-- TODO: delay playback speed? Reverse delay? delay bank etc?
-- TODO: initialDelayTime, maxDelayTime, audioBufferSize, etc

accumulateDelay :: UInt -> Float -> Float -> Float -> *DelayState s -> (#*DelayState s, Float#)
accumulateDelay bufferSizeMinus1 targetDelayTime mix input (DelayState# buffer0 index delayTime) =
  (#DelayState# buffer2 index' delayTime', out#)
  where
    delayTime'       = targetDelayTime
    delayIndex       = bitAnd (index + floatToUInt (delayTime' * audioSampleRateF)) bufferSizeMinus1
    (#del, buffer1#) = readArrayU (Index index) buffer0
    out              = input * (1 - mix) + del * mix
    buffer2          = writeArray (Index delayIndex) out buffer1
    index'           = bitAnd (index + 1) bufferSizeMinus1

mkDelayState :: Seconds s -> () -> *DelayState s
mkDelayState _ _ = DelayState# (arrayFrom 0) 0 1

delay :: AudioFormat f => Seconds n -> f Audio -> f Audio -> f Audio -> f Audio
delay maxDelayTime delayTime mix input =
  accumulate3U (mkDelayState maxDelayTime) (accumulateDelay (natVal (natSecondsToNatBufferSamples maxDelayTime) - 1)) (\s -> (#s, True#)) delayTime mix input

delay' :: AudioFormat f => Seconds n -> f Audio -> f Audio -> f Audio -> f Audio -> f Audio
delay' maxDelayTime delayTime feedbackAmount wetMix input =
  map3 (\x y m -> x * (1 - m) + y * m) input wet wetMix
  where
    wet = accumulate3U (mkDelayState maxDelayTime) (accumulateDelay (natVal (natSecondsToNatBufferSamples maxDelayTime) - 1)) (\s -> (#s, True#)) delayTime feedbackAmount input


oneSec :: Seconds 1
oneSec = Seconds

twoSec :: Seconds 2
twoSec = Seconds

threeSec :: Seconds 3
threeSec = Seconds

fourSec :: Seconds 4
fourSec = Seconds

fiveSec :: Seconds 5
fiveSec = Seconds

sixSec :: Seconds 6
sixSec = Seconds

sevenSec :: Seconds 7
sevenSec = Seconds

eightSec :: Seconds 8
eightSec = Seconds

nineSec :: Seconds 9
nineSec = Seconds

tenSec :: Seconds 10
tenSec = Seconds


-----------
-- Pluck: Karplus Strong

data PluckState n = PluckState# (.Array (NatMul BlockSize n) Float) UInt UInt

accumulatePluck :: UInt -> Float -> Float -> *PluckState s -> (#*PluckState s, Float#)
accumulatePluck bufferSizeMinus1 freq damping (PluckState# buffer0 index0 count) =
  (#PluckState# buffer3 index1 count, out#)
  where
    delaySamples     = min (floatToUInt (audioSampleRateF / freq)) bufferSizeMinus1
    delayIndex1      = (index0 + delaySamples) % delaySamples
    delayIndex2      = (delayIndex1 + 1) % delaySamples
    (#d1, buffer1#)  = readArrayU (Index delayIndex1) buffer0
    (#d2, buffer2#)  = readArrayU (Index delayIndex2) buffer1
    out              = (d1 + d2) * 0.5 * damping
    buffer3          = writeArray (Index index0) out buffer2
    index1           = (index0 + 1) % delaySamples

-- Note: Fill Buffer with quick'n'dirty random noise
mkPluckState :: NatVal n -> () -> *PluckState n
mkPluckState _ _ =
  PluckState# arr 0 0
  where
    seed       = 123456789
    a          = 1664525
    c          = 1013904223
    m          = 4294967296
    (#arr, _#) =
      loop (#arr, s#) = (#unsafeEmptyArray (), seed#) for i <- each do
        let
          s'   = (a * s + c) % m
          arr' = writeArray i (((fromUInt s' / 1000000) % 2) - 1) arr
        in
          (#arr', s'#)

pluck :: AudioFormat f => NatVal n -> f Audio -> f Audio -> f Audio
pluck maxDelayInBlocks freq damping =
  accumulate2U (mkPluckState maxDelayInBlocks) (accumulatePluck (natVal maxDelayInBlocks * audioBlockSize - 1)) (\s -> (#s, True#)) freq damping

-----------
-- Interlude: Interpolation

cubicInterpolation :: Float -> Float -> Float -> Float -> Float -> Float
cubicInterpolation p0 p1 p2 p3 mu =
  a0 * mu * mewTwo + a1 * mewTwo + a2 * mu + a3
  where
    a0     = p3 - p2 - p0 + p1
    a1     = p0 - p1 - a0
    a2     = p2 - p0
    a3     = p1
    mewTwo = mu * mu -- Get it?

cosineInterpolation :: Float -> Float -> Float -> Float
cosineInterpolation y1 y2 mu =
  y1 * (1 - mu2) + y2 * mu2
  where
    mu2 = (1 - cosine (mu * pi)) / 2

-- Larange interpolation for Fractional Delay lines
-- https://ccrma.stanford.edu/~jos/pasp/Larange_Interpolation.html
-- Thanks ccrma for the great info!
lagrangeInterpolation3 :: Float -> Float -> Float -> Float -> Float -> Float
lagrangeInterpolation3 s0 s1 s2 s3 delta =
  s0 * h0 + s1 * h1 + s2 * h2 + s3 * h3
  where
    h0 = -1 * (((delta - 1) * (delta - 2) * (delta - 3)) / 6)
    h1 = (delta * (delta - 2) * (delta - 3)) / 2
    h2 = -1 * ((delta * (delta - 1) * (delta - 3)) / 2)
    h3 = (delta * (delta - 1) * (delta - 2)) / 6

lagrangeInterpolation4 :: Float -> Float -> Float -> Float -> Float -> Float -> Float
lagrangeInterpolation4 s0 s1 s2 s3 s4 delta =
  s0 * h0 + s1 * h1 + s2 * h2 + s3 * h3 + s4 * h4
  where
    dm1 = delta - 1
    dm2 = delta - 2
    dm3 = delta - 3
    dm4 = delta - 4
    h0  = (dm1 * dm2 * dm3 * dm4) / 24
    h1  = (0 - delta * dm2 * dm3 * dm4) / 6
    h2  = (delta * dm1 * dm3 * dm4) / 4
    h3  = (0 - delta * dm1 * dm2 * dm4) / 6
    h4  = (delta * dm1 * dm2 * dm3) / 24

-----------
-- Delay Line
-- Note: This is a non-fractional delay line which can only perform integral delay lengths
data Delay n = Delay# (.Array (NatNextPowerOfTwo n) Float) UInt UInt UInt

mkDelay :: UInt -> NatVal n -> *Delay n
mkDelay delayLength n =
  Delay# arr sizeMask 0 outCursor
  where
    pow2n        = nextPowerOfTwoNatVal n
    sizeMask     = natVal pow2n - 1
    arr          = arrayFrom 0
    outCursor    = bitAnd (0 - delayLength) sizeMask

delayReadOutput :: *Delay n -> (#Float, *Delay n#)
delayReadOutput (Delay# arr0 sizeMask inCursor outCursor) =
  (#out, Delay# arr1 sizeMask inCursor outCursor#)
  where
    (#out, arr1#) = readArrayU (unsafeUIntToIndex outCursor) arr0

delayTick :: Float -> *Delay n -> *Delay n
delayTick sample (Delay# arr0 sizeMask inCursor0 outCursor0) =
  Delay# arr1 sizeMask inCursor1 outCursor1
  where
    inCursor1  = bitAnd (inCursor0 + 1) sizeMask
    outCursor1 = bitAnd (outCursor0 + 1) sizeMask
    arr1       = writeArray (unsafeUIntToIndex inCursor1) sample arr0


-----------
-- Fractional Delay Line
data FractionalDelay n = FractionalDelay# (.Array (NatNextPowerOfTwo n) Float) UInt Float Float UInt UInt

mkFractionalDelay' :: NatVal n -> () -> *FractionalDelay n
mkFractionalDelay' n _ = mkFractionalDelay n

mkFractionalDelay :: NatVal n -> *FractionalDelay n
mkFractionalDelay n =
  FractionalDelay# arr sizeMask stringLength 0 0 0
  where
    sizeMask     = natVal n - 1
    stringLength = fromUInt sizeMask
    arr          = arrayFrom 0

fracDelaySetDelay :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetDelay delayLength (FractionalDelay# arr sizeMask _ _ inCursor _) =
  FractionalDelay# arr sizeMask delayLength delta inCursor outCursor
  where
    outCursor        = bitAnd (inCursor - (floatToUInt delayLength)) sizeMask
    delta            = 1 - (delayLength - floor delayLength)

-- Do we need the + 1 or not?
fracDelaySetDelayFromFreq :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetDelayFromFreq freq (FractionalDelay# arr sizeMask _ _ inCursor _) =
  FractionalDelay# arr sizeMask stringLength delta inCursor outCursor
  where
    stringLength     = ((audioSampleRateF / freq) / 2)
    outCursor        = bitAnd (inCursor - (floatToUInt stringLength)) sizeMask
    delta            = 1 - (stringLength - floor stringLength)

fracDelayReadOutput :: *FractionalDelay n -> (#Float, *FractionalDelay n#)
fracDelayReadOutput (FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor) =
  (#out, FractionalDelay# arr5 sizeMask stringLength delta inCursor outCursor#)
  where
    index0       = outCursor
    indexM1      = bitAnd (index0 - 1) sizeMask
    indexM2      = bitAnd (index0 - 2) sizeMask
    index1       = bitAnd (index0 + 1) sizeMask
    index2       = bitAnd (index0 + 2) sizeMask
    (#s0, arr1#) = readArrayU (unsafeUIntToIndex indexM2) arr0
    (#s1, arr2#) = readArrayU (unsafeUIntToIndex indexM1) arr1
    (#s2, arr3#) = readArrayU (unsafeUIntToIndex index0) arr2
    (#s3, arr4#) = readArrayU (unsafeUIntToIndex index1) arr3
    (#s4, arr5#) = readArrayU (unsafeUIntToIndex index2) arr4
    out          = lagrangeInterpolation4 s0 s1 s2 s3 s4 (2.0 + delta)

fracDelayReadFromPos :: Float -> *FractionalDelay n -> (#Float, *FractionalDelay n#)
fracDelayReadFromPos readPos (FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor) =
  (#out, FractionalDelay# arr5 sizeMask stringLength delta inCursor outCursor#)
  where
    readOffset   = floatToUInt (readPos * stringLength)
    index0       = bitAnd (outCursor - readOffset) sizeMask
    indexM1      = bitAnd (index0 - 1) sizeMask
    indexM2      = bitAnd (index0 - 2) sizeMask
    index1       = bitAnd (index0 + 1) sizeMask
    index2       = bitAnd (index0 + 2) sizeMask
    (#s0, arr1#) = readArrayU (unsafeUIntToIndex indexM2) arr0
    (#s1, arr2#) = readArrayU (unsafeUIntToIndex indexM1) arr1
    (#s2, arr3#) = readArrayU (unsafeUIntToIndex index0) arr2
    (#s3, arr4#) = readArrayU (unsafeUIntToIndex index1) arr3
    (#s4, arr5#) = readArrayU (unsafeUIntToIndex index2) arr4
    out          = lagrangeInterpolation4 s0 s1 s2 s3 s4 (2.0 + delta)

fracDelaySetPos :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetPos inCursorPos (FractionalDelay# arr0 sizeMask stringLength delta _ _) =
  FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor
  where
    inCursor  = bitAnd (floatToUInt (inCursorPos * stringLength)) sizeMask
    outCursor = bitAnd (inCursor - (floatToUInt stringLength)) sizeMask

fracDelayTick :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelayTick sample (FractionalDelay# arr0 sizeMask stringLength delta inCursor0 outCursor0) =
  FractionalDelay# arr1 sizeMask stringLength delta inCursor1 outCursor1
  where
    inCursor1  = bitAnd (inCursor0 + 1) sizeMask
    outCursor1 = bitAnd (outCursor0 + 1) sizeMask
    arr1       = writeArray (unsafeUIntToIndex inCursor1) sample arr0

fractionalDelayTick :: Float -> Float -> Float -> *FractionalDelay n -> (#*FractionalDelay n, Float#)
fractionalDelayTick delayTime mix input state0 =
  (#state3, out#)
  where
    (#sample, state1#) = fracDelayReadOutput state0
    out                = input * (1 - mix) + sample * mix
    state2             = fracDelaySetDelay delayTime state1
    state3             = fracDelayTick out state2

fractionalDelay :: AudioFormat f => Seconds n -> f Audio -> f Audio -> f Audio -> f Audio
fractionalDelay maxDelayTime delayTime mix input =
  accumulate3U (mkFractionalDelay' n) fractionalDelayTick (\s -> (#s, True#)) delayTime mix input
  where
    n = natSecondsToNatBufferSamples maxDelayTime


-----------
-- Waveguide Synthesis: Pluck

data WaveGuidePluckState n = WaveGuidePluckState# (.FractionalDelay (NatMul BlockSize n)) (.FractionalDelay (NatMul BlockSize n)) OnePole

waveGuideBridgeReflection :: Float -> Float -> Float -> (#Float, Float#)
waveGuideBridgeReflection sustain sample state0 =
  (#negate state1, state1#)
  where
    state1 = sample * sustain + state0 * (1 - sustain)

accumulateWaveGuidePluck :: Float -> Float -> Float -> Float -> *WaveGuidePluckState n -> (#*WaveGuidePluckState n, Float#)
accumulateWaveGuidePluck brightness sustain freq pickupLocation (WaveGuidePluckState# leftBuffer0 rightBuffer0 bridgeReflectionState0) =
  (#WaveGuidePluckState# leftBuffer4 rightBuffer4 bridgeReflectionState1, out#)
  where
    leftBuffer1                                   = fracDelaySetDelayFromFreq freq leftBuffer0 -- Set Freq
    rightBuffer1                                  = fracDelaySetDelayFromFreq freq rightBuffer0
    -- Read Outputs
    (#pickupSampleLeft,  leftBuffer2#)            = fracDelayReadFromPos pickupLocation leftBuffer1
    (#pickupSampleRight, rightBuffer2#)           = fracDelayReadFromPos pickupLocation rightBuffer1
    (#bridgeSample, leftBuffer3#)                 = fracDelayReadOutput leftBuffer2
    (#nutSample, rightBuffer3#)                   = fracDelayReadOutput rightBuffer2
    -- Nut and Bridge
    invertedNutReflection                         = negate nutSample
    (#bridgeReflectionState1, bridgeReflection0#) = onePoleTick brightness sustain bridgeSample bridgeReflectionState0
    bridgeReflection                              = negate bridgeReflection0

    -- Tick Delays
    leftBuffer4                                   = fracDelayTick invertedNutReflection leftBuffer3
    rightBuffer4                                  = fracDelayTick bridgeReflection rightBuffer3
    -- Out
    out                                           = (pickupSampleLeft + pickupSampleRight) + (bridgeReflection + invertedNutReflection) * 0.125
    -- out                                          = pickupSampleLeft

-- -- Option for either somehow? pizz vs pluck?
-- -- randLCG pluck init
-- mkWaveGuidePluckState :: NatVal n -> Float -> Float -> Float -> () -> *WaveGuidePluckState n
-- mkWaveGuidePluckState n pickLocation pickAmplitude freq _ =
--   WaveGuidePluckState# left3 right3 default
--   where
--     delaySize      = natVal n * audioBlockSize
--     pickAmplitudeN = negate pickAmplitude
--     left0  = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq -- TODO: put freq argument into mkFractionalDelay so that we don't have to set it after we mk it
--     right0 = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
--     (#_, _, left2, right2#) =
--       loop (#i, seed0, left1, right1#) = (#0, 1337, left0, right0#) while i < delaySize do
--         let
--           (#seed1, randL#) = randLCG -1 1 seed0
--           (#seed2, randR#) = randLCG -1 1 seed1
--         in
--           (#i + 1, seed2, fracDelayTick (randL * pickAmplitude) left1, fracDelayTick (randR * pickAmplitudeN) right1#)
--     left3  = fracDelaySetPos pickLocation left2
--     right3 = fracDelaySetPos pickLocation right2

-- Original pluck waveform init
mkWaveGuidePluckState :: NatVal n -> Float -> Float -> Float -> () -> *WaveGuidePluckState n
mkWaveGuidePluckState n pickLocation pickAmplitude freq _ =
  WaveGuidePluckState# left2 right2 default
  where
    pickAmplitudeN = negate pickAmplitude
    fullLength     = ((audioSampleRateF / freq) / 2)
    delaySize      = min (floatToUInt fullLength) (natVal n * audioBlockSize)
    pickSample     = max (fullLength * pickLocation) 1
    pickIndex      = pickSample |> floatToUInt
    upSlope        = 1 / pickSample
    downSlope      = 1 / (fullLength - pickSample - 1)
    left00         = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
    right00        = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
    (#_, _, left1, right1#) =
      loop (#i, seed0, left0, right0#) = (#0, 1337, left00, right00#) while i < delaySize do
        let
          (#seed1, randL#) = randLCG -1 1 seed0
          (#seed2, randR#) = randLCG -1 1 seed1
          ri          = (delaySize - 1) - i
          rightSample =
            if i < pickIndex then
              (upSlope * fromUInt i) * pickAmplitude
            else
              (downSlope * (fullLength - 1 - fromUInt i))
          leftSample =
            if ri < pickIndex then
              (upSlope * fromUInt ri)
            else
              (downSlope * (fullLength - 1 - fromUInt ri))
          leftSample2  = lerp randL (leftSample * 2 - 1) 0.8 * pickAmplitude
          rightSample2 = lerp (randR * -1) ((rightSample * 2 - 1) * -1) 0.8 * pickAmplitude
          -- leftSample2  = (leftSample * 2 - 1)
          -- rightSample2 = ((rightSample * 2 - 1) * -1)
        in
          (#i + 1, seed2, fracDelayTick leftSample2 left0, fracDelayTick rightSample2 right0#)
    left2  = fracDelaySetPos pickLocation left1
    right2 = fracDelaySetPos (1 - pickLocation) right1

waveGuidePluck :: NatVal n -> Float -> Float -> Float -> Float -> Mono Audio -> Mono Audio -> Mono Audio
waveGuidePluck maxDelayInBlocks pickLocation pickAmplitude brightness sustain freq pickupLocation =
  accumulate2U (mkWaveGuidePluckState maxDelayInBlocks pickLocation pickAmplitude (audioToFloat freq)) (accumulateWaveGuidePluck (clamp brightness 0 1) (clamp sustain 0 1)) (\s -> (#s, True#)) freq pickupLocation

-----------
-- Waveguide Synthesis: Bow
-- based on:
--   https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Bowed_String.html

-- Collapse this into only 2 fractional delays
data WaveGuideBowState n =
  WaveGuideBowState#
    (.FractionalDelay (NatMul BlockSize n)) -- Neck Delay
    (.FractionalDelay (NatMul BlockSize n)) -- Bridge Delay
    OnePole
    ViolinBodyFilter

-- TODO: Start at bow location???
mkWaveGuideBowState :: NatVal n -> () -> *WaveGuideBowState n
mkWaveGuideBowState _ _ =
  WaveGuideBowState#
    (mkFractionalDelay NatVal)
    (mkFractionalDelay NatVal)
    default
    default

bowTable :: Float -> Float -> Float -> Float -> Float -> Float
bowTable diffVelocity offset slope minOut maxOut =
  x4
  where
    x0 = diffVelocity + offset
    x1 = x0 * slope
    x2 = abs x1 + 0.75
    x3 = pow x2 -4
    x4 = clamp x3 minOut maxOut

accumulateWaveGuideBow :: Float -> Float -> Float -> Float -> Float -> Float -> *WaveGuideBowState n -> (#*WaveGuideBowState n, Float#)
accumulateWaveGuideBow bowLocation brightness sustain bowSlope bowVelocity freq (WaveGuideBowState# neckDelay0 bridgeDelay0 bridgeReflectionState0 bodyState0) =
  (#stateOut, out#)
  where
    fullStringLength                              = (audioSampleRateF / freq) - 2
    bowToNutLength                                = fullStringLength * (1 - bowLocation)
    bridgeToBowLength                             = fullStringLength * bowLocation

    -- Update delay lengths
    neckDelay1                                    = fracDelaySetDelay bowToNutLength neckDelay0
    bridgeDelay1                                  = fracDelaySetDelay bridgeToBowLength bridgeDelay0

    -- Read outputs from delays
    (#neckSample,   neckDelay2#)                  = fracDelayReadOutput neckDelay1
    (#bridgeSample, bridgeDelay2#)                = fracDelayReadOutput bridgeDelay1

    -- Values
    invertedNutReflection                         = negate neckSample
    pole                                          = 0.65 - (brightness * 48000 * 0.5 * recipSampleRate)
    (#bridgeReflectionState1, bridgeReflection0#) = onePoleTick pole sustain bridgeSample bridgeReflectionState0
    bridgeReflection1                             = negate bridgeReflection0
    (#bodyState1, bodyResonance#)                 = violinBodyfilterAccumulate (bridgeSample * 0.8 * sustain) bodyState0
    bridgeReflection                              = bridgeReflection1 * 0.75 + bodyResonance * 0.25

    -- Nonlinear scattering junction
    stringVelocity                                = bridgeReflection + invertedNutReflection
    differentialVelocity                          = bowVelocity - stringVelocity
    newVelocity                                   = bowTable differentialVelocity 0 bowSlope 0 1 * differentialVelocity
    neckDelayInput                                = bridgeReflection + newVelocity
    bridgeDelayInput                              = invertedNutReflection + newVelocity

    -- Write inputs to delays
    neckDelay3                                    = fracDelayTick neckDelayInput neckDelay2
    bridgeDelay3                                  = fracDelayTick bridgeDelayInput bridgeDelay2

    -- Out
    -- out                                           = (bowToBridgeSample + bridgeReflection) * 0.5
    -- out                                           = bridgeReflection
    -- out                                           = bridgeSample * 0.75 + bridgeReflection * 0.25
    out                                           = bodyResonance
    -- out                                           = bridgeSample
    stateOut                                      = WaveGuideBowState# neckDelay3 bridgeDelay3 bridgeReflectionState1 bodyState1

waveGuideBow :: NatVal n -> Float -> Float -> Float -> Float -> Mono Audio -> Mono Audio -> Mono Audio
waveGuideBow maxDelayInBlocks bowLocation brightness sustain bowSlope bowVelocity freq =
  accumulate2U
    (mkWaveGuideBowState maxDelayInBlocks)
    (accumulateWaveGuideBow (clamp bowLocation 0 1) (clamp brightness 0 1) (clamp sustain 0 1) (max bowSlope 0))
    (\s -> (#s, True#))
    bowVelocity
    freq

-- Cascaded second order sections via Esteban Maestre
data ViolinBodyFilter =
  ViolinBodyFilter# BiquadState BiquadState BiquadState BiquadState BiquadState BiquadState

instance Default ViolinBodyFilter where
  default = ViolinBodyFilter# default default default default default default

violinBodyFilterTick :: Float -> Float -> Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
violinBodyFilterTick b0 b1 b2 a1 a2 x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 y0 y1, y0#)
  where
    y0 =
      (b0 * x0 + b1 * x1 + b2 * x2) -
      (a2 * y2 + a1 * y1)

violinBodyfilterAccumulate :: Float -> ViolinBodyFilter -> (#ViolinBodyFilter, Float#)
violinBodyfilterAccumulate input (ViolinBodyFilter# bq0 bq1 bq2 bq3 bq4 bq5) =
  (#ViolinBodyFilter# bq0' bq1' bq2' bq3' bq4' bq5', output5 * 0.1248#)
  where
    (#bq0', output0#) = violinBodyFilterTick 1  1.5667 0.3133 -0.5509 -0.3925 input   bq0
    (#bq1', output1#) = violinBodyFilterTick 1 -1.9537 0.9542 -1.6357  0.8697 output0 bq1
    (#bq2', output2#) = violinBodyFilterTick 1 -1.6683 0.8852 -1.7674  0.8735 output1 bq2
    (#bq3', output3#) = violinBodyFilterTick 1 -1.8585 0.9653 -1.8498  0.9516 output2 bq3
    (#bq4', output4#) = violinBodyFilterTick 1 -1.9299 0.9621 -1.9354  0.9590 output3 bq4
    (#bq5', output5#) = violinBodyFilterTick 1 -1.9800 0.9888 -1.9867  0.9923 output4 bq5

violinBodyFilter :: AudioFormat f => f Audio -> f Audio
violinBodyFilter input =
  accumulate1 violinBodyfilterAccumulate constTrue input


----------------------
-- Modal Bar
-- https://ccrma.stanford.edu/workshops/dsp2008/prc/PDFs/stringbar.pdf
----------------------

data ModalFrequency = ModalFrequency# Float Float Float Float -- 4 Modes
data ModalResonance = ModalResonance# Float Float Float Float -- 4 Modes
data ModalAmplitude = ModalAmplitude# Float Float Float Float -- 4 Modes
data ModalStickSig  = ModalStickSig#  Float Float Float       -- Hardness Position DirectGain
data ModalSignature =
  ModalSignature
    ModalFrequency
    ModalResonance
    ModalAmplitude
    ModalStickSig

marimbaSig :: ModalSignature
marimbaSig =
  ModalSignature
    (ModalFrequency# 1 3.99 10.65 -2443)
    (ModalResonance# 0.9996 0.9994 0.9994 0.999)
    (ModalAmplitude# 0.04 0.01 0.01 0.008)
    (ModalStickSig# 0.429688 0.445312 0.093750)

woodSig :: ModalSignature
woodSig =
  ModalSignature
    (ModalFrequency# 1 2.777 7.378 15.377)
    (ModalResonance# 0.996 0.994 0.994 0.99)
    (ModalAmplitude# 0.04 0.01 0.01 0.008)
    (ModalStickSig# 0.460938 0.375 0.046875)

resoSig :: ModalSignature
resoSig =
  ModalSignature
    (ModalFrequency# 1 2.777 7.378 15.377)
    (ModalResonance# 0.99996 0.99994 0.99994 0.9999)
    (ModalAmplitude# 0.02 0.005 0.005 0.004)
    (ModalStickSig# 0.453125 0.25 0.101562)

-- WaveTable

data ModalBar =
  ModalBar#
    BiquadState
    BiquadState
    BiquadState
    BiquadState
    OnePole
    Float -- AudioBufferState

instance Default ModalBar where
  default = ModalBar# default default default default default 0

-- TODO: Make AudioBuffer (Array n Float)
-- TODO: audioFileToBuffer :: AudioFormat f => AudioFile -> f (AudioBuffer)
-- TODO: Strike waveform
-- TODO: Vibrato?
-- modalBar :: AudioBuffer -> ModalSignature -> (Float, Float, Float) -> Float -> Float

modalBarMkModeBiquad :: Float -> Float -> Float -> Float -> Biquad
modalBarMkModeBiquad ratio radius gain baseFreq =
  biquadMk freq radius gain
  where
    freq =
      if ratio >= 0 then
        ratio * baseFreq
      else
        negate ratio

modalBarTick :: AudioBuffer -> Float -> Float -> Biquad -> Biquad -> Biquad -> Biquad -> Float -> ModalBar -> (#ModalBar, Float#)
modalBarTick ab directGain masterGain mode1 mode2 mode3 mode4 strikeAmplitude (ModalBar# bq10 bq20 bq30 bq40 op0 abState0) =
  (#ModalBar# bq11 bq21 bq31 bq41 op1 abState1, out#)
  where
    (#abState1, abOut#) = audioBufferPlayTick ab Loop 0.01 abState0
    (#op1, opOut#)      = onePoleTick (1 - strikeAmplitude) 1 abOut op0
    direct              = opOut * masterGain
    (#bq11, bq1Out#)    = biquadTick mode1 direct bq10 -- Feed onePole out in parallel to filters for each mode
    (#bq21, bq2Out#)    = biquadTick mode2 direct bq20
    (#bq31, bq3Out#)    = biquadTick mode3 direct bq30
    (#bq41, bq4Out#)    = biquadTick mode4 direct bq40
    filtered            = bq1Out + bq2Out + bq3Out + bq4Out
    -- out                 = direct
    out                 = lerp filtered direct directGain
    -- out                 = (filtered - filtered * directGain) + (direct * directGain)
    -- out                 = bq1Out

-- TODO: Handle audioformat + audio buffer!
-- AudioBuffer play rate based on hardness???
modalBar :: AudioFormat f => AudioBuffer -> ModalSignature -> Float -> f Audio -> f Audio
modalBar audioBuffer (ModalSignature frequencies resonances amplitudes stickSig) frequency strikeAmplitude =
  accumulate1 (modalBarTick audioBuffer directGain hardness mode1 mode2 mode3 mode4) constTrue strikeAmplitude
  where
    ModalFrequency# f1 f2 f3 f4                 = frequencies
    ModalResonance# r1 r2 r3 r4                 = resonances
    ModalAmplitude# _  _  _  a4                 = amplitudes
    ModalStickSig# hardness position directGain = stickSig
    ppi                                         = position * pi
    a1                                          =  0.12 * sine ppi
    a2                                          = -0.03 * sine (0.05 + 3.9 * ppi)
    a3                                          =  0.11 * sine (-0.05 + 11 * ppi)
    mode1                                       = modalBarMkModeBiquad f1 r1 frequency a1
    mode2                                       = modalBarMkModeBiquad f2 r2 frequency a2
    mode3                                       = modalBarMkModeBiquad f3 r3 frequency a3
    mode4                                       = modalBarMkModeBiquad f4 r4 frequency a4

nat1 :: NatVal 1
nat1 = NatVal

nat2 :: NatVal 2
nat2 = NatVal

nat3 :: NatVal 3
nat3 = NatVal

nat4 :: NatVal 4
nat4 = NatVal

nat5 :: NatVal 5
nat5 = NatVal

nat6 :: NatVal 6
nat6 = NatVal

nat7 :: NatVal 7
nat7 = NatVal

nat8 :: NatVal 8
nat8 = NatVal

nat16 :: NatVal 16
nat16 = NatVal

nat32 :: NatVal 32
nat32 = NatVal

nat64 :: NatVal 64
nat64 = NatVal

nat128 :: NatVal 128
nat128 = NatVal

nat256 :: NatVal 256
nat256 = NatVal

clip :: AudioFormat f => f Audio -> f Audio
clip cs =
  map (mapAudio (\x -> clamp x -1 1)) cs

softClip :: AudioFormat f => f Audio -> f Audio -> f Audio
softClip distortion input =
  map2 (mapAudio2 f) distortion input
  where
    f alpha x =
      2 * recipPi * atanF64 (alpha * x)


----------------------
-- Freeverb
----------------------

-- TODO / HACK / CRASH: Preset Nat values in data constructors is causing the compiler to crash!!!!!
-- We SHOULD be able to do:
-- data FreeVerbCombFilter = FreeVerbCombFilter# (.FractionalDelay 2048) Float

-- A Lowpass Feedback Combfilter
data FreeVerbCombFilter n = FreeVerbCombFilter# (.Delay n) Float
data FreeVerbAllPass    n = FreeVerbAllPass (.Delay n)
data FreeVerb c a         =
  FreeVerb#
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)

mkFreeVerb :: UInt -> () -> *FreeVerb 2048 1024
mkFreeVerb stereoSpread _ =
  FreeVerb# c0 c1 c2 c3 c4 c5 c6 c7 a0 a1 a2 a3
  where
    c0 = FreeVerbCombFilter# (mkDelay (1557 + stereoSpread) NatVal) 0
    c1 = FreeVerbCombFilter# (mkDelay (1617 + stereoSpread) NatVal) 0
    c2 = FreeVerbCombFilter# (mkDelay (1491 + stereoSpread) NatVal) 0
    c3 = FreeVerbCombFilter# (mkDelay (1422 + stereoSpread) NatVal) 0
    c4 = FreeVerbCombFilter# (mkDelay (1277 + stereoSpread) NatVal) 0
    c5 = FreeVerbCombFilter# (mkDelay (1356 + stereoSpread) NatVal) 0
    c6 = FreeVerbCombFilter# (mkDelay (1188 + stereoSpread) NatVal) 0
    c7 = FreeVerbCombFilter# (mkDelay (1116 + stereoSpread) NatVal) 0
    a0 = FreeVerbAllPass (mkDelay (225 + stereoSpread) NatVal)
    a1 = FreeVerbAllPass (mkDelay (556 + stereoSpread) NatVal)
    a2 = FreeVerbAllPass (mkDelay (441 + stereoSpread) NatVal)
    a3 = FreeVerbAllPass (mkDelay (341 + stereoSpread) NatVal)

freeVerbCombFilterTick :: Float -> Float -> Float -> *FreeVerbCombFilter 2048 -> (#*FreeVerbCombFilter 2048, Float#)
freeVerbCombFilterTick roomSize damp x (FreeVerbCombFilter# delay0 zs0) =
  (#FreeVerbCombFilter# delay2 zs1, y0#)
  where
    damp1          = damp * 0.4
    damp2          = 1 - damp1
    feedback       = roomSize * 0.28 + 0.7
    (#y0, delay1#) = delayReadOutput delay0
    zs1            = y0 * damp2 + zs0 * damp1
    y1             = x * 0.015 + zs1 * feedback
    delay2         = delayTick y1 delay1

freeVerbAllPassTick :: Float -> Float -> *FreeVerbAllPass 1024 -> (#*FreeVerbAllPass 1024, Float#)
freeVerbAllPassTick feedback x (FreeVerbAllPass delay0) =
  (#FreeVerbAllPass delay2, y0#)
  where
    (#delayOut, delay1#) = delayReadOutput delay0
    y0                   = negate x + delayOut
    y1                   = x + delayOut * feedback
    delay2               = delayTick y1 delay1

freeVerbTick :: Float -> Float -> Float -> Float -> *FreeVerb 2048 1024 -> (#*FreeVerb 2048 1024, Float#)
freeVerbTick mix roomSize damp x (FreeVerb# c0 c1 c2 c3 c4 c5 c6 c7 a0 a1 a2 a3) =
  (#FreeVerb# c0' c1' c2' c3' c4' c5' c6' c7' a0' a1' a2' a3', y#)
  where
    (#c0', sc0#) = freeVerbCombFilterTick roomSize damp x c0 -- Comb Filters, in parallel
    (#c1', sc1#) = freeVerbCombFilterTick roomSize damp x c1
    (#c2', sc2#) = freeVerbCombFilterTick roomSize damp x c2
    (#c3', sc3#) = freeVerbCombFilterTick roomSize damp x c3
    (#c4', sc4#) = freeVerbCombFilterTick roomSize damp x c4
    (#c5', sc5#) = freeVerbCombFilterTick roomSize damp x c5
    (#c6', sc6#) = freeVerbCombFilterTick roomSize damp x c6
    (#c7', sc7#) = freeVerbCombFilterTick roomSize damp x c7
    combsOut     = sc0 + sc1 + sc2 + sc3 + sc4 + sc5 + sc6 + sc7
    (#a0', sa0#) = freeVerbAllPassTick 0.5 combsOut a0 -- Allpass filters, in series
    (#a1', sa1#) = freeVerbAllPassTick 0.5 sa0 a1
    (#a2', sa2#) = freeVerbAllPassTick 0.5 sa1 a2
    (#a3', sa3#) = freeVerbAllPassTick 0.5 sa2 a3
    y            = x * (1 - mix) + sa3 * mix

-- mix:      0 - 1
-- roomSize: 0 - 1
-- damp:     0 - 1
freeVerb :: Float -> Float -> Stereo Audio -> Stereo Audio -> Stereo Audio
freeVerb mix roomSize (Stereo# dampL dampR) (Stereo# l0 r0) =
  Stereo# l1 r1
  where
    l1 = accumulateAudio2U (mkFreeVerb 0) (freeVerbTick mix roomSize) constTrueU dampL l0
    r1 = accumulateAudio2U (mkFreeVerb 23) (freeVerbTick mix roomSize) constTrueU dampR r0

--------------------
-- Trigger

data TriggerState = TriggerInactive | TriggerActive

instance Enum TriggerState where
  toEnum   x = if x == 0 then TriggerInactive else TriggerActive
  fromEnum x =
    case x of
      TriggerInactive -> 0
      _    -> 1

instance Eq TriggerState where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

zeroCrossingTick :: Float -> Float -> (#Float, Float#)
zeroCrossingTick sample lastPole = (#pole, result#)
  where
    pole = copysign 1 sample
    result = if pole >= 0 && lastPole < 0 then 1 else 0

-- creates an impulse ever sample a zero crossing is detected
zeroCrossing :: AudioFormat f => f Audio -> f Audio
zeroCrossing a = accumulate1 zeroCrossingTick constTrue a

triggerTick :: TriggerState -> Float -> TriggerState
triggerTick acc sample =
  case acc of
    TriggerInactive -> if (sample > 0) then TriggerActive else TriggerInactive
    _ -> TriggerActive

-- transforms zero-crossing impulses into logical triggers
genTriggers :: AudioFormat f => f Audio -> f TriggerState
genTriggers a = map (foldAudio triggerTick TriggerInactive) (zeroCrossing a)

latchTick :: Float -> Float -> Float -> (#Float, Float#)
latchTick tr a s =
  (#s', s'#)
  where
    s' = if tr > 0 then a else s

latch :: AudioFormat f => f Audio -> f Audio -> f Audio
latch tr a =
  map2 f tr a
  where
    f trc ac = accumulateAudio2 latchTick constTrue trc ac


----------------------
-- Score
----------------------

-- Basic idea:
--    * Score tick
--    * Score clock calculated via score tick + score tempo
--    * Score typeclass which provides everything you'll need
--    * Seqs are lazy accumulator functions and are passed in relevant information in a monadic fashion.
--    * runSeq quantization parameter (poly and seqToAudio quant parameter)

data Alphabet      = A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z deriving (Default, Enum)
data SectionType   = First | Coda | Head | Prime | Trans | Repeated deriving (Default, Enum)
data Tempo         = Tempo Rational | TempoChange Rational Rational Rational
data Meter         = Meter UInt UInt deriving (Eq)
data SectionLength = Beats UInt | Bars Meter UInt | SectionTime Rational | HoldUntil Bool | HoldForever deriving (Eq)
data ScoreBeat     = ScoreBeat# UInt Rational Rational UInt -- Beat Number, Beat Start Time, Beat End Time, Beat Section Index
data Section s     = Section SectionLength s Tempo
data Score s       = Score ScoreBeat ScoreBeat (Slice (Section s)) -- Start Beat, End Beat, Section Data

instance Eq Alphabet where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

instance Eq SectionType where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

instance Default Meter where
  default = Meter 4 4

class (Eq s, Default s) => ScoreType s where
  score :: Score s

sectionLength :: Section s -> SectionLength
sectionLength (Section l _ _) = l

sectionSection :: Section s -> s
sectionSection (Section _ s _) = s

sectionTempo :: Section s -> Tempo
sectionTempo (Section _ _ t) = t

scoreBeatInit :: Array n (Section s) -> UInt -> ScoreBeat
scoreBeatInit sectionArray initialSection =
  ScoreBeat# 0 0 (calculateNextBeatEndTime 0 tempo) initialSection
  where
    tempo = readArrayClamped initialSection sectionArray |> sectionTempo

scoreBeatStartTime :: ScoreBeat -> Rational
scoreBeatStartTime (ScoreBeat# _ startTime _ _) =
  startTime

scoreBeatEndTime :: ScoreBeat -> Rational
scoreBeatEndTime (ScoreBeat# _ _ endTime _) =
  endTime

scoreBeatSectionIndex :: ScoreBeat -> UInt
scoreBeatSectionIndex (ScoreBeat# _ _ _ section) =
  section

scoreBeatSection :: Slice (Section s) -> ScoreBeat -> Section s
scoreBeatSection sectionSlice scoreBeat =
  sliceReadClamped (scoreBeatSectionIndex scoreBeat) sectionSlice

isNextSection :: SectionLength -> UInt -> Rational -> Bool
isNextSection sectionLength beatNumber beatStartTime =
  case sectionLength of
    Beats numBeats ->
      beatNumber >= numBeats
    Bars (Meter numBeats beatLength) numBars ->
      beatNumber >= numBeats * numBars
    SectionTime sectionTime ->
      beatStartTime >= sectionTime
    HoldUntil condition ->
      condition
    HoldForever ->
      False

-- TODO: name shadow warning / error?
-- TODO: Handle tempo curves!
calculateNextBeatEndTime :: Rational -> Tempo -> Rational
calculateNextBeatEndTime beatStartTime tempo =
  case tempo of
    Tempo tempoBpm ->
      beatStartTime + (60 / tempoBpm)
    TempoChange tempoStart tempoEnd tempoCurve ->
      beatStartTime + (60 / tempoStart)

calculateNextBeat :: Slice (Section s) -> ScoreBeat -> ScoreBeat
calculateNextBeat sectionSlice (ScoreBeat# prevBeatNumber prevBeatStartTime prevBeatEndTime prevSectionIndex) =
  if isNextSection sLength beatNumber beatStartTime then
    let
      nextSectionIndex = min (prevSectionIndex + 1) (sliceLength sectionSlice - 1)
      nextTempo        = sliceReadClamped nextSectionIndex sectionSlice |> sectionTempo
    in
      ScoreBeat# 0 beatStartTime (calculateNextBeatEndTime beatStartTime nextTempo) nextSectionIndex
  else
    ScoreBeat# beatNumber beatStartTime (calculateNextBeatEndTime beatStartTime sTempo) prevSectionIndex
  where
    Section sLength _ sTempo = sliceReadClamped prevSectionIndex sectionSlice
    beatNumber               = prevBeatNumber + 1
    beatStartTime            = prevBeatEndTime

scoreBeatStartAndEndTick :: Slice (Section s) -> ScoreBeat -> (#ScoreBeat, ScoreBeat#)
scoreBeatStartAndEndTick sectionSlice prevEndBeat =
  (#newStartBeat, newEndBeat#)
  where
    newStartBeat =
      loop startBeat = prevEndBeat while scoreBeatEndTime startBeat <= currBlockTime do
        calculateNextBeat sectionSlice startBeat
    newEndBeat =
      loop endBeat = newStartBeat while scoreBeatEndTime endBeat < nextBlockTime do
        calculateNextBeat sectionSlice endBeat

scoreNewAt :: UInt -> Array n (Section s) -> Score s
scoreNewAt startingSection sectionArray =
  case unwrapOrPanic "scoreNewAt" tickBeats of
    (#startBeat, endBeat#) -> Score startBeat endBeat sectionSlice
  where
    sectionSlice        = toSlice sectionArray
    tickBeats ~ Nothing =
      Just <| scoreBeatStartAndEndTick sectionSlice <|
      case tickBeats of
        Just (#_, endBeat#) -> endBeat
        Nothing             -> scoreBeatInit sectionArray startingSection

scoreNew :: Array n (Section s) -> Score s
scoreNew sectionArray =
  scoreNewAt 0 sectionArray

scoreGetNextBeat :: Score s -> ScoreBeat
scoreGetNextBeat (Score startBeat endBeat sectionSlice) =
  if currBlockTime <= scoreBeatStartTime startBeat then
    startBeat
  else
    calculateNextBeat sectionSlice startBeat

scoreGetSectionDataWithOffset :: Score s -> Rational -> Section s
scoreGetSectionDataWithOffset (Score startBeat endBeat sectionSlice) offset =
  if currBlockTime + offset < scoreBeatEndTime startBeat then
    scoreBeatSection sectionSlice startBeat
  else
    scoreBeatSection sectionSlice endBeat

-- TODO: Handle tempo change
scoreGetTempoWithOffset :: Score s -> Rational -> Rational
scoreGetTempoWithOffset s offset =
  case sectionTempo (scoreGetSectionDataWithOffset s offset) of
    Tempo       tempoInBpm     -> 60 / tempoInBpm
    TempoChange startTempo _ _ -> 60 / startTempo

scoreSectionWithOffset  :: Score s -> Rational -> s
scoreSectionWithOffset s offset =
  sectionSection (scoreGetSectionDataWithOffset s offset)

scoreSection :: ScoreType s => Seq s
scoreSection =
  Seq (\p -> pure (scoreSectionWithOffset score (seqParamGetTimeOffset p)))

-- TODO: gcd optimization

-- playDuringSection :: (AudioFormat f, ScoreType s) => Score s -> s -> (() -> f Audio) -> f Audio
-- playDuringSection score sectionToPlayAt playFunction =
--   if scoreSection score == sectionToPlayAt then
--     playFunction ()
--   else
--     pure (BlockRate 0)

-- data DefaultScore = DefaultScore
-- instance ScoreType DefaultScore where
--   score = scoreNew {Section HoldForever DefaultScore (Tempo 60)}

----------------------
-- Play
----------------------

data PlayControl = Play | Stop | FadeIn Float Float | FadeOut Float Float | NoChange
data PlayState   = PlayState# Bool Float Float Float

playStateTick :: PlayState -> PlayState
playStateTick (PlayState# isPlaying amplitude fadeRate fadeCurve) =
  if not isPlaying then
    PlayState# False 0 0 0
  else
    let
      amplitude' = min 1 (amplitude + audioBlockDeltaF * fadeRate)
    in
      if fadeRate <= 0 && amplitude' <= 0 then
        PlayState# False 0 0 0
      else
        PlayState# True amplitude' fadeRate fadeCurve

-- TODO: interpolated fade!
-- NOTE: Currently only block accurate!!!
-- TODO: Sub block timing!
play :: (ScoreType s, Floating a) => (s -> PlayControl) -> (() -> a) -> a
play s f =
  case state of
    PlayState# True amplitude _ _ -> f () * fromFloat amplitude
    _                             -> 0
  where
    state ~ PlayState# False 0 0 0 =
      playStateTick <|
      case s (scoreSectionWithOffset score 0) of
        Play                       -> PlayState# True  1 0 0
        Stop                       -> PlayState# False 0 0 0
        NoChange                   -> state
        FadeIn  fadeTime fadeCurve ->
          case state of
            PlayState# _ a _ _ ->
              PlayState# True a (1 / fadeTime) fadeCurve
        FadeOut fadeTime fadeCurve ->
          case state of
            PlayState# _ a _ _ ->
              PlayState# True a (-1 / fadeTime) fadeCurve

--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
-- data SeqValue a = SeqValue# Rational SeqControl (Maybe a)
data SeqValue a = SeqValue# Rational SeqControl (Maybe a)
data SeqParam   = SeqParam# Rational -- Block Time Offset
data Seq a      = Seq (SeqParam -> SeqValue a)

getSeqParamAtExactTime :: Rational -> SeqParam
getSeqParamAtExactTime time =
  SeqParam# time

seqParamGetTimeOffset :: SeqParam -> Rational
seqParamGetTimeOffset (SeqParam# timeOffset) =
  timeOffset

instance Default SeqParam where
  default = SeqParam# 0

seqTime :: Seq Rational
seqTime =
  Seq (\p -> pure (currBlockTime + seqParamGetTimeOffset p))

mergeSeqValueTimes :: Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes xt xc yt yc =
  case xc of
    SeqPure -> yt
    _ ->
      case yc of
        SeqPure -> xt
        _       -> min xt yt

mergeSeqValueTimes3 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes3 xt xc yt yc zt zc =
  case xc of
    SeqPure -> mergeSeqValueTimes yt yc zt zc
    _ ->
      case yc of
        SeqPure -> mergeSeqValueTimes xt xc zt zc
        _       ->
          case zc of
            SeqPure -> mergeSeqValueTimes xt xc yt yc
            _       -> min (min xt yt) zt

mergeSeqValueTimes4 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes4 wt wc xt xc yt yc zt zc =
  case wc of
    SeqPure -> mergeSeqValueTimes3 xt xc yt yc zt zc
    _       ->
      case xc of
        SeqPure -> mergeSeqValueTimes3 wt wc yt yc zt zc
        _ ->
          case yc of
            SeqPure -> mergeSeqValueTimes3 wt wc xt xc zt zc
            _       ->
              case zc of
                SeqPure -> mergeSeqValueTimes3 wt wc xt xc yt yc
                _       -> min (min (min wt xt) yt) zt

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

instance Eq SeqControl where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

seqControlFromEnumAlt :: SeqControl -> Int
seqControlFromEnumAlt s =
  case s of
    SeqNormal   -> 0
    SeqLoopEnd  -> 1
    SeqPure     -> 2
    SeqBlockEnd -> 3
    SeqEnd      -> 4

seqControlAlternative :: SeqControl -> SeqControl -> SeqControl
seqControlAlternative x y =
  if lt (seqControlFromEnumAlt x) (seqControlFromEnumAlt y) then
    x
  else
    y

instance Functor SeqValue where
  map f (SeqValue# t c x) =
    SeqValue# t c (map f x)

instance FunctorN SeqValue where
  map2 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (xc <> yc) (map2 f xv yv)
  map3 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes3 xt xc yt yc zt zc) (xc <> yc <> zc) (map3 f xv yv zv)
  map4 f (SeqValue# wt wc wv) (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes4 wt wc xt xc yt yc zt zc) (wc <> xc <> yc <> zc) (map4 f wv xv yv zv)

instance Applicative SeqValue where
  pure x = SeqValue# 1 SeqPure (Just x)
  ap (SeqValue# ft fc fv) (SeqValue# xt xc xv) =
    SeqValue# (mergeSeqValueTimes xt xc ft fc) (fc <> xc) (ap fv xv)

instance Semigroup a => Semigroup (SeqValue a) where
  append (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (append xc yc) (append xv yv)

instance Monoid (SeqValue a) where
  mempty = SeqValue# 1 SeqPure nothing

instance Alternative SeqValue where
  empty = SeqValue# 1 SeqEnd nothing
  alternative (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (seqControlAlternative xc yc) (alternative xv yv)

instance Default (SeqValue a) where
  default = SeqValue# 1 SeqPure nothing

instance Eq a => Eq (SeqValue a) where
  eq  (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt == yt && xc == tc && xv == yv
  neq (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt /= yt || xc /= tc || xv /= yv

instance Semiring a => Semiring (SeqValue a) where
  zero    = SeqValue# 1 SeqPure (Just zero)
  one     = SeqValue# 1 SeqPure (Just one)
  add x y = map2 add x y
  mul x y = map2 mul x y

instance Ring a => Ring (SeqValue a) where
  sub x y   = map2 sub x y
  fromInt i = SeqValue# 1 SeqPure (Just (fromInt i))

instance EuclideanRing a => EuclideanRing (SeqValue a) where
  div x y = map2 div x y
  rem x y = map2 rem x y

instance DivisionRing a => DivisionRing (SeqValue a) where
  recip x = map recip x

instance Num a => Num (SeqValue a) where
  signum x  = map signum x
  abs x     = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (SeqValue a) where

instance Floating a => Floating (SeqValue a) where
  fromFloat f = SeqValue# 1 SeqPure (Just (fromFloat f))
  sqrt f      = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x

runSeq :: Seq a -> SeqParam -> SeqValue a
runSeq (Seq stepFunc) p =
  stepFunc p

runSeq2 :: Seq a -> Seq b -> SeqParam -> (#SeqValue a, SeqValue b#)
runSeq2 sx sy p =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv#) ->
          let
            t = min xt yt
            x = if xt <= t then runSeq sx p else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy p else SeqValue# (yt - t) yc yv
          in
            (#x, y#)

runSeq3 :: Seq a -> Seq b -> Seq c -> SeqParam -> (#SeqValue a, SeqValue b, SeqValue c#)
runSeq3 sx sy sz p =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min xt yt) zt
            x = if xt <= t then runSeq sx p else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy p else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz p else SeqValue# (zt - t) zc zv
          in
            (#x, y, z#)

runSeq4 :: Seq a -> Seq b -> Seq c -> Seq d -> SeqParam -> (#SeqValue a, SeqValue b, SeqValue c, SeqValue d#)
runSeq4 sw sx sy sz p =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# wt wc wv, SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min (min wt xt) yt) zt
            w = if wt <= t then runSeq sw p else SeqValue# (wt - t) wc wv
            x = if xt <= t then runSeq sx p else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy p else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz p else SeqValue# (zt - t) zc zv
          in
            (#w, x, y, z#)

seqValueDuration :: SeqValue a -> Rational
seqValueDuration (SeqValue# t _ _) = t

seqValueControl :: SeqValue a -> SeqControl
seqValueControl (SeqValue# _ c _) = c

seqValueValue :: SeqValue a -> Maybe a
seqValueValue (SeqValue# _ _ v) = v

runSeqOnLeft :: Seq a -> Seq b -> SeqParam -> (#SeqValue a, SeqValue b#)
runSeqOnLeft ls rs p =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc _, SeqValue# rt rc rv#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls p else SeqValue# (lt - t) lc nothing
            r = if rt <= t then runSeq rs p else SeqValue# (rt - t) rc rv
          in
            (#l, r#)

runSeqOnRight :: Seq a -> Seq b -> SeqParam -> (#SeqValue a, SeqValue b#)
runSeqOnRight ls rs p =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc lv, SeqValue# rt rc _#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls p else SeqValue# (lt - t) lc lv
            r = if rt <= t then runSeq rs p else SeqValue# (rt - t) rc nothing
          in
          (#l, r#)

instance Functor Seq where
  map f s = Seq (\p -> map f (runSeq s p))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\p -> ap (runSeq fs p) (runSeq xs p))

instance FunctorN Seq where
  map2 f sx sy       = Seq (\p -> let (#x, y#)       = runSeq2 sx sy p       in map2 f x y)
  map3 f sx sy sz    = Seq (\p -> let (#x, y, z#)    = runSeq3 sx sy sz p    in map3 f x y z)
  map4 f sw sx sy sz = Seq (\p -> let (#w, x, y, z#) = runSeq4 sw sx sy sz p in map4 f w x y z)

instance Monad Seq where
  bind aSeq f =
    Seq go
    where
      go p =
        let
          SeqValue# at ac av = runSeq aSeq p
        in
          case av of
            Nothing -> SeqValue# at ac nothing
            Just a  ->
              let
                SeqValue# bt bc bv = runSeq (f a) p
              in
                SeqValue# (mergeSeqValueTimes at ac bt bc) (ac <> bc) bv

-- instance Eq a => Eq (Seq a) where
--   eq  sx sy = let (#x, y#) = runSeq2 sx sy in x == y
--   neq sx sy = let (#x, y#) = runSeq2 sx sy in x == y

instance Semiring a => Semiring (Seq a) where
  zero      = Seq (\_ -> pure zero)
  one       = Seq (\_ -> pure one)
  add sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in map2 add x y)
  mul sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in map2 mul x y)

instance Ring a => Ring (Seq a) where
  sub sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in map2 sub x y)
  fromInt i = Seq (\_ -> pure (fromInt i))

instance EuclideanRing a => EuclideanRing (Seq a) where
  div sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in map2 div x y)
  rem sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in map2 rem x y)

instance DivisionRing a => DivisionRing (Seq a) where
  recip x = Seq (\p -> map recip (runSeq x p))

instance Num a => Num (Seq a) where
  signum x        = map signum x
  abs x           = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (Seq a) where

instance Floating a => Floating (Seq a) where
  fromFloat f = Seq (\_ -> pure (fromFloat f))
  sqrt      f = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x

instance Semigroup (Seq a) where
  append sx sy = [sx sy]

instance Monoid (Seq a) where
  mempty = Seq (\_ -> SeqValue# 1 SeqPure nothing)

instance Alternative Seq where
  empty             = Seq (\_ -> SeqValue# 1 SeqPure nothing)
  alternative sx sy = Seq (\p -> let (#x, y#) = runSeq2 sx sy p in alternative x y)

-- TODO: <|>

-- Biased BinOps
-- +@  @+  +
-- -@  @-  -
-- *@  @*  *
-- /@  @/  /
-- <@  @< @<@
-- >@  @> @>@

-- TODO:
-- %@ @%

leftConst :: a -> b -> a
leftConst x _ = x

rightConst :: a -> b -> b
rightConst _ y = y

addSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
addSeqOnLeft ls rs = Seq (\p -> let (#l, r#) = runSeqOnLeft ls rs p in map2 add l r)

addSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
addSeqOnRight ls rs = Seq (\p -> let (#l, r#) = runSeqOnRight ls rs p in map2 add l r)

subSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
subSeqOnLeft ls rs = Seq (\p -> let (#l, r#) = runSeqOnLeft ls rs p in map2 sub l r)

subSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
subSeqOnRight ls rs = Seq (\p -> let (#l, r#) = runSeqOnRight ls rs p in map2 sub l r)

mulSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnLeft ls rs = Seq (\p -> let (#l, r#) = runSeqOnLeft ls rs p in map2 mul l r)

mulSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnRight ls rs = Seq (\p -> let (#l, r#) = runSeqOnRight ls rs p in map2 mul l r)

divSeqOnLeft :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnLeft ls rs = Seq (\p -> let (#l, r#) = runSeqOnLeft ls rs p in map2 div l r)

divSeqOnRight :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnRight ls rs = Seq (\p -> let (#l, r#) = runSeqOnRight ls rs p in map2 div l r)

leftConstSeqOnLeft :: Seq a -> Seq b -> Seq a
leftConstSeqOnLeft ls _ = ls

leftConstSeqOnRight :: Seq a -> Seq b -> Seq a
leftConstSeqOnRight ls rs = Seq (\p -> let (#l, r#) = runSeqOnRight ls rs p in map2 leftConst l r)

rightConstSeqOnLeft :: Seq a -> Seq b -> Seq b
rightConstSeqOnLeft ls rs = Seq (\p -> let (#l, r#) = runSeqOnLeft ls rs p in map2 rightConst l r)

rightConstSeqOnRight :: Seq a -> Seq b -> Seq b
rightConstSeqOnRight _ rs = rs

leftConstSeqOnBoth :: Seq a -> Seq b -> Seq a
leftConstSeqOnBoth ls rs = Seq (\p -> let (#l, r#) = runSeq2 ls rs p in map2 leftConst l r)

rightConstSeqOnBoth :: Seq a -> Seq b -> Seq b
rightConstSeqOnBoth ls rs = Seq (\p -> let (#l, r#) = runSeq2 ls rs p in map2 rightConst l r)


-- addSeqOnLeftTest :: Seq Int
-- addSeqOnLeftTest =
--   [1 _ <2 3>] @+ [4 <5 6> <7 8 9>] *@ [1 2 _ 5] @- <3 4 5> @> fromInt mouseX

-- mouseBeat :: Seq Float
-- mouseBeat = fromInt mouseX <@ coolBeat

-- addSeqOnRightTest :: SeqValue Int
-- addSeqOnRightTest = runSeq (rightConstSeqOnLeft 1 2) ()

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue# 1 SeqPure nothing

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

restDuring :: Seq a -> Seq a
restDuring s = Seq go
  where
    go p =
      case runSeq s p of
        SeqValue# dur con _ ->
          SeqValue# dur con nothing

-- TODO: restFor

seqValueDurationMul :: Rational -> SeqValue a -> SeqValue a
seqValueDurationMul speed (SeqValue# t c v) =
  SeqValue# (t * speed) c v

seqSpeed :: Rational -> Seq a -> Seq a
seqSpeed speed seq =
  Seq (\p -> seqValueDurationMul (recip speed) (runSeq seq p))

bpm :: Int -> Rational
bpm tempoInBPM =
  tempoInBPM // 60

toSeq :: SeqValue a -> Seq a
toSeq sv =
  Seq (\_ -> sv)

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  if (slot + 1) < maxSlot then
    SeqNormal
  else
    SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue# t c v ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#(slot + 1) % maxSlot, SeqValue# t controlIfNotNormal v#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (seqValueDurationMul (1 // maxSlot) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqLoopEnd sv

-- TODO: Make repetitions parameter a Seq value
seqRepeat :: UInt -> Seq a -> Seq a
seqRepeat repetitions s =
  Seq go
  where
    go p =
      case runSeq s p of
        SeqValue# dur control value ->
          case control of
            SeqLoopEnd ->
              let
                currentRepetition ~ 0 = if repetitions == 0 then 0 else (currentRepetition + 1) % repetitions
              in
                if currentRepetition == 0 then
                  SeqValue# dur SeqLoopEnd value
                else
                  SeqValue# dur SeqNormal value
            _  -> SeqValue# dur control value

seqControlAllNormalButEnd :: SeqValue a -> SeqValue a
seqControlAllNormalButEnd (SeqValue# dur control value) =
  case control of
    SeqEnd -> SeqValue# dur control value
    _      -> SeqValue# dur SeqNormal value

-- TODO: Make repetitions parameter a Seq value
seqStutter :: UInt -> Seq a -> Seq a
seqStutter repetitions s =
  Seq go
  where
    go p =
      snd3' acc
      where
        acc ~ (#1, SeqValue# 0 SeqNormal Nothing, SeqNormal#) =
          case acc of
            (#i, SeqValue# dur control value, prevControl#) ->
              if i == 0 || repetitions <= 1 then
                case runSeq s p of
                  SeqValue# dur' control' value' ->
                    if repetitions <= 1 then
                      (#0, SeqValue# dur' control' value', control'#)
                    else
                      (#i + 1, seqControlAllNormalButEnd (SeqValue# dur' control' value'), control'#)
              else if i < (repetitions - 1) then
                (#i + 1, SeqValue# dur control value, prevControl#)
              else
                case prevControl of
                  SeqPure -> (#0, SeqValue# dur SeqLoopEnd value, prevControl#)
                  _       -> (#0, SeqValue# dur prevControl value, prevControl#)

seqSeries :: Int -> Int -> Seq Int
seqSeries start step =
  Seq go
  where
    go _ = SeqValue# 1 SeqPure n
      where
        n ~ Nothing =
          case n of
            Nothing -> Just start
            Just v -> Just <| v + step

endAtLoop :: Seq a -> Seq a
endAtLoop s = Seq go
  where
    go p =
      value
      where
        value ~ SeqValue# 0 SeqNormal Nothing =
          case value of
            SeqValue# d c v ->
              case c of
                SeqEnd     -> SeqValue# maxRational SeqEnd nothing
                SeqLoopEnd -> SeqValue# maxRational SeqEnd nothing
                SeqPure    -> SeqValue# maxRational SeqEnd nothing
                _          -> runSeq s p

-- TODO: seqShift / seqDelay

----------------------
-- MIDI
----------------------

------------------------------------------------------------------------------
------------------------------------------------------------------------------
-- MIDI Internals

-- Runtime C Function
-- getMIDIMessageBuffer :: () -> Ptr UInt
-- getMIDIMessageBuffer = primUndefined

-- Runtime C Function
-- getMIDIMessageBufferSize :: () -> UInt
-- getMIDIMessageBufferSize = primUndefined

-- Message buffer has a stride of 2, where a message is a pair of uints in the sequence { Message, TimeStamp }
primMIDIMessageBuffer :: Ptr UInt
primMIDIMessageBuffer = getMIDIMessageBuffer ()

primMIDIMessageBufferSize :: UInt
primMIDIMessageBufferSize = getMIDIMessageBufferSize ()

primMIDIMessageSlice :: Slice UInt
primMIDIMessageSlice =
  Slice# primMIDIMessageBuffer primMIDIMessageBufferSize

primMIDIMessageTypeMask :: UInt
primMIDIMessageTypeMask = bitAnd 255 (bitNot 15)

primMIDIMessageType :: UInt -> UInt
primMIDIMessageType rawMessage = bitShiftRight (bitAnd rawMessage primMIDIMessageTypeMask) 4

primMIDIMessageChannel :: UInt -> UInt
primMIDIMessageChannel rawMessage = bitAnd rawMessage 15

primMIDIMessageData1 :: UInt -> UInt
primMIDIMessageData1 rawMessage = bitShiftRight (bitAnd rawMessage (bitShiftLeft 255 8)) 8

primMIDIMessageData2 :: UInt -> UInt
primMIDIMessageData2 rawMessage = bitShiftRight (bitAnd rawMessage (bitShiftLeft 255 16)) 16

primMIDINoteOffType :: UInt
primMIDINoteOffType = 8

primMIDINoteOnType :: UInt
primMIDINoteOnType = 9

primMIDIControlType :: UInt
primMIDIControlType = 11

primMkMIDIArray :: UInt -> MIDI_Message
primMkMIDIArray i =
  if i < midiMessageBufferSize then
    let
      j = i * 2
      rawMessage = unsafePtrPeek j primMIDIMessageBuffer
      rawTimeStamp = unsafePtrPeek (j + 1) primMIDIMessageBuffer
      messageType = primMIDIMessageType rawMessage
      -- channels are encode in messages as 0-15, but the spec denotes them as 1-16
      midiChannel = primMIDIMessageChannel rawMessage + 1
      midiMessage = -- case (primMIDIMessageType rawMessage) of
        if messageType == primMIDINoteOffType then
          MIDI_NoteOff
            (MIDI_Channel midiChannel)
            (MIDI_Note (primMIDIMessageData1 rawMessage))
            (MIDI_Velocity (primMIDIMessageData2 rawMessage))
            (MIDI_TimeStamp rawTimeStamp)
        else if messageType == primMIDINoteOnType then
          MIDI_NoteOn
            (MIDI_Channel midiChannel)
            (MIDI_Note (primMIDIMessageData1 rawMessage))
            (MIDI_Velocity (primMIDIMessageData2 rawMessage))
            (MIDI_TimeStamp rawTimeStamp)
        else if messageType == primMIDIControlType then
          MIDI_Control
            (MIDI_Channel midiChannel)
            (MIDI_ControlNumber (primMIDIMessageData1 rawMessage))
            (MIDI_ControlValue (primMIDIMessageData2 rawMessage))
            (MIDI_TimeStamp rawTimeStamp)
        else MIDI_Undefined
    in
      midiMessage
  else
    MIDI_Undefined

primMIDIMessageArray :: Array 256 MIDI_Message -- KEEP THIS IN SYNC WITH RT_MIDI_MESSAGE_BUFFER_SIZE IN RUNTIME.C!!!
primMIDIMessageArray =
  mkArray primMkMIDIArray

-- ~MIDI Internals
------------------------------------------------------------------------------
------------------------------------------------------------------------------

midiMessageBufferSize :: UInt
midiMessageBufferSize = primMIDIMessageBufferSize / 2

midiMessageBuffer :: Slice MIDI_Message
midiMessageBuffer =
  subSlice primMIDIMessageArray midiMessageBufferSize

dumpMIDIBuffer :: *World -> *World
dumpMIDIBuffer w =
  if sliceLength midiMessageBuffer > 0
    then
      printLn midiMessageBuffer w
    else
      w

dumpRawMIDIBuffer :: *World -> *World
dumpRawMIDIBuffer w =
    (loop (#w', i#) = (#w, 0#) while i < primMIDIMessageBufferSize do
      (#
        print "{ Necro :: Message: " w'
          |> print (unsafePtrPeek i primMIDIMessageBuffer)
          |> print ", TimeStamp: "
          |> print (unsafePtrPeek (i + 1) primMIDIMessageBuffer)
          |> printLn " }",
        i + 2
      #)
    )
    |> fst'
    -- |> \w'' ->
    --   if primMIDIMessageBufferSize > 0
    --     then print "MIDI Message buffer size: " w'' |> printLn primMIDIMessageBufferSize
    --     else w''

data MIDI_Channel = MIDI_Channel UInt
data MIDI_Note = MIDI_Note UInt
data MIDI_Velocity = MIDI_Velocity UInt
data MIDI_TimeStamp = MIDI_TimeStamp UInt
data MIDI_ControlNumber = MIDI_ControlNumber UInt
data MIDI_ControlValue = MIDI_ControlValue UInt

data MIDI_Message =
  MIDI_NoteOn  MIDI_Channel MIDI_Note MIDI_Velocity MIDI_TimeStamp |
  MIDI_NoteOff MIDI_Channel MIDI_Note MIDI_Velocity MIDI_TimeStamp |
  MIDI_Control MIDI_Channel MIDI_ControlNumber MIDI_ControlValue MIDI_TimeStamp |
  MIDI_Undefined -- Used to represent unhandled or not properly bound messages types

instance Eq MIDI_Channel where
  eq  (MIDI_Channel x) (MIDI_Channel y) = x == y
  neq (MIDI_Channel x) (MIDI_Channel y) = x /= y

instance Eq MIDI_Note where
  eq  (MIDI_Note x) (MIDI_Note y) = x == y
  neq (MIDI_Note x) (MIDI_Note y) = x /= y

instance Eq MIDI_Velocity where
  eq  (MIDI_Velocity x) (MIDI_Velocity y) = x == y
  neq (MIDI_Velocity x) (MIDI_Velocity y) = x /= y

instance Eq MIDI_TimeStamp where
  eq  (MIDI_TimeStamp x) (MIDI_TimeStamp y) = x == y
  neq (MIDI_TimeStamp x) (MIDI_TimeStamp y) = x /= y

instance Eq MIDI_ControlNumber where
  eq  (MIDI_ControlNumber x) (MIDI_ControlNumber y) = x == y
  neq (MIDI_ControlNumber x) (MIDI_ControlNumber y) = x /= y

instance Eq MIDI_ControlValue where
  eq  (MIDI_ControlValue x) (MIDI_ControlValue y) = x == y
  neq (MIDI_ControlValue x) (MIDI_ControlValue y) = x /= y

instance Eq MIDI_Message where
  eq x y =
    case x of
      (MIDI_NoteOn cx nx vx tx) ->
        case y of
          (MIDI_NoteOn cy ny vy ty) -> cx == cy && nx == ny && vx == vy && tx == ty
          _ -> False
      (MIDI_NoteOff cx nx vx tx) ->
        case y of
          (MIDI_NoteOff cy ny vy ty) -> cx == cy && nx == ny && vx == vy && tx == ty
          _ -> False
      (MIDI_Control cx nx vx tx) ->
        case y of
          (MIDI_Control cy ny vy ty) -> cx == cy && nx == ny && vx == vy && tx == ty
          _ -> False
      MIDI_Undefined ->
        case y of
          MIDI_Undefined -> True
          _ -> False
  neq x y = not <| x == y

instance Default MIDI_Message where
  default = MIDI_Undefined

deepCopyMIDIMessage :: MIDI_Message -> MIDI_Message
deepCopyMIDIMessage message =
  case message of
    (MIDI_NoteOn (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)) ->
      MIDI_NoteOn (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)
    (MIDI_NoteOff (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)) ->
      MIDI_NoteOff (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)
    (MIDI_Control (MIDI_Channel channel) (MIDI_ControlNumber num) (MIDI_ControlValue val) (MIDI_TimeStamp timeStamp)) ->
      MIDI_Control (MIDI_Channel channel) (MIDI_ControlNumber num) (MIDI_ControlValue val) (MIDI_TimeStamp timeStamp)
    MIDI_Undefined -> MIDI_Undefined

middleC_MIDINote :: UInt
middleC_MIDINote = 60

midiToFrequency :: Scale t d -> MIDI_Message -> Maybe Float
midiToFrequency scale midiMessage =
  case midiMessage of
    MIDI_NoteOn _ (MIDI_Note note) _ _ -> Just <| d2f scale (fromUInt note - fromUInt middleC_MIDINote)
    _ -> Nothing

m2f :: Scale t d -> MIDI_Message -> Maybe Float
m2f = midiToFrequency

midiNoteToDegree :: UInt -> Int
midiNoteToDegree m = fromUInt m - 60

m2d :: UInt -> Int
m2d = midiNoteToDegree

-- most recent MIDI Note On, if any, otherwise Nothing
midiNoteOnMessages :: Maybe MIDI_Message
midiNoteOnMessages =
  foldl f Nothing midiMessageBuffer
  where
    f acc message =
      case message of
        (MIDI_NoteOn _ _ _ _) -> Just message
        _ -> acc

midiNoteOnOffMessages :: MIDI_Message
midiNoteOnOffMessages =
  foldl f MIDI_Undefined midiMessageBuffer
  where
    f acc message =
      case message of
        (MIDI_NoteOn _ _ _ _) -> message
        (MIDI_NoteOff _ _ _ _) -> message
        _ -> acc

numMIDIKeys :: UInt
numMIDIKeys = 127

-- TODO: change to bitfield?
-- How to implement large bitfield?
-- As array of UInts? --> With Ptr poke/peek semantics with offsets?

midiKeysState :: Array 127 Bool
midiKeysState ~ arrayFrom False =
  (loop (#midiKeysState', i#) = (#deepCopyArray midiKeysState, 0#) while i < midiMessageBufferSize do
    let
      message = sliceReadClamped i midiMessageBuffer
      midiKeysState'' =
        case message of
          MIDI_NoteOn _ (MIDI_Note note) _ _ ->
            writeArray (unsafeUIntToIndex note) True midiKeysState'
          MIDI_NoteOff _ (MIDI_Note note) _ _ ->
            writeArray (unsafeUIntToIndex note) False midiKeysState'
          _ -> midiKeysState'
    in
      (#midiKeysState'', i + 1#))
  |> fst'
  |> freezeArray

data MIDI_ActiveNotesState = MIDI_ActiveNotesState# (Array 127 UInt) UInt

midiKeysPressed :: Slice UInt
midiKeysPressed =
  case activeNotesState of
    MIDI_ActiveNotesState# activeNotes numActiveNotes ->
      subSlice activeNotes numActiveNotes
  where
    activeNotesState :: MIDI_ActiveNotesState
    activeNotesState ~ MIDI_ActiveNotesState# (arrayFrom 0) 0 =
      case activeNotesState of
        MIDI_ActiveNotesState# activeNotes numActiveNotes ->
          (loop (#activeNotes', numActiveNotes, i, j#) = (#deepCopyArray activeNotes, 0, 0, 0#) while i < numMIDIKeys do
            let
              isActive = readArray (unsafeUIntToIndex i) midiKeysState
              (#activeNotes'', numActiveNotes', j'#) =
                if isActive
                  then (#writeArray (unsafeUIntToIndex j) i activeNotes', numActiveNotes + 1, j + 1#)
                  else (#activeNotes', numActiveNotes, j#)
            in
              (#activeNotes'', numActiveNotes', i + 1, j'#))
          |> \(#activeNotes, numActiveNotes, _, _#) -> MIDI_ActiveNotesState# (freezeArray activeNotes) numActiveNotes

dumpMIDIKeysPressed :: *World -> *World
dumpMIDIKeysPressed w =
  if sliceLength midiKeysPressed > 0 then
    printLn midiKeysPressed w
  else
    w

midiBufferUndefined :: Array 127 UInt
midiBufferUndefined = arrayFrom 0

midiNotes_LastNotePriorityBuffer :: DynArrayFixedCapacity 127 UInt
midiNotes_LastNotePriorityBuffer ~ (mkEmptyDynArrayFixedCapacity (deepCopyArray midiBufferUndefined) 127) =
  (loop (#midiKeyBuffer, i#) = (#dynArrayFixedCapacity_DeepCopy midiNotes_LastNotePriorityBuffer, 0#) while i < midiMessageBufferSize do
    let
      message = sliceReadClamped i midiMessageBuffer
      (#_, midiKeyBuffer'#) =
        case message of
          MIDI_NoteOn _ (MIDI_Note n) _ _ ->
            dynArrayFixedCapacity_PushUnique n midiKeyBuffer
          MIDI_NoteOff _ (MIDI_Note n) _ _ ->
            dynArrayFixedCapacity_EraseUnique n midiKeyBuffer
          _ -> (#True, midiKeyBuffer#)
    in
      (#midiKeyBuffer', i + 1#))
  |> \(#DynArrayFixedCapacity# a capacity size, _#) -> DynArrayFixedCapacity# (freezeArray a) capacity size

-- MIDI_NoteOn messages for the last note played, Nothing if no note active
-- Handles key releases with a FIFO note stack, so if multiple keys pressed and you release a key will revert to the note on the top of the stack
midiNotes_LastNotePriority :: Maybe UInt
midiNotes_LastNotePriority =
  case midiNotes_LastNotePriorityBuffer of
    DynArrayFixedCapacity# a _ size ->
      if size > 0
        then Just (readArray (unsafeUIntToIndex (size - 1)) a)
        else Nothing

midiNotesAndTriggers_LastNotePriority :: AudioFormat f => Maybe (UInt, f Audio)
midiNotesAndTriggers_LastNotePriority =
  case midiNotes_LastNotePriorityBuffer of
    DynArrayFixedCapacity# a _ size ->
      if size > 0 then
        Just
          (
            (readArray (unsafeUIntToIndex (size - 1)) a),
            case midiNoteOnMessages of
              Nothing -> pure <| BlockRate 0
              Just _ -> pure <| singleImpulse
          )
      else
        Nothing

dumpMIDINotes_LastNotePriorityBuffer :: *World -> *World
dumpMIDINotes_LastNotePriorityBuffer w =
  if dynArrayFixedCapacity_Size midiNotes_LastNotePriorityBuffer > 0 then
    printLn midiNotes_LastNotePriorityBuffer w
  else
    w

midiVoiceEvents :: Scale t d -> Slice VoiceEvent
midiVoiceEvents scale =
  dynArrayFixedCapacity_ToSlice voiceEventBuffer
  where
    voiceEventBuffer :: DynArrayFixedCapacity 256 VoiceEvent
    voiceEventBuffer =
      foldl toVoiceEvent (mkEmptyDynArrayFixedCapacity (unsafeEmptyArray ()) 256) primMIDIMessageArray
      |> dynArrayFixedCapacity_Freeze
    toVoiceEvent dyn message =
      case message of
        (MIDI_NoteOn _ (MIDI_Note note) _ (MIDI_TimeStamp timeStamp)) ->
          let
            freq = d2f scale (fromUInt note - 60)
          in
            dynArrayFixedCapacity_PushBack
              (VoiceEvent
                (VoiceID <| uintToInt note)
                VoiceActive
                VoiceTimeStamp_Block
                freq)
              dyn |> snd'
        (MIDI_NoteOff _ (MIDI_Note note) _ (MIDI_TimeStamp timeStamp)) ->
          let
            freq = d2f scale (fromUInt note - 60)
          in
            dynArrayFixedCapacity_PushBack
              (VoiceEvent
                (VoiceID <| uintToInt note)
                VoiceInactive
                VoiceTimeStamp_Block
                freq)
              dyn |> snd'
        (MIDI_Control (MIDI_Channel channel) (MIDI_ControlNumber num) (MIDI_ControlValue val) (MIDI_TimeStamp timeStamp)) ->
          dyn
        MIDI_Undefined -> dyn

-- dumpMIDIVoiceEvents :: *World -> *World
-- dumpMIDIVoiceEvents w =
--   if sliceLength midiVoiceEvents > 0 then
--     printLn midiVoiceEvents w
--   else
--     w

midiMonoTest :: () -> Stereo Audio
midiMonoTest _ =
  saw (afreq |> mixStereo)
    |> mul 0.3
    |> adsr 0.01 0.1 0.5 1 -1 gate
  where
    gate = fromFloat rawFreq
    afreq = fromFloat freq -- |> traceLn2 "freq: "
    rawFreq =
      case midiNotes_LastNotePriority of
        Just note -> d2f chromatic <| m2d note
        _ -> 0
    freq ~ 0 =
      if rawFreq > 0
        then rawFreq
        else freq

midiMonoMultiTriggerTest :: () -> Stereo Audio
midiMonoMultiTriggerTest _ =
  saw (afreq |> mixStereo)
    |> mul 0.3
    |> adsrMultiTrigger 0.01 0.1 0.5 1 -1 gate trigger
  where
    gate = fromFloat rawFreq
    afreq = fromFloat freq -- |> traceLn2 "freq: "
    (rawFreq, trigger) =
      case midiNotesAndTriggers_LastNotePriority of
        Just (note, trigger) -> (d2f chromatic <| m2d note, trigger)
        _ -> (0, 0)
    freq ~ 0 =
      if rawFreq > 0
        then rawFreq
        else freq

polyVoiceBank_MIDITest :: () -> Stereo Audio
polyVoiceBank_MIDITest _ =
  polyVoiceBank numVoices synth envGen <| midiVoiceEvents <| primaxial12 middleC
  where
    numVoices :: NatVal 88
    numVoices = NatVal
    envGen :: Stereo Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    envGen gate trigger audioIn =
      adsr 0.01 0.1 0.5 1 -4 gate audioIn
    synth :: VoiceID -> Mono Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    synth _ freq envVal trigger =
      tri (mixStereo freq) * envVal * 0.05

polyVoiceBank_SeqTest :: () -> Stereo Audio
polyVoiceBank_SeqTest _ =
  polyVoiceBank numVoices synth envGen seqVE
  where
    numVoices :: NatVal 4
    numVoices = NatVal
    envGen :: Stereo Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    envGen gate trigger audioIn =
      adsrMultiTrigger 0.01 0.1 0.75 3 -4 gate trigger audioIn
    synth :: VoiceID -> Mono Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    synth (VoiceID vid) freq envVal trigger =
      (tri (freq |> lag 0.1 |> mixStereo) * envVal * 0.03)
      +
      (tri (freq * 0.5 |> lag 0.1 |> mixStereo) * envVal * 0.03)
      |> pan (fromInt (vid % 4) * 0.25 + 0.125 |> fromFloat) 
    seqVE :: Slice VoiceEvent
    seqVE =
      [ 0 _ <0 0> _ <0 <0 0>> ]
      |> map (\_ -> let n ~ -1 = (n + 1) in n)
      |> map (\id -> (id, 1 // 3, d2f (blackstar middleC) ((id * 6) % (10 * 4)) |> mul 0.5))
      |> seqSpeed (bpm 120)
      |> seqToVoiceEvents

polyVoiceBank_SeqVibeTest :: () -> Stereo Audio
polyVoiceBank_SeqVibeTest _ =
  polyVoiceBank_InfiniteRelease numVoices synth envGen seqVE
  where
    numVoices :: NatVal 40
    numVoices = NatVal
    envGen :: Stereo Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    envGen gate trigger audioIn =
      adsrMultiTrigger 0.01 0.1 0.75 40 -16 gate trigger audioIn
    maxDelayInBlocks :: NatVal 64
    maxDelayInBlocks = NatVal
    synth :: VoiceID -> Mono Audio -> Stereo Audio -> Stereo Audio -> Stereo Audio
    synth (VoiceID vid) freq envVal trigger =
      sin (mixStereo freq) * envVal |> mul (sin 4 * 0.125 + 0.75)
      |> pan (((fromInt vid) / 38.0) + (1 / 38.0) |> fromFloat)
      |> mul (1 / 20)
    seqVE :: Slice VoiceEvent
    seqVE =
      [ 0 _ <0 0> _ <0 <0 0>> ]
      |> map (\_ -> let n ~ -1 = (n + 1) in n)
      |> map (\nID ->
        let
          id = ((nID * 6) % (10 * 4))
        in
          (id, 1 // 3, d2f (blackstar middleC) id |> mul 0.5))
      |> seqSpeed (bpm 120)
      |> seqToVoiceEvents

--------------------
-- Print
--------------------

instance Print Complex where
  print (Complex# r i) w =
    print '(' w
    |> print r
    |> print ' ' |> print '+' |> print ' ' |> print 'i' -- hack for array print dependency :(
    |> print i
    |> print ')'

instance Print a => Print (Array n a) where
  print a w =
    loop w' = w for i <- each do
      print (readArray i a) w'

instance Print Bool where
  print x w =
    case x of
      True -> print "True" w
      _    -> print "False" w

instance Print Rational where
  print (Rational# n d) w =
    print '(' w |> print n |> print " // " |> print d |> print ')'

instance Print a => Print (Maybe a) where
  print mx w =
    case mx of
      Nothing -> print '_' w
      Just x  -> print x w

instance Print a => Print (SeqValue a) where
  print (SeqValue# t _ v) w =
    print '(' w
    |> print t
    |> print ':'
    |> print v
    |> print ')'

printBarOnLoop :: SeqControl -> *World -> *World
printBarOnLoop c w =
  case c of
    SeqLoopEnd -> print '|' w |> print ' ' |> printNewline
    _          -> printNewline w

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + audioBlockDelta
      (#_, _, wout#) =
        loop (#cont, time, w'#) = (#True, 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#False, 0, w'#)
            else
              case runSeq s (getSeqParamAtExactTime nextValueTime) of
                SeqValue# t c mx ->
                  case mx of
                    Just x -> (#True, t, print x w' |> print ' ' |> printBarOnLoop c#)
                    _      -> (#True, t, printBarOnLoop c w'#)

instance Print Audio where
  print c w =
    case c of
      AudioEnd    -> print "AudioEnd" w
      BlockRate x -> print "BlockRate " w |> print x
      AudioRate b ->
        print '}' <| loop w' = (print '{' w) for i <- each do
          print (readArray i b) w' |> print ',' |> print ' '

instance Print a => Print (Mono a) where
  print (Mono c) w = print c w

instance Print a => Print (Stereo a) where
  print (Stereo# l r) w = print l (print ',' (print r w))

instance Print (FFT k) where
  print (FFT c) w =
    print "FFT [" w
    |> printNewline
    |> printNewline
    |> print c
    |> print ']'
    |> printNewline

instance Print ScoreBeat where
  print (ScoreBeat# beatNum beatStartTime beatEndTime beatSectionIndex) w =
    print "(ScoreBeat " w
    |> print beatNum
    |> print ' '
    |> print beatStartTime
    |> print ' '
    |> print beatEndTime
    |> print ' '
    |> print beatSectionIndex
    |> print ')'
    |> printNewline

instance Print EnvState where
  print (EnvState# a b grow time) w =
    print "(EnvState " w
    |> print a |> print " "
    |> print b |> print " "
    |> print grow |> print " "
    |> print time |> print ")"

instance Print ADSRState where
  print adsrState w =
    case adsrState of
      ADSRState_Attack ->
        printLn "ADSRState_Attack" w
      ADSRState_Decay ->
        printLn "ADSRState_Decay" w
      ADSRState_Sustain ->
        printLn "ADSRState_Sustain" w
      ADSRState_Release ->
        printLn "ADSRState_Release" w
      ADSRState_End ->
        printLn "ADSRState_End" w

instance Print ADSRAccumulateState where
  print (ADSRAccumulateState# adsrState envState) w =
    print "(ADSRAccumulateState " w
    |> print adsrState |> print " "
    |> print envState |> print ")"

instance Print MIDI_Message where
  print midiMessage w =
    case midiMessage of
      (MIDI_NoteOn (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)) ->
        print "MIDI_NoteOn { " w
        |> print "(MIDI_Channel " |> print channel |> print ") "
        |> print "(MIDI_Note " |> print note |> print ") "
        |> print "(MIDI_Velocity " |> print vel |> print ") "
        |> print "(MIDI_TimeStamp " |> print timeStamp |> print ") "
        |> printLn "}"
      (MIDI_NoteOff (MIDI_Channel channel) (MIDI_Note note) (MIDI_Velocity vel) (MIDI_TimeStamp timeStamp)) ->
        print "MIDI_NoteOff { " w
        |> print "(MIDI_Channel " |> print channel |> print ") "
        |> print "(MIDI_Note " |> print note |> print ") "
        |> print "(MIDI_Velocity " |> print vel |> print ") "
        |> print "(MIDI_TimeStamp " |> print timeStamp |> print ") "
        |> printLn "}"
      (MIDI_Control (MIDI_Channel channel) (MIDI_ControlNumber num) (MIDI_ControlValue val) (MIDI_TimeStamp timeStamp)) ->
        print "MIDI_Control { " w
        |> print "(MIDI_Channel " |> print channel |> print ") "
        |> print "(MIDI_ControlNumber " |> print num |> print ") "
        |> print "(MIDI_ControlValue " |> print val |> print ") "
        |> print "(MIDI_TimeStamp " |> print timeStamp |> print ") "
        |> printLn "}"
      MIDI_Undefined -> printLn "(MIDI_Undefined)" w
      _ -> printLn "(MIDI_? Print support not implemented!)" w

instance Print a => Print (DynArrayFixedCapacity n a) where
  print (DynArrayFixedCapacity# a capacity size) w =
    (loop (#w', i#) = (#print "(DynArrayFixedCapacity {" w |> print ' ', 0#) while i < size do
      let
        printDelimiter w =
          if i < (size - 1)
            then print ',' w |> print ' '
            else w
      in
        (#print (readArray (unsafeUIntToIndex i) a) w' |> printDelimiter, i + 1#))
    |> fst'
    |> print " } capacity: "
    |> print capacity
    |> print ", size: "
    |> print size
    |> print ')'

instance Print VoiceActivity where
  print voiceActivity w =
    case voiceActivity of
      VoiceInactive -> print "VoiceInactive" w
      VoiceActive -> print "VoiceActive" w

instance Print VoiceEvent where
  print (VoiceEvent (VoiceID vid) voiceActivity ts params) w =
    print "(VoiceEvent (VoiceID " w
    |> print vid
    |> print ") "
    |> print voiceActivity
    |> print " (VoiceTimeStamp "
    |> \w' ->
      case ts of
        VoiceTimeStamp_Rational rt ->
          print "(VoiceTimeStamp_Rational " w'
          |> print rt
          |> print ")"
        VoiceTimeStamp_Block ->
          print "VoiceTimeStamp_Block" w'
        VoiceTimeStamp_StartStop_Rational start stop ->
          print "(VoiceTimeStamp_StartStop_Rational " w'
          |> print start
          |> print " "
          |> print stop
          |> print ")"
    |> print ") "
    |> print params
    |> print")"

instance Print VoiceState where
  print voiceState w =
    case voiceState of
      VoiceStateSustaining -> print "VoiceStateSustaining" w
      VoiceStateReleasing -> print "VoiceStateReleasing" w
      VoiceStateInactive -> print "VoiceStateInactive" w

instance Print PolyVoiceState where
  print (PolyVoiceState# (VoiceID vid) (PolyVoiceStateOrderID oid) voiceState (PolyVoiceLifetime# start end) voiceParams) w =
    print "(PolyVoiceState# (VoiceID " w
    |> print vid
    |> print ") (PolyVoiceStateOrderID "
    |> print oid
    |> print ") "
    |> print voiceState
    |> print " (PolyVoiceStateLifetime "
    |> print start
    |> print " "
    |> print end
    |> print ") "
    |> print voiceParams
    |> print ")"

instance Print (PolyVoiceBank numVoices) where
  print (PolyVoiceBank# a (PolyVoiceBankCapacity c) (PolyVoiceBankNumActive n) (PolyVoiceBankOrderCounter o)) w =
    print "(PolyVoiceBank# " w
    |> print a
    |> print " (PolyVoiceBankCapacity "
    |> print c
    |> print ") (PolyVoiceBankNumActive "
    |> print n
    |> print ") (PolyVoiceBankOrderCounter "
    |> print o
    |> print "))"

-- instance Print Alphabet where
--   print alphabet w =
--     print c w
--     where
--       c :: Char
--       c = fromEnum alphabet |> add 65 |> toEnum

-- foldp :: (b -> a -> b) -> f a -> b

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue# t _ (Just x) -> (#tick, time + t, f acc x#)
--             SeqValue# t _ _        -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- seqTest :: Seq Float
-- -- seqTest :: Seq Int
-- seqTest =
--   [0 _ 1 2] + [<3 4> _ <5 6> <7 8 9>]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- notAnInt :: Seq Float
-- notAnInt = 2 / 3

-- doubleTrouble :: SeqValue Int
-- doubleTrouble =
--   runSeq (2 * <33 44 <0 _ 1 2>>) ()

-- appendSeq :: Seq a -> Seq a -> Seq a
-- appendSeq x y = [x y]

-- appendGo :: SeqValue Rational
-- appendGo = runSeq (appendSeq 1 2) ()

----------------------------
-- RingBuffer
----------------------------

data RingBufferHead = RingBufferHead UInt
data RingBufferTail = RingBufferTail UInt
data RingBufferSize = RingBufferSize UInt
data RingBufferCapacity = RingBufferCapacity UInt
data RingBuffer n a = RingBuffer# .(Array (NatNextPowerOfTwo n) a) RingBufferCapacity RingBufferHead RingBufferTail RingBufferSize 

mkEmptyRingBuffer :: Default a => NatVal n -> .RingBuffer n a
mkEmptyRingBuffer n =
  RingBuffer#
    (arrayFrom default)
    (RingBufferCapacity (nextPowerOfTwoNatVal n |> natVal))
    (RingBufferHead 0)
    (RingBufferTail 0)
    (RingBufferSize 0)

deepCopyRingBuffer :: RingBuffer n a -> *RingBuffer n a
deepCopyRingBuffer (RingBuffer# a c h t s) =
  RingBuffer# (deepCopyArray a) c h t s

freezeRingBuffer :: *RingBuffer n a -> RingBuffer n a
freezeRingBuffer (RingBuffer# a c h t s) =
  RingBuffer# (freezeArray a) c h t s

instance Foldable (RingBuffer n) where
  fold (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) _ (RingBufferSize s)) =
    fst' <|
      loop (#x, i#) = (#mempty, 0#) while i < s  do
        let
          index = bitAnd (h + i) cMask |> unsafeUIntToIndex
        in
          (#x <> readArray index a, i + 1#)
    where
      cMask = c - 1
  foldl f init (RingBuffer# a0 (RingBufferCapacity c) (RingBufferHead h) _ (RingBufferSize s)) =
    result
    where
      cMask = c - 1
      (#result, _, _#) =
        loop (#x, a1, i#) = (#init, a0, 0#) while i < s do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
          in
            case readArrayU index a1 of
              (#y, a2#) ->
                (#f x y, a2, i + 1#)

instance Functor (RingBuffer n) where
  map f (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
    (RingBuffer# (freezeArray a') (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s))
    where
      cMask = c - 1
      (#a', _#) =
        loop (#a', i#) = (#unsafeEmptyArray (), 0#) while i < s do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            a'' = writeArray index (f (readArray index a)) a'
          in
            (#a'', i + 1#)

instance (Print a) => Print (RingBuffer n a) where
  print (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)) w =
    (loop (#w', i#) = (#print "(RingBuffer {" w |> print ' ', 0#) while i < s do
      let
        printDelimiter w =
          if i < (s - 1)
            then print ',' w |> print ' '
            else w
      in
        (#print (readArray (unsafeUIntToIndex i) a) w' |> printDelimiter, i + 1#))
    |> fst'
    |> print " } capacity: "
    |> print c
    |> print ", size: "
    |> print s
    |> print ", head: "
    |> print h
    |> print ", tail: "
    |> print t
    |> print ')'

ringBufferSize :: *RingBuffer n a -> (#UInt, *RingBuffer n a#)
ringBufferSize (RingBuffer# a c h t (RingBufferSize s)) =
  (#s, RingBuffer# a c h t (RingBufferSize s)#)

ringBufferReadIndex :: Index n -> *RingBuffer n a -> (#Maybe a, *RingBuffer n a#)
ringBufferReadIndex (Index n) (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
  if n >= s then
    (#Nothing, RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)#)
  else
    let
      cMask = c - 1
      rIndex = bitAnd (h + n) cMask |> unsafeUIntToIndex
      (#v, readA#) = readArrayU rIndex a
    in
      (#Just v, RingBuffer# readA (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)#)

ringBufferPushBack :: a -> *RingBuffer n a -> (#Bool, *RingBuffer n a#)
ringBufferPushBack v (RingBuffer# a (RingBufferCapacity c) h (RingBufferTail t) (RingBufferSize s)) =
    (#result, RingBuffer# a' (RingBufferCapacity c) h (RingBufferTail t) (RingBufferSize s')#)
    where
      cMask = c - 1
      (#result, t', s', a'#) =
        if s >= c then
          (#False, t, s, a#)
        else
          let
            t' = bitAnd (t + 1) cMask
            index = t' |> unsafeUIntToIndex 
          in
            (#True, t', s + 1, writeArray index v a#)

ringBufferPopBack :: *RingBuffer n a -> (#Maybe a, *RingBuffer n a#)
ringBufferPopBack (RingBuffer# a (RingBufferCapacity c) h (RingBufferTail t) (RingBufferSize s)) =
    (#result, RingBuffer# a' (RingBufferCapacity c) h (RingBufferTail t') (RingBufferSize s')#)
    where
      cMask = c - 1
      (#result, t', s', a'#) =
        if s == 0 then
          (#Nothing, t, s, a#)
        else
          let
            t' = bitAnd (t - 1) cMask
            index = unsafeUIntToIndex t
            (#v, a'#) = readArrayU index a
          in
            (#Just v, t', s - 1, a'#)

ringBufferPushFront :: a -> *RingBuffer n a -> (#Bool, *RingBuffer n a#)
ringBufferPushFront v (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
    (#result, RingBuffer# a' (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s')#)
    where
      cMask = c - 1
      (#result, h', s', a'#) =
        if s >= c then
          (#False, h, s, a#)
        else
          let
            h' = bitAnd (h - 1) cMask
            index = h' |> unsafeUIntToIndex 
          in
            (#True, h', s + 1, writeArray index v a#)

ringBufferPopFront :: *RingBuffer n a -> (#Maybe a, *RingBuffer n a#)
ringBufferPopFront (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
    (#result, RingBuffer# a' (RingBufferCapacity c) (RingBufferHead h') t (RingBufferSize s')#)
    where
      cMask = c - 1
      (#result, h', s', a'#) =
        if s == 0 then
          (#Nothing, h, s, a#)
        else
          let
            h' = bitAnd (h + 1) cMask
            index = unsafeUIntToIndex h
            (#v, a'#) = readArrayU index a
          in
            (#Just v, h', s - 1, a'#)

ringBufferMoveFrontToBack :: *RingBuffer n a -> *RingBuffer n a
ringBufferMoveFrontToBack r =
  case ringBufferPopFront r of
    (#Nothing, r'#) -> r'
    (#Just v, r'#) ->
      case ringBufferPushBack v r' of
        (#_, r''#) -> r''

ringBufferMoveBackToFront :: *RingBuffer n a -> *RingBuffer n a
ringBufferMoveBackToFront r =
  case ringBufferPopBack r of
    (#Nothing, r'#) -> r'
    (#Just v, r'#) ->
      case ringBufferPushFront v r' of
        (#_, r''#) -> r''

ringBufferContainsElement :: Eq a => a -> *RingBuffer n a -> (#Bool, *RingBuffer n a #)
ringBufferContainsElement e (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
  (#found, RingBuffer# a' (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)#)
    where
      cMask = c - 1
      (#found, a', _#) =
        loop (#found, a', i#) = (#False, a, 0#) while (i < s && (not found)) do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            (#e2, a''#) = readArrayU index a'
          in
            (#e == e2, a'', i + 1#)

ringBufferContainsElementIf :: (a -> Bool) -> *RingBuffer n a -> (#Bool, *RingBuffer n a #)
ringBufferContainsElementIf f (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)) =
  (#found, RingBuffer# a' (RingBufferCapacity c) (RingBufferHead h) t (RingBufferSize s)#)
    where
      cMask = c - 1
      (#found, a', _#) =
        loop (#found, a', i#) = (#False, a, 0#) while (i < s && (not found)) do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            (#e, a''#) = readArrayU index a'
          in
            (#f e, a'', i + 1#)

ringBufferEraseElement :: Eq a => a -> *RingBuffer n a -> (#Bool, *RingBuffer n a #)
ringBufferEraseElement e (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)) =
  (#erased, RingBuffer# erasedA (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t') (RingBufferSize s')#)
    where
      cMask = c - 1
      (#found, foundA, afterI#) =
        loop (#found, a', i#) = (#False, a, 0#) while (i < s && (not found)) do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            (#e2, a''#) = readArrayU index a'
          in
            (#e == e2, a'', i + 1#)
      (#erased, erasedA, t', s'#) =
        case found of
          False -> (#False, foundA, t, s#)
          True ->
            (loop (#erasedA, i#) = (#foundA, afterI#) while i < s do
              let
                index = bitAnd (h + i) cMask |> unsafeUIntToIndex
                index0 = bitAnd (h + i - 1) cMask |> unsafeUIntToIndex
                (#v, readA#) = readArrayU index erasedA
                writtenA = writeArray index0 v readA
              in
                (#writtenA, i + 1#))
            |> \(#erasedA, _#) ->
              (#True, erasedA, bitAnd (t - 1) cMask, s - 1#)

ringBufferPushBackUnique:: Eq a => a -> *RingBuffer n a -> (#Bool, *RingBuffer n a#)
ringBufferPushBackUnique e r =
  case ringBufferContainsElement e r of
    (#False, r'#) -> (#False, r'#)
    (#True, r'#) -> ringBufferPushBack e r'

ringBufferPushBackUniqueIf :: (a -> Bool) -> a -> *RingBuffer n a -> (#Bool, *RingBuffer n a#)
ringBufferPushBackUniqueIf f e r =
  case ringBufferContainsElementIf f r of
    (#False, r'#) -> (#False, r'#)
    (#True, r'#) -> ringBufferPushBack e r'

ringBufferMoveElementToBackIf :: (a -> Bool) -> *RingBuffer n a -> (#Bool, *RingBuffer n a #)
ringBufferMoveElementToBackIf f (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)) =
  (#moved, RingBuffer# movedA (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)#)
    where
      cMask = c - 1
      (#maybeE, foundA, afterI#) =
        loop (#maybeE, a', i#) = (#Nothing, a, 0#) while (i < s && (isNothing maybeE)) do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            (#e, a''#) = readArrayU index a'
            maybeE = if f e then Just e else Nothing
          in
            (#maybeE, a'', i + 1#)
      (#moved, movedA#) =
        case maybeE of
          Nothing -> (#False, foundA#)
          Just e ->
            (loop (#movedA, i#) = (#foundA, afterI#) while i < s do
              let
                index = bitAnd (h + i) cMask |> unsafeUIntToIndex
                index0 = bitAnd (h + i - 1) cMask |> unsafeUIntToIndex
                (#v, readA#) = readArrayU index movedA
                writtenA = writeArray index0 v readA
              in
                (#writtenA, i + 1#))
            |> \(#movedA, _#) ->
              (#True, writeArray (unsafeUIntToIndex t) e movedA#)

ringBufferUpdateElementIf :: (a -> Bool) -> (a -> a) -> *RingBuffer n a -> (#Bool, *RingBuffer n a#)
ringBufferUpdateElementIf f u (RingBuffer# a (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)) =
  (#found, RingBuffer# updatedA (RingBufferCapacity c) (RingBufferHead h) (RingBufferTail t) (RingBufferSize s)#)
    where
      cMask = c - 1
      (#found, foundA, afterI#) =
        loop (#found, a', i#) = (#False, a, 0#) while (i < s && (not found)) do
          let
            index = bitAnd (h + i) cMask |> unsafeUIntToIndex
            (#e, a''#) = readArrayU index a'
          in
            (#f e, a'', i + 1#)
      updatedA =
        if found then
          foundA
        else
          let
            index = bitAnd (h + afterI - 1) cMask |> unsafeUIntToIndex
            (#v, readA#) = readArrayU index foundA
          in
            writeArray index (u v) readA

----------------------------
-- DynArrayFixedCapacity
----------------------------

-- Dynamically resizing array with fixed max capacity
data DynArrayFixedCapacity n a = DynArrayFixedCapacity# .(Array n a) UInt UInt

-- takes ownership of array
mkEmptyDynArrayFixedCapacity :: *Array n a -> UInt -> .DynArrayFixedCapacity n a
mkEmptyDynArrayFixedCapacity a capacity = DynArrayFixedCapacity# (freezeArray a) capacity 0

mkDynArrayFixedCapacity :: NatVal n -> (UInt -> a) -> .DynArrayFixedCapacity n a
mkDynArrayFixedCapacity n f = DynArrayFixedCapacity# (mkArray f |> freezeArray) c c
  where
    c = natVal n

dynArrayFixedCapacity_DeepCopy :: DynArrayFixedCapacity n a -> .DynArrayFixedCapacity n a
dynArrayFixedCapacity_DeepCopy (DynArrayFixedCapacity# a capacity size) =
  DynArrayFixedCapacity# (deepCopyArray a) capacity size

dynArrayFixedCapacity_Freeze :: *DynArrayFixedCapacity n a -> DynArrayFixedCapacity n a
dynArrayFixedCapacity_Freeze (DynArrayFixedCapacity# a capacity size) =
  DynArrayFixedCapacity# (freezeArray a) capacity size

dynArrayFixedCapacity_ContainsElement :: Eq a => a -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_ContainsElement element (DynArrayFixedCapacity# a capacity size) =
  (loop (#found, a', i#) = (#False, a, 0#) while (i < size && (not found)) do
    let
      (#elementAt, readA#) = readArrayU (unsafeUIntToIndex i) a'
      isElement = elementAt == element
    in
      (#isElement, readA, i + 1#)
  )
  |> \(#found, a', _#) -> (#found, DynArrayFixedCapacity# a' capacity size#)

dynArrayFixedCapacity_ContainsElementIf :: (a -> Bool) -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_ContainsElementIf f (DynArrayFixedCapacity# a capacity size) =
  (loop (#found, a', i#) = (#False, a, 0#) while (i < size && (not found)) do
    let
      (#elementAt, readA#) = readArrayU (unsafeUIntToIndex i) a'
      isElement = f elementAt
    in
      (#isElement, readA, i + 1#)
  )
  |> \(#found, a', _#) -> (#found, DynArrayFixedCapacity# a' capacity size#)

-- dynArrayFixedCapacity_Capacity :: *DynArrayFixedCapacity n a -> (#UInt, *DynArrayFixedCapacity n a#)
-- dynArrayFixedCapacity_Capacity n d = (#natVal n, d#)
--
-- dynArrayFixedCapacity_SizeAndCapacity :: *DynArrayFixedCapacity n a -> (#UInt, UInt, *DynArrayFixedCapacity n a#)
-- dynArrayFixedCapacity_SizeAndCapacity dyn =
--   (#size, maxCapacity, DynArrayFixedCapacity# a size#)
--   where
--     (#maxCapacity, (DynArrayFixedCapacity# a size)#) = dynArrayFixedCapacity_Capacity NatVal dyn

dynArrayFixedCapacity_PushBack :: a -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_PushBack element (DynArrayFixedCapacity# a capacity size) =
  if size >= capacity then
    (#False, DynArrayFixedCapacity# a capacity size#)
  else
    let
      elementWrittenA = writeArray (unsafeUIntToIndex size) element a
    in
      (#True, DynArrayFixedCapacity# elementWrittenA capacity (size + 1)#)

dynArrayFixedCapacity_PopBack :: *DynArrayFixedCapacity n a -> (#Maybe a, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_PopBack (DynArrayFixedCapacity# a capacity size) =
  if size == 0 then
    (#Nothing, DynArrayFixedCapacity# a capacity size#)
  else
    let
      size' = size - 1
      (#element, elementReadA#) = readArrayU (unsafeUIntToIndex size') a
    in
      (#Just element, DynArrayFixedCapacity# elementReadA capacity size'#)


-- first element is whether the operation was succesful, second element is the updated container
dynArrayFixedCapacity_PushUnique :: Eq a => a -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_PushUnique element (DynArrayFixedCapacity# a capacity size) =
  if size >= capacity then
    (#False, DynArrayFixedCapacity# a capacity size#)
  else
    let
      (#isContained, (DynArrayFixedCapacity# elementReadA _ _)#) = dynArrayFixedCapacity_ContainsElement element (DynArrayFixedCapacity# a capacity size)
    in
      if isContained then
        (#False, DynArrayFixedCapacity# elementReadA capacity size#)
      else
        let
          elementWrittenA = writeArray (unsafeUIntToIndex size) element elementReadA
        in
          (#True, DynArrayFixedCapacity# elementWrittenA capacity (size + 1)#)

-- first element is whether the operation was succesful, second element is the updated container
dynArrayFixedCapacity_PushUniqueIf :: (a -> Bool) -> a -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_PushUniqueIf f element (DynArrayFixedCapacity# a capacity size) =
  if size >= capacity then
    (#False, DynArrayFixedCapacity# a capacity size#)
  else
    let
      (#isContained, (DynArrayFixedCapacity# elementReadA _ _)#) = dynArrayFixedCapacity_ContainsElementIf f (DynArrayFixedCapacity# a capacity size)
    in
      if isContained then
        (#False, DynArrayFixedCapacity# elementReadA capacity size#)
      else
        let
          elementWrittenA = writeArray (unsafeUIntToIndex size) element elementReadA
        in
          (#True, DynArrayFixedCapacity# elementWrittenA capacity (size + 1)#)

-- first element is whether the operation was succesful, second element is the updated container
dynArrayFixedCapacity_UpdateElementIf :: (a -> Bool) -> (a -> a) -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_UpdateElementIf f u (DynArrayFixedCapacity# a capacity size) =
  (#found, DynArrayFixedCapacity# updatedA capacity size#)
  where
    (#found, foundA, afterI#) =
      (loop (#found, a', i#) = (#False, a, 0#) while (i < size && (not found)) do
        let
          (#elementAt, readA#) = readArrayU (unsafeUIntToIndex i) a'
          isElement = f elementAt
        in
          (#isElement, readA, i + 1#)
      )
    updatedA =
      if found then
        foundA
      else
        let
          index = unsafeUIntToIndex (afterI - 1)
          (#v, readA#) = readArrayU index foundA
        in
          writeArray index (u v) readA

-- first element returned is the updated container, second is if the operation was succesful
dynArrayFixedCapacity_EraseUnique :: Eq a => a -> *DynArrayFixedCapacity n a -> (#Bool, *DynArrayFixedCapacity n a#)
dynArrayFixedCapacity_EraseUnique element (DynArrayFixedCapacity# a capacity size) =
  (loop (#found, a', i#) = (#False, a, 0#) while (i < size) do
    if found then
      -- move elements down one by one
      let
        (#elementAt, elementReadA#) = readArrayU (unsafeUIntToIndex i) a'
        elementWrittenA = writeArray (unsafeUIntToIndex (i - 1)) elementAt elementReadA
      in
        (#True, elementWrittenA, i + 1#)
    else
      let
        (#elementAt, elementReadA#) = readArrayU (unsafeUIntToIndex i) a'
        isElement = elementAt == element
      in
        (#isElement, elementReadA, i + 1#)
  )
  |> \(#found, a', _#) ->
    (#found, DynArrayFixedCapacity# a' capacity (if found then size - 1 else size)#)

dynArrayFixedCapacity_Size :: DynArrayFixedCapacity n a -> UInt
dynArrayFixedCapacity_Size (DynArrayFixedCapacity# _ _ size) = size

dynArrayFixedCapacity_ToSlice :: DynArrayFixedCapacity n a -> Slice a
dynArrayFixedCapacity_ToSlice (DynArrayFixedCapacity# a capacity size) =
  subSlice a size

----------------------
-- DynArray
----------------------
data PolyThunkState = PolyThunkAlloc | PolyThunkInit | PolyThunkEval
data PolyThunk a    = PolyThunk# (Ptr .()) (Ptr .()) a PolyThunkState Float
-- UpdateState, CopyState, Arg, ThunkState, SampleOffset

data DynTier      a = DynTier# UInt UInt UInt (Ptr (.PolyThunk a))
data DynArray     a = DynArray# (.DynTier a) (.DynTier a)
data DynTierIndex   = DynTierLow | DynTierHigh
data DynArrayIndex  = DynArrayIndex# DynTierIndex UInt

-- dynTierTrace :: *DynTier a -> *DynTier a
-- dynTierTrace (DynTier# cap count hwm ptr) =
--   DynTier# cap count hwm ptr
--   |> trace "    DynTier { cap: "
--   |> trace cap
--   |> trace ", count: "
--   |> trace count
--   |> trace ", hwm: "
--   |> trace hwm
--   |> traceLn " }"

-- dynArrayTrace :: Array n Char -> *DynArray a -> *DynArray a
-- dynArrayTrace opName (DynArray# low high) =
--   let low'  = dynTierTrace <| traceLn "  {" <| traceLn "  DynArray " <| traceLn opName low in
--   let high' = traceLn " " <| traceLn "  }" <| dynTierTrace high in
--   DynArray# low' high'

dynArrayIndexEmpty :: DynArrayIndex
dynArrayIndexEmpty = DynArrayIndex# DynTierLow 0

dynTierEmpty :: UInt -> *DynTier a
dynTierEmpty capacity =
  DynTier# capacity 0 0 (ptrMalloc capacity)

dynArrayEmpty :: UInt -> *DynArray a
dynArrayEmpty capacity =
  DynArray# (dynTierEmpty 0) (dynTierEmpty capacity)

dynTierSwapToEndAndDelete :: UInt -> *DynTier a -> *DynTier a
dynTierSwapToEndAndDelete index (DynTier# capacity count highWaterMark ptr) =
  if index >= capacity then
    DynTier# capacity count highWaterMark ptr
  else if index == (count - 1) then
    DynTier# capacity (count - 1) highWaterMark ptr
  else
    case unsafePtrSwapElement index primUndefined ptr of
      (#indexElement, ptr2#) ->
        case unsafePtrSwapElement (count - 1) indexElement ptr2 of
          (#endElement, ptr3#) ->
            DynTier# capacity (count - 1) highWaterMark (unsafePtrPoke index endElement ptr3)

-- NOTE: This assumes that the tier is correctly sized!
dynTierAppend :: *PolyThunk a -> *DynTier a -> *DynTier a
dynTierAppend element (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > count then
    case unsafePtrSwapElement count element ptr of
      (#hwmElement, ptr'#) ->
        DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr')
  else
    DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke count element ptr)

  -- |> trace "dynTierAppend, capacity: "
  -- |> trace capacity
  -- |> trace ", count: "
  -- |> traceLn count

data DynTierPromotePopResult a = DynTierPromotePopEmpty | DynTierPromotePopLive (.PolyThunk a) | DynTierPromotePopInactive (.PolyThunk a)
dynTierPromotePop :: *DynTier a -> (#*DynTierPromotePopResult a, *DynTier a#)
dynTierPromotePop (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > 0 && highWaterMark > count && highWaterMark <= capacity then
    case unsafePtrSwapElement (highWaterMark - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopInactive element, DynTier# capacity count (highWaterMark - 1) ptr'#)
  else if count > 0 && count <= capacity then
    case unsafePtrSwapElement (count - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopLive element, DynTier# capacity (count - 1) (count - 1) ptr'#)
  else
    (#DynTierPromotePopEmpty, DynTier# capacity count highWaterMark ptr#)

dynArrayPromoteElement :: *DynArray a -> *DynArray a
dynArrayPromoteElement (DynArray# low (DynTier# capacity count highWaterMark ptr)) =
  case dynTierPromotePop low of
    (#DynTierPromotePopEmpty, low'#) ->
      DynArray# low' (DynTier# capacity count highWaterMark ptr)

    (#DynTierPromotePopInactive element, low'#) ->
      DynArray# low' (DynTier# capacity count (highWaterMark + 1) (unsafePtrPoke highWaterMark element ptr))

    (#DynTierPromotePopLive element, low'#) ->
      case unsafePtrSwapElement count element ptr of
        (#hwmElement, ptr'#) ->
          DynArray# low' (DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr'))

-- -- TODO: Nested case branching seems broken!?!?!?
-- dynArrayPromoteElement :: *DynArray a -> *DynArray a
-- dynArrayPromoteElement (DynArray# low (DynTier# capacity count highWaterMark ptr)) =
--   case dynTierPromotePop low of
--     (#m, low'#) ->
--       case m of
--         DynTierPromotePopEmpty ->
--           DynArray# low' (DynTier# capacity count highWaterMark ptr)
--
--         DynTierPromotePopInactive element ->
--           DynArray# low' (DynTier# capacity count (highWaterMark + 1) (unsafePtrPoke highWaterMark element ptr))
--
--         DynTierPromotePopLive element ->
--           case unsafePtrSwapElement count element ptr of
--             (#hwmElement, ptr'#) ->
--               DynArray# low' (DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr'))

-- NOTE: This assumes that the low tier has been completely moved to the high tier
dynArrayResize :: *DynArray a -> *DynArray a
dynArrayResize (DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)) =
  if highCount < highCapacity && hhwm < highCapacity then
    DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)
  else
    let
      newCap  = highCapacity * 2
      newLow  = DynTier# highCapacity highCount hhwm highPtr
      newHigh = DynTier# newCap 0 0 (ptrRealloc newCap lowPtr)
    in
      DynArray# newLow newHigh

dynArrayAppend :: *PolyThunk a -> *DynArray a -> *DynArray a
dynArrayAppend element (DynArray# low high) =
  DynArray# low (dynTierAppend element high)

dynTierModifyElement :: UInt -> (*PolyThunk a -> *PolyThunk a) -> *DynTier a -> *DynTier a
dynTierModifyElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    DynTier# capacity count highWaterMark ptr0
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element, ptr1#) ->
        DynTier# capacity count highWaterMark (unsafePtrPoke index (f element) ptr1)

data DynArrayResult a = DynArrayEnd | DynArrayNothing | DynArrayJust a

dynTierWithElement :: UInt -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynTier a -> (#Maybe b, *DynTier a#)
dynTierWithElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    (#Nothing, DynTier# capacity count highWaterMark ptr0#)
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element0, ptr1#) ->
        case f element0 of
          (#result, element1#) ->
            (#Just result, DynTier# capacity count highWaterMark (unsafePtrPoke index element1 ptr1)#)

dynArrayWithElement :: DynArrayIndex -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArray a -> (#DynArrayResult b, *DynArray a#)
dynArrayWithElement (DynArrayIndex# tier index) f (DynArray# low high) =
  case tier of
    DynTierLow ->
      case dynTierWithElement index f low of
        (#result, low'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low' high#)
            _            -> (#DynArrayNothing, DynArray# low' high#)
    DynTierHigh ->
      case dynTierWithElement index f high of
        (#result, high'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low high'#)
            _            -> (#DynArrayEnd, DynArray# low high'#)

dynArrayDelete :: DynArrayIndex -> *DynArray a -> *DynArray a
dynArrayDelete (DynArrayIndex# tier index) (DynArray# low high) =
  case tier of
    DynTierLow  -> DynArray# (dynTierSwapToEndAndDelete index low) high
    DynTierHigh -> DynArray# low (dynTierSwapToEndAndDelete index high)

dynArrayEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArray a -> *DynArray a
dynArrayEmplaceOrAppend emplaceInit appendMk (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr)) =
  if highCount < highWaterMark then
    DynArray# low (dynTierModifyElement highCount emplaceInit <| DynTier# highCapacity (highCount + 1) highWaterMark highPtr)
  else
    dynArrayAppend (appendMk ()) (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr))

data DynArrayIterator a = DynArrayIterator# DynArrayIndex (.DynArray a)

dynArrayIterator :: *DynArray a -> *DynArrayIterator a
dynArrayIterator x = DynArrayIterator# dynArrayIndexEmpty x

dynArrayIteratorEnd :: *DynArrayIterator a -> *DynArray a
dynArrayIteratorEnd (DynArrayIterator# _ array) = array

dynArrayIteratorEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorEmplaceOrAppend emplaceInit appendMk (DynArrayIterator# _ array) =
  DynArrayIterator# dynArrayIndexEmpty <| dynArrayEmplaceOrAppend emplaceInit appendMk <| dynArrayResize <| dynArrayPromoteElement array

dynArrayIteratorWithElement :: (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArrayIterator a -> (#DynArrayResult b, *DynArrayIterator a#)
dynArrayIteratorWithElement f (DynArrayIterator# index array) =
  case dynArrayWithElement index f array of
    (#result, array'#) ->
      (#result, DynArrayIterator# index array'#)

dynArrayIteratorNext :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorNext (DynArrayIterator# (DynArrayIndex# tier index) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))) =
  case tier of
    DynTierLow ->
      if index < lcount then
        DynArrayIterator# (DynArrayIndex# DynTierLow (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
      else
        DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
    DynTierHigh ->
      DynArrayIterator# (DynArrayIndex# DynTierHigh (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))

dynArrayIteratorFree :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorFree (DynArrayIterator# index array) =
  case dynArrayDelete index array of
    DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr) ->
      case index of
        DynArrayIndex# tier _ ->
          case tier of
            DynTierLow ->
              if lcount > 0 then
                DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
              else
                DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
            DynTierHigh ->
              DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))


--------------------
-- PolyThunks
--------------------
-- NOTE on Propagation:
--    * All Type variables are propagating
--    * In data constructors type variables are always polymorphic in uniqueness
--    * In data constructors monomorphic types default to shared uniqueness
--    * Uniqueness notation is allowed in data constructors only on monomorphic type cons
--    * Higher Kinded Types do not have uniqueness types and do not propagate uniqueness, instead Type Applications have uniqueness types associated with them and are propagating!
--    * Propagation behavior is enforced by the type of the data constructor function!
dynDeepCopy :: a -> (#Ptr *(), a#)
dynDeepCopy x =
  primUndefined

dynDeepCopyInto :: Ptr *() -> a -> (#Ptr *(), a#)
dynDeepCopyInto copyState x =
  primUndefined

polyThunkAlloc :: a -> Float -> () -> *PolyThunk a
polyThunkAlloc x sampleOffset u =
  case dynDeepCopy x of
    (#copyState, x'#) ->
      PolyThunk# primUndefined copyState x' PolyThunkAlloc sampleOffset

polyThunkInit :: a -> Float -> *PolyThunk a -> *PolyThunk a
polyThunkInit x sampleOffset (PolyThunk# updateState copyState _ _ _)  =
  case dynDeepCopyInto copyState x of
    (#copyState', x'#) ->
      PolyThunk# updateState copyState' x' PolyThunkInit sampleOffset

-- compiler magic prevents this from inlining, which is required for poly to function properly
polyThunkEvalGo :: (a -> b) -> a -> b
polyThunkEvalGo f x = f x

polyThunkEval :: (a -> b) -> *PolyThunk a -> (#b, *PolyThunk a#)
polyThunkEval f t =
  let
    dummy = polyThunkEvalGo f primUndefined
  in
    primUndefined


----------------------
-- Poly
----------------------
class Finite a where
  isRunning :: a -> Bool

class (Monoid p, Finite p) => Poly p where

instance Finite Audio where
  isRunning c =
    case c of
      AudioEnd -> False
      _        -> True

instance Finite a => Finite (Mono a) where
  isRunning (Mono x) = isRunning x

instance Finite a => Finite (Stereo a) where
  isRunning (Stereo# l r) = isRunning l && isRunning r

instance Poly Audio where
instance Poly a => Poly (Mono a) where
instance Poly a => Poly (Stereo a) where
-- TODO / BUG: These instance declarations should throw type errors without the Poly constraint on 'a', but they are not!, Test case below:
-- polyFn :: Bool -> Mono Bool
-- polyFn b = Mono b
--
-- polyTest :: Mono Bool
-- polyTest =
--   poly polyFn (pure True)

calculateAudioSampleOffset :: Rational -> Rational -> Float
calculateAudioSampleOffset valueTime tickTime =
  (fromInt n / fromInt d) * fromUInt audioBlockSize
  where
    Rational# n d =
      (valueTime - (tickTime - audioBlockDelta)) / audioBlockDelta

calculateCurrBlockTimeOffset :: Rational -> Rational -> Rational
calculateCurrBlockTimeOffset valueTime tickTime =
  valueTime - (tickTime - audioBlockDelta)

seqToAudio :: (AudioFormat f) => Seq Float -> f Audio
seqToAudio s =
  pure (AudioRate (freezeArray aout))
  where
    (#_, aout#) =
      loop (#i0, a#) = (#audioSampleOffset, audioInitArray ()#) while i0 < audioBlockSize do
        let
          i1        = i0 + 1
          time ~ 0  = time + audioSampleDelta
          value ~ 0 =
            thd' <| loop (#cont, seqDuration0, prevValue#) = (#True, 0, value#) while cont do
              let
                nextValueTime ~ 0 = nextValueTime + seqDuration0
                -- blockTimeOffset   = calculateCurrBlockTimeOffset nextValueTime time
              in
                if nextValueTime > time then (#False, 0, prevValue#) else
                  case runSeq s (getSeqParamAtExactTime nextValueTime) of
                    SeqValue# seqDuration1 _ (Just seqValue) -> (#True, seqDuration1, seqValue#)
                    SeqValue# seqDuration1 _ _               -> (#True, seqDuration1, prevValue#)
        in
          (#i1, writeArray (Index i0) (fromFloat value) a#)

-- HOW TO DEAL WITH VOICE RELEASE EVENTS?!?!
-- Bug with initial note? start/end time for voice? time issue with gate?
-- TO DO: argument handling!
-- DIFFEENT SEQS FOR ID -> ARG(s?) -> DURATION?

emptySeqToVoiceEventDynArray :: () -> *DynArrayFixedCapacity 256 VoiceEvent
emptySeqToVoiceEventDynArray _ = mkEmptyDynArrayFixedCapacity (unsafeEmptyArray ()) 256

-- Taks a sequence of (VoiceID, Note_Duration_Seconds, Note_Param), where note param will be forwarded to your synth via polyVoiceBank
seqToVoiceEvents :: Seq (Int, Rational, Float) -> Slice VoiceEvent
seqToVoiceEvents sIDs_Durations_Params =
  (loop (#cont, time, veBuffer#) = (#True, 0, emptySeqToVoiceEventDynArray ()#) while cont do
    let
      nextValueTime ~ 0 = nextValueTime + time
      audioSampleOffset = calculateAudioSampleOffset nextValueTime tick
    in
      if nextValueTime < tick then
        case runSeq sIDs_Durations_Params (getSeqParamAtExactTime nextValueTime) of
          SeqValue# t _ mx ->
            case mx of
              Just (vid, nduration, nparams) ->
                let
                  ve =
                    -- traceLn2 "seqToVoiceEvents: " <|
                    VoiceEvent
                      (VoiceID vid)
                      VoiceActive
                      (VoiceTimeStamp_StartStop_Rational nextValueTime (nextValueTime + nduration))
                      nparams
                  veBuffer' = dynArrayFixedCapacity_PushBack ve veBuffer |> snd'
                in
                  (#True, t, veBuffer'#)
              Nothing -> (#True, t, veBuffer#)
      else
        (#False, 0, veBuffer#)
  ) |> \(#_, _, veBuffer#) ->
    dynArrayFixedCapacity_Freeze veBuffer
    |> dynArrayFixedCapacity_ToSlice
  where
    tick ~ 0 = tick + audioBlockDelta

-- TODO: Either make poly only accept unboxed types, or making poly ACTUALLY accept boxed types correctly! Or does it do this and I forgot implementing? Double check!
poly :: Poly b => (a -> b) -> Seq a -> b
poly f s =
  case mutRefTake (\_ -> dynArrayEmpty 8) of
    (#thunks0, mref#) ->
      let
        tick ~ 0                = tick + audioBlockDelta
        (#_, _, acc', thunks4#) =
          loop (#cont, time, acc, thunks1#) = (#True, 0, mempty, dynArrayIterator thunks0#) while cont do
            let
              nextValueTime ~ 0 = nextValueTime + time
              audioSampleOffset = calculateAudioSampleOffset nextValueTime tick
            in
              if nextValueTime < tick then
                case runSeq s (getSeqParamAtExactTime nextValueTime) of
                  SeqValue# t _ mx ->
                    case mx of
                      Just x  -> (#True, t, acc, dynArrayIteratorEmplaceOrAppend (polyThunkInit x audioSampleOffset) (polyThunkAlloc x audioSampleOffset) thunks1#)
                      Nothing -> (#True, t, acc, thunks1#)
              else
                case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                  (#maybeEvalResult, thunks2#) ->
                    case maybeEvalResult of
                      DynArrayJust evalResult ->
                        if isRunning evalResult then
                          (#True, 0, append acc evalResult, dynArrayIteratorNext thunks2#)
                        else
                          (#True, 0, acc, dynArrayIteratorFree thunks2#)
                      DynArrayNothing -> (#True,  0, acc, dynArrayIteratorNext thunks2#)
                      DynArrayEnd     -> (#False, 0, acc, thunks2#)
      in
        case mutRefPut (dynArrayIteratorEnd thunks4) mref of
          _ -> acc'

poly2 :: Poly c => (a -> b -> c) -> Seq a -> Seq b -> c
poly2 f x y = poly (uncurry' f) (map2 (\x' y' -> (#x', y'#)) x y)

poly3 :: Poly d => (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> d
poly3 f x y z = poly (uncurry3' f) (map3 (\x' y' z' -> (#x', y', z'#)) x y z)

polyEmplace :: a -> Rational -> *DynArrayIterator a -> *DynArrayIterator a
polyEmplace x nextValueTime thunks =
  dynArrayIteratorEmplaceOrAppend (polyThunkInit x audioSampleOffset) (polyThunkAlloc x audioSampleOffset) thunks
  where
    audioSampleOffset = (fromInt n / fromInt d) * fromUInt audioBlockSize
    Rational#     n d = nextValueTime / audioBlockDelta

polyScore :: (ScoreType s, Poly b) => Score s -> (a -> b) -> Seq a -> b
polyScore scr f s =
  case mutRefTake (\_ -> (#dynArrayEmpty 8, 0, True#)) of
    (#(#thunks0, prevValueTime0, isFirstBeat#), mref#) ->
      let
        firstBeatOffset = if isFirstBeat then scoreBeatStartTime (scoreGetNextBeat scr) - currBlockTime else 0
        (#_, prevValueTime1, acc', thunks4#) =
          loop (#cont, nextValueTime, acc, thunks1#) = (#True, prevValueTime0 + firstBeatOffset, mempty, dynArrayIterator thunks0#) while cont do
            if nextValueTime < audioBlockDelta then
              case runSeq s (SeqParam# nextValueTime) of
                SeqValue# dur _ mx ->
                  let nextValueTime' = nextValueTime + dur * scoreGetTempoWithOffset scr nextValueTime in
                  case mx of
                    Just x  -> (#True, nextValueTime', acc, polyEmplace x nextValueTime thunks1#)
                    Nothing -> (#True, nextValueTime', acc, thunks1#)
            else
              case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                (#maybeEvalResult, thunks2#) ->
                  case maybeEvalResult of
                    DynArrayJust evalResult ->
                      if isRunning evalResult then
                        (#True, nextValueTime, append acc evalResult, dynArrayIteratorNext thunks2#)
                      else
                        (#True, nextValueTime, acc, dynArrayIteratorFree thunks2#)
                    DynArrayNothing -> (#True,  nextValueTime, acc, dynArrayIteratorNext thunks2#)
                    DynArrayEnd     -> (#False, nextValueTime - audioBlockDelta, acc, thunks2#)
      in
        case mutRefPut (#dynArrayIteratorEnd thunks4, prevValueTime1, False#) mref of
          _ -> acc'

seqToAudioScore :: (ScoreType s, AudioFormat f) => Score s -> Seq Float -> f Audio
seqToAudioScore scr s =
  case mutRefTake (\_ -> (#1, 0, True#)) of
    (#(#prevValue0, prevValueTime0, isFirstTime#), mref#) ->
      let
        firstBeatOffset = if isFirstTime then scoreBeatStartTime (scoreGetNextBeat scr) - currBlockTime else 0
        (#_, aout, nextValue, nextValueTime#)  =
          loop (#i0, a, prevValue, prevValueTime#) = (#0, unsafeEmptyArray (), prevValue0, prevValueTime0 + firstBeatOffset#) while i0 < audioBlockSize do
            let
              i1                   = i0 + 1
              sampleTime           = fromUInt i0 // fromUInt audioSampleRate
              (#value, valueTime#) =
                if prevValueTime > sampleTime then (#prevValue, prevValueTime#) else
                  case runSeq s (SeqParam# prevValueTime) of
                    SeqValue# dur _ msv ->
                      let nextValueTime' = prevValueTime + dur * scoreGetTempoWithOffset scr prevValueTime in
                      case msv of
                        Just seqValue -> (#seqValue,  nextValueTime'#)
                        Nothing       -> (#prevValue, nextValueTime'#)
            in
              (#i1, writeArray (Index i0) value a, value, valueTime #)
      in
        case mutRefPut (#nextValue, nextValueTime - audioBlockDelta, False#) mref of
          _ -> pure (AudioRate (freezeArray aout))

-- testJit :: *World -> *World
-- testJit w = w

-- somePow :: F64
-- somePow = pow pi 5

-- testJit :: *World -> *World
-- testJit w =
--     print "halfPi: " w
--     |> printLn halfPi
--     |> print "floor halfPi: "
--     |> printLn (floor halfPi)
--     |> print "floor -halfPi: "
--     |> printLn (floor <| negate halfPi)
--     |> print "ceil halfPi: "
--     |> printLn (ceil halfPi)
--     |> print "ceil -halfPi: "
--     |> printLn (ceil <| negate halfPi)
--     |> print "truncate halfPi: "
--     |> printLn (truncate halfPi)
--     |> print "truncate -halfPi: "
--     |> printLn (truncate <| negate halfPi)
--     |> print "round halfPi: "
--     |> printLn (round halfPi)
--     |> print "round -halfPi: "
--     |> printLn (round <| negate halfPi)
--     |> print "copysign 666 halfPi: "
--     |> printLn (copysign 666 halfPi)
--     |> print "copysign 666 -halfPi: "
--     |> printLn (copysign 666 <| negate halfPi)
--     |> print "signum halfPi: "
--     |> printLn (signum halfPi)
--     |> print "signum -halfPi: "
--     |> printLn (signum <| negate halfPi)
--     |> print "floorToInt halfPi: "
--     |> printLn (floorToInt halfPi)
--     |> print "floorToInt -halfPi: "
--     |> printLn (floorToInt <| negate halfPi)
--     |> print "ceilToInt halfPi: "
--     |> printLn (ceilToInt halfPi)
--     |> print "ceilToInt -halfPi: "
--     |> printLn (ceilToInt <| negate halfPi)
--     |> print "truncateToInt halfPi: "
--     |> printLn (truncateToInt halfPi)
--     |> print "truncateToInt -halfPi: "
--     |> printLn (truncateToInt <| negate halfPi)
--     |> print "roundToInt halfPi: "
--     |> printLn (roundToInt halfPi)
--     |> print "roundToInt -halfPi: "
--     |> printLn (roundToInt <| negate halfPi)

-- copysign :: F64 -> F64 -> F64
-- fmin :: F64 -> F64 -> F64
-- fmax :: F64 -> F64 -> F64
-- floorToInt :: F64 -> Int
-- ceilToInt :: F64 -> Int
-- truncateToInt :: F64 -> Int
-- roundToInt :: F64 -> Int

-- testJit :: *World -> *World
-- testJit w = printLn "IEEE format=========================================" w
--           |> print "iEEESignMask"
-- 		  |> print " -> "
--           |> printLn iEEESignMask
--           |> print "iEEESignMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignMaskF
--           |> print "iEEEExponentMask"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMask
--           |> print "iEEEExponentMaskF"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMaskF
--           |> print "iEEESignificandMask"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMask
--           |> print "iEEESignificandMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMaskF
--           |> print "all bits"
-- 		  |> print " -> "
--           |> printLn allBits
--           |> print "all bits F"
-- 		  |> print " -> "
--           |> printLn allBitsF
--     where
--       allBits :: UInt
--       allBits = -1
--       allBitsF :: Float
--       allBitsF = fromBits allBits

----------------------
-- Oscillator tests
----------------------

oscTest :: (Mono Audio -> Mono Audio) -> Stereo Audio
oscTest f =
  perc 10 1 3 6000 + 50
  |> f
  |> perc 5 5 -1
  |> mul 0.2
  |> mixStereo

-- -- Arrays of Audio seems broken at the moment :\
-- oscTestMany :: (Mono Audio -> Mono Audio) -> Stereo Audio
-- oscTestMany f =
--   s
--   |> mul 0.01
--   |> perc 5 5 -1
--   |> mul 0.1
--   |> mixStereo
--   where
--     freq = perc 10 1 3 6000 + 50
--     r :: Range 100
--     r = each
--     s     =
--       loop o = 0 for i <- r do
--         f freq + o

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest sin) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest tri) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (lfPulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (pulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       pulse ((sin 0.2 * 0.4) + 0.5) 440
--       |> perc 5 5 -1
--       |> mul 0.1
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest lfSaw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest saw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTestMany saw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lpf (perc 10 1 4 5000 + 330) 0.075
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> hpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf 2000 (abs (sin 0.5 * 3) + 0.01)
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lowShelf (5110 - perc 10 1 -4 5000) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> highShelf (perc 10 1 -4 5000 + 220) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       perc 10 1 3 6000 + 50
--       |> lfSaw 0
--       |> highShelf 20000 -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superSaw 440 0.1 0.7
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superPulse 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superTri 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 200 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.125 * 0.125)
--     osc  =
--       syncTri sync 200
--       |> perc 5 15 0.1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.25 * 0.125)
--     osc  =
--       syncPulse 0.66667 sync 100
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       hardSyncPulse sync 0.5 100
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 240 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.2 * 0.35)
--     osc  =
--       syncSaw sync 0.495 80
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync =
--       ([1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 400)
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lag 0.085
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       perc 10 1 3 4000 + 50
--       |> hardSyncSaw sync
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync =
--       ([1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 50)
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lag 0.085
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       perc 10 1 3 4000 + 5
--       |> hardSyncPulse sync 0.5
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     ikedaSize :: NatVal2 2 25
--     ikedaSize = NatVal2
--     ikedaFn (Vector2D# x y) s = (#s + ((abs x + abs y) * recipSampleRate * 0.05), 0.25 * (sine s + sine x + sine ((y * 2) + (sine (x * 0.0001) * 5)))#)
--     a =
--       ikedaAttractor ikedaSize ikedaFn 0.99925 (stereo 120 80)
--       |> perc 10 20 -1
--       |> mul 0.5

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal2 4 4
--     size = NatVal2
--     ifn i (Vector2D# x y)   = (#Vector2D# (x * 0.1) (y * 0.1), fromUInt i#)
--     mfn i (Vector2D# x y) s = (#s, 0.25 * (sine (x * 0.1) + sine ((y * 0.2) + (sine (x * 0.0001) * 5)))#)
--     a =
--       ikedaAttractor size ifn mfn 0.1 (stereo 5 10)
--       |> perc 10 20 -1
--       |> mul 0.4

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal2 8 8
--     size = NatVal2
--     ifn i (Vector2D# x y)   = (#Vector2D# (x * 1) (y * 1), fromUInt i#)
--     mfn i (Vector2D# x y) s = (#s, sine (((x + ((s * 10)) + 1) * 200) + (sine (y * 0.4) * -200)) + sine ((y * 200) + (sine (x * 0.4) * 200))#)
--     a =
--       duffingAttractor size ifn mfn 0.27 0.3 1 (stereo 10 20)
--       |> perc 10 20 -1
--       |> mul 0.5

    -- mfn i (Vector3D# x y z) s = (#s, sine (x * 400) + sine (y * 400) + sine (z * 400)#)

-- -- TODO: Use dot product vs forward/up vector for oscillator frequency
-- -- Doom Bubbles
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 5 5 5
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# (x * 0.1) (y * 0.1) (z * 0.1), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s + ((magnitude3D (Vector3D# x y z)) * 30 * recipSampleRate), ((sine s + sine (s * 0.5)) * 0.5) + (sine (x * 4.00) * 0.5) + sine (z * 1)#)
--     a =
--       lorenzAttractor size ifn mfn 10 38 (8/3) (perc 15 15 1 11 + stereo 6 6.01)
--       |> lpf (perc 20 10 1 4000 + 50) 0.5
--       |> delay twoSec (stereo 1 2) 0.3
--       |> perc 10 20 -1
--       |> mul 0.15


------------------------------------------------------------------------------------------------
-- Tunings

-- TODO: Tonality Lattices/Diamonds

-- Scale (Tuning --> last index is repeat ratio, typically 2.0 for an octave) (Degrees) rootFreq
data Scale (t :: Nat) (d :: Nat) = Scale (Array t Float) (Array d UInt) Float

equalTemperament :: Array 13 Float
equalTemperament =
  mkArray (\x -> pow 2 (fromUInt x / 12))

sruti :: Array 23 Float
sruti =
  {
    1,
    256/243,
    16/15,
    10/9,
    9/8,
    32/27,
    6/5,
    5/4,
    81/64,
    4/3,
    27/20,
    45/32,
    729/512,
    3/2,
    128/81,
    8/5,
    5/3,
    27/16,
    16/9,
    9/5,
    15/8,
    243/128,
    2
  }

slendroTuning :: Array 6 Float
slendroTuning =
  {
    1,
    1.1654065573126493,
    1.3263853707896778,
    1.5087286267502333,
    1.743113687764283,
    2
  }

slendroTuning2 :: Array 13 Float
slendroTuning2 =
  {
    1,
    1.0204225362734822,
    1.1044540007443515,
    1.1721576888192515,
    1.2191142483402215,
    1.3464556089438007,
    1.3464556089438007,
    1.4870982841226525,
    1.5457782086418603,
    1.6405353335201565,
    1.7766588275058794,
    1.8118958124688056,
    2
  }

pelogTuning :: Array 6 Float
pelogTuning =
  {
    1,
    1.0999973132782155,
    1.3763365917680923,
    1.4581778243945491,
    1.629203328218162,
    2
  }

ankaraTuning :: Array 35 Float
ankaraTuning =
  {
    1,
    1053/1000,
    533/500,
    1079/1000,
    273/250,
    111/100,
    281/250,
    589/500,
    239/200,
    1211/1000,
    123/100,
    156/125,
    158/125,
    1333/1000,
    677/500,
    1373/1000,
    1393/1000,
    7/5,
    1421/1000,
    721/500,
    3/2,
    317/200,
    201/125,
    407/250,
    1653/1000,
    167/100,
    211/125,
    1777/1000,
    1801/1000,
    1827/1000,
    1853/1000,
    47/25,
    951/500,
    1931/1000,
    2
  }

flamencoTuning :: Array 13 Float
flamencoTuning =
  {
    1,
    160/153,
    512/459,
    32/27,
    64/51,
    4/3,
    1216/867,
    76/51,
    80/51,
    256/153,
    16/9,
    4096/2187,
    2
  }

hawaiianTuning :: Array 13 Float
hawaiianTuning =
  {
    1,
    1418440/1360773,
    168926/151197,
    60354/50399,
    566204/453591,
    67431/50399,
    1897784/1360773,
    75338/50399,
    2120315/1360773,
    84172/50399,
    90219/50399,
    846376/453591,
    2
  }

kotoTuning :: Array 12 Float
kotoTuning =
  {
    107/152,
    3/4,
    5/4,
    143/114,
    45/32,
    429/304,
    3/2,
    1/1,
    5/4,
    15/8,
    143/76,
    2
  }

mothraTuning :: Array 12 Float
mothraTuning =
  {
    1,
    1.1189384464207068,
    1.1436839646530013,
    1.2797119586051036,
    1.3080130110044073,
    1.4635860464313424,
    1.49595350624323,
    1.6738798921934088,
    1.7108980369568154,
    1.914389591456696,
    1.9567266500238074,
    2
  }

justTuning :: Array 13 Float
justTuning =
  {
    1,
    16/15,
    9/8,
    6/5,
    5/4,
    4/3,
    45/32,
    3/2,
    8/5,
    5/3,
    9/5,
    15/8,
    2
  }

-- Tuning used in The Well Tuned Piano, by La Monte Young
youngTuning :: Array 13 Float
youngTuning =
  {
    1,
    567/512,
    9/8,
    147/128,
    21/16,
    1323/1024,
    189/128,
    3/2,
    49/32,
    7/4,
    441/256,
    63/32,
    2
  }

-- Note that the pitches are not arranged in frequency ascent,
-- Rather, they are arranged according to the original tunings of the keys in The Well Tuned Piano
youngScale :: Scale 13 12
youngScale =
  Scale youngTuning { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 } 297.989

partch43Tuning :: Array 44 Float
partch43Tuning =
  {
    1, 81/80, 33/32, 21/20, 16/15, 12/11, 11/10, 10/9, 9/8, 8/7,
    7/6, 32/27, 6/5, 11/9, 5/4, 14/11, 9/7, 21/16, 4/3, 27/20,
    11/8, 7/5, 10/7, 16/11, 40/27, 3/2, 32/21, 14/9, 11/7, 8/5,
    18/11, 5/3, 27/16, 12/7, 7/4, 16/9, 9/5, 20/11, 11/6, 15/8,
    40/21, 64/33, 160/81, 2
  }

egyptianTuning :: Array 13 Float
egyptianTuning =
  { 1/2, 107/96, 9/8, 11/9, 59/48, 4/3, 1/1, 3/2, 5/3, 121/72, 11/6, 133/72, 2 }

justMajor :: Scale 13 7
justMajor =
  Scale justTuning {0, 2, 4, 5, 7, 9, 11} 261.6255653006

major :: Float -> Scale 13 7
major rootFreq =
  Scale equalTemperament {0, 2, 4, 5, 7, 9, 11} rootFreq

minor :: Float -> Scale 13 7
minor rootFreq =
  Scale equalTemperament {0, 2, 3, 5, 7, 8, 10} rootFreq

middleC :: Float
middleC = 261.6255653006

---------------
-- Major Scales

cMajor :: Scale 13 7
cMajor = major middleC

dMajor :: Scale 13 7
dMajor = major <| d2f cMajor 1

eMajor :: Scale 13 7
eMajor = major <| d2f cMajor 2

fMajor :: Scale 13 7
fMajor = major <| d2f cMajor 3

gMajor :: Scale 13 7
gMajor = major <| d2f cMajor 4

aMajor :: Scale 13 7
aMajor = major <| d2f cMajor 5

bMajor :: Scale 13 7
bMajor = major <| d2f cMajor 6

---------------
-- Minor Scales

cMinor :: Scale 13 7
cMinor = minor middleC

dMinor :: Scale 13 7
dMinor = major <| d2f cMinor 1

eMinor :: Scale 13 7
eMinor = major <| d2f cMinor 2

fMinor :: Scale 13 7
fMinor = major <| d2f cMinor 3

gMinor :: Scale 13 7
gMinor = major <| d2f cMinor 4

aMinor :: Scale 13 7
aMinor = major <| d2f cMinor 5

bMinor :: Scale 13 7
bMinor = major <| d2f cMinor 6

-------------------------
-- Harmonic Minor Scales

harmonicMinor :: Float -> Scale 13 7
harmonicMinor rootFreq =
  Scale equalTemperament {0, 2, 3, 5, 7, 8, 11} rootFreq

cHarmonicMinor :: Scale 13 7
cHarmonicMinor = harmonicMinor middleC

dHarmonicMinor :: Scale 13 7
dHarmonicMinor = harmonicMinor <| d2f cMinor 1

eHarmonicMinor :: Scale 13 7
eHarmonicMinor = harmonicMinor <| d2f cMinor 2

fHarmonicMinor :: Scale 13 7
fHarmonicMinor = harmonicMinor <| d2f cMinor 3

gHarmonicMinor :: Scale 13 7
gHarmonicMinor = harmonicMinor <| d2f cMinor 4

aHarmonicMinor :: Scale 13 7
aHarmonicMinor = harmonicMinor <| d2f cMinor 5

bHarmonicMinor :: Scale 13 7
bHarmonicMinor = harmonicMinor <| d2f cMinor 6

-------------------------
-- Harmonic Major Scales

harmonicMajor :: Float -> Scale 13 7
harmonicMajor rootFreq =
  Scale equalTemperament {0, 2, 4, 5, 7, 8, 11} rootFreq

cHarmonicMajor :: Scale 13 7
cHarmonicMajor = harmonicMajor middleC

dHarmonicMajor :: Scale 13 7
dHarmonicMajor = harmonicMajor <| d2f cMajor 1

eHarmonicMajor :: Scale 13 7
eHarmonicMajor = harmonicMajor <| d2f cMajor 2

fHarmonicMajor :: Scale 13 7
fHarmonicMajor = harmonicMajor <| d2f cMajor 3

gHarmonicMajor :: Scale 13 7
gHarmonicMajor = harmonicMajor <| d2f cMajor 4

aHarmonicMajor :: Scale 13 7
aHarmonicMajor = harmonicMajor <| d2f cMajor 5

bHarmonicMajor :: Scale 13 7
bHarmonicMajor = harmonicMajor <| d2f cMajor 6

-- NOTE / TODO: This root of 200 business makes little sense! Had it like this for part of piece, but that's not even used anymore...
justChromatic :: Scale 13 12
justChromatic =
  -- Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 150
  Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 200
  -- Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 200

-- justChromaticTest :: Scale 12 12
-- justChromaticTest =
--   Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 266.668
--

chromatic :: Scale 13 12
chromatic =
  Scale equalTemperament {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} middleC

coleJI :: Scale 13 12
coleJI =
  Scale {1,10/9,9/8,8/7,6/5,4/3,11/8,3/2,8/5,7/4,16/9,9/5, 2} {0,1,2,3,4,5,6,7,8,9,10,11} middleC

partch43 :: Scale 44 43
partch43 =
  -- Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 250
  Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 300
  -- Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 261.6255653006

----------------------------------------------------------------------
----------------------------------------------------------------------
-- Axial based scales
-- based on the article found here:
-- https://www.xenharmonikon.org/2020/04/27/the-axial-chord-a-basis-for-2-3-7-11-harmony/ 
----------------------------------------------------------------------

axialPentatonic :: Float -> Scale 6 5
axialPentatonic rootFreq =
  Scale
    { 1/1, 33/32, 21/16, 11/8, 7/4, 2/1 }
    { 0, 1, 2, 3, 4 }
    rootFreq

primal :: Float -> Scale 7 6
primal rootFreq =
  Scale
    { 1/1, 33/32, 21/16, 11/8, 7/4, 231/128, 2/1 }
    { 0, 1, 2, 3, 4, 5 }
    rootFreq

axial :: Float -> Scale 8 7
axial rootFreq =
  Scale
    { 1/1, 33/32, 7/6, 21/16, 11/8, 99/64, 7/4, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6 }
    rootFreq

primaxial :: Float -> Scale 11 10
primaxial rootFreq =
  Scale
    { 1/1, 33/32, 7/6, 77/64, 21/16, 11/8, 3/2, 99/64, 7/4, 231/128, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    rootFreq

blackstar :: Float -> Scale 11 10
blackstar rootFreq =
  Scale
    { 1/1, 33/32, 8/7, 77/64, 21/16, 11/8, 3/2, 11/7, 7/4, 231/128, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    rootFreq

janus :: Float -> Scale 13 12
janus rootFreq =
  Scale
    { 1/1, 33/32, 9/8, 7/6, 5/4, 21/16, 11/8, 3/2, 99/64, 5/3, 7/4, 15/8, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
    rootFreq

primaxial12 :: Float -> Scale 13 12
primaxial12 rootFreq =
  Scale
    { 1/1, 33/32, 9/8, 7/6, 77/64, 21/16, 11/8, 3/2, 99/64, 77/48, 7/4, 231/128, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
    rootFreq

axialK5 :: Float -> Scale 16 15
axialK5 rootFreq =
  Scale
    { 1/1, 33/32, 147/128, 4851/4096, 77/64, 2541/2048, 21/16, 693/512, 11/8, 363/256, 1617/1024, 53361/32768, 7/4, 231/128, 7623/4096, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }
    rootFreq

astral17 :: Float -> Scale 18 17
astral17 rootFreq =
  Scale
    { 1/1, 33/32, 147/128, 4851/4096, 77/64, 2541/2048, 21/16, 693/512, 11/8, 363/256, 1617/1024, 53361/32768, 441/256, 7/4, 231/128, 7623/4096, 121/64, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }
    rootFreq

astral19 :: Float -> Scale 20 19
astral19 rootFreq =
  Scale
    { 1/1, 33/32, 1089/1024, 147/128, 4851/4096, 77/64, 2541/2048, 21/16, 693/512, 11/8, 363/256, 49/32, 1617/1024, 53361/32768, 441/256, 7/4, 231/128, 7623/4096, 121/64, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }
    rootFreq

astral19Diamond :: Float -> Scale 18 17
astral19Diamond rootFreq =
  Scale
    { 1/1, 33/32, 22/21, 8/7, 33/28, 14/11, 21/16, 4/3, 11/8, 16/11, 3/2, 32/21, 11/7, 56/33, 7/4, 21/11, 64/33, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }
    rootFreq

astral21 :: Float -> Scale 22 21
astral21 rootFreq =
  Scale
    { 1/1, 33/32, 1089/1024, 693/512, 147/128, 4851/4096, 77/64, 2541/2048, 21/16, 693/512, 11/8, 363/256, 3/2, 49/32, 1617/1024, 53361/32768, 441/256, 7/4, 231/128, 7623/4096, 121/64, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 }
    rootFreq

astral47 :: Float -> Scale 48 47
astral47 rootFreq =
  Scale
    {
      1/1, 99/98, 64/63, 33/32, 28/27, 22/21, 256/231, 9/8, 112/99, 8/7, 297/256, 7/6, 33/28, 32/27, 77/64, 14/11, 9/7, 128/99, 21/16, 297/224, 4/3, 693/512, 49/36, 11/8, 16/11, 72/49, 1024/693,
      3/2, 448/297, 32/21, 99/64, 14/9, 11/7, 128/77, 27/16, 56/33, 12/7, 512/297, 7/4, 99/56, 16/9, 231/128, 21/11, 27/14, 64/33, 63/32, 196/99, 2/1
    }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46 }
    rootFreq

chromaxial22 :: Float -> Scale 23 22
chromaxial22 rootFreq =
  Scale
    { 1/1, 2079/2048, 49/48, 33/32, 1089/1024, 147/128, 7/6, 9801/8192, 77/64, 21/16, 693/512, 49/36, 11/8, 363/256, 49/32, 99/64, 3267/2048, 77/48, 441/256, 7/4, 231/128, 121/64, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 }
    rootFreq

chromaxial17 :: Float -> Scale 18 17
chromaxial17 rootFreq =
  Scale
    { 1/1, 49/48, 33/32, 1089/1024, 147/128, 7/6, 77/64, 21/16, 693/512, 11/8, 363/256, 49/32, 99/64, 77/48, 7/4, 231/128, 121/64, 2/1 }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }
    rootFreq

enharmaxial1 :: Float -> Scale 48 47
enharmaxial1 rootFreq =
  Scale
    {
      1/1, 2079/2048, 49/48, 33/32, 68609/65536, 539/512, 1089/1024, 9/8, 18711/16384, 147/128, 297/256, 7/6, 33/28, 9801/8192, 77/64, 14/11, 1323/1024, 343/264, 21/16, 43659/32768, 343/256,
      693/512, 49/36, 11/8, 22869/16384, 539/384, 363/256, 3/2, 6237/4096, 49/32, 99/64, 14/9, 11/7, 3267/2048, 77/48, 56/33, 441/256, 343/198, 7/4, 14533/8192, 343/192, 231/128, 49/27, 11/6,
      7623/4096, 539/288, 121/64, 2/1
    }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46 }
    rootFreq

enharmaxial2 :: Float -> Scale 48 47
enharmaxial2 rootFreq =
  Scale
    {
      1/1, 2079/2048, 49/48, 33/32, 68609/65536, 539/512, 1089/1024, 9/8, 18711/16384, 147/128, 297/256, 7/6, 4851/4096, 9801/8192, 77/64, 160083/131072, 1323/1024, 2673/2048, 21/16, 43659/32768,
      88209/65536, 693/512, 49/36, 11/8, 22869/16384, 539/384, 363/256, 3/2, 6237/4096, 49/32, 99/64, 14/9, 1617/1024, 3267/2048, 77/48, 53361/32768, 441/256, 891/512, 7/4, 14533/8192, 29403/16384,
      231/128, 49/27, 11/6, 7623/4096, 539/288, 121/64, 2/1
    }
    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46 }
    rootFreq

enharmaxialPentatonic1 :: Float -> Scale 6 5
enharmaxialPentatonic1 rootFreq =
  Scale
    { 1/1, 9/8, 14/11, 3/2, 56/33, 2/1 }
    { 0, 1, 2, 3, 4 }
    rootFreq

enharmaxialPentatonic2 :: Float -> Scale 6 5
enharmaxialPentatonic2 rootFreq =
  Scale
    { 1/1, 9/8, 1323/1024, 3/2, 441/256, 2/1 }
    { 0, 1, 2, 3, 4 }
    rootFreq

enharmaxialPentatonic3 :: Float -> Scale 6 5
enharmaxialPentatonic3 rootFreq =
  Scale
    { 1/1, 8/7, 21/16, 32/21, 7/4, 2/1 }
    { 0, 1, 2, 3, 4 }
    rootFreq
----------------------------------------------------------------------
----------------------------------------------------------------------

degreeToFrequency :: Scale t d -> Int -> Float
degreeToFrequency (Scale tuning degrees rootFreq) degree =
  pitch * octave * rootFreq
  where
    numTuningFreqs   = (arrayLength NatVal tuning - 1) |> max 1 -- subtract 1 as the last tuning frequency is the scale repetition ratio
    scaleRepeatRatio = lookupArray numTuningFreqs tuning |> unwrapOr 0
    numDegrees       = arrayLength NatVal degrees |> fromUInt
    octave           = fromInt degree / fromInt numDegrees |> floor |> pow scaleRepeatRatio
    degreeRem        = rem degree numDegrees
    degreeWrap       = if degreeRem < 0 then degreeRem + numDegrees else degreeRem
    degree'          = rem (lookupArray (fromInt degreeWrap) degrees |> unwrapOr 0) numTuningFreqs
    pitch            = lookupArray degree' tuning |> unwrapOr 0

d2f :: Scale t d -> Int -> Float
d2f = degreeToFrequency

testJit :: *World -> *World
testJit w = plotFFTOnce "fftOut.dat" fftOut w
  where
    fftOut :: Mono (FFT 1)
    fftOut = fft p
    p =
      pluck nat8 50 1.0 +
      pluck nat4 100 1.0

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 p w
--   where
--     p =
--       pluck nat8 50 1.0 +
--       pluck nat4 100 1.0
--       |> pan 0.5
--       |> mul 0.1

-- -- Look into alternative to euler method...
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 4 4 4
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# (x * 0.1) (y * 0.3) (z * -0.6), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s, sine (x * 200)#)
--     a =
--       luChenAttractor size ifn mfn 36 3 20 -15.5 1
--       |> perc 10 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 1 1 1
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# -1 0 0.5 + Vector3D# (x * 0.05) (y * 0.05) (z * 0.05), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s, sine ((x * 4000) + sine (y * 4000) + sine (z * 4000))#)
--     a =
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.5 0.75) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.6 0.7) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.4 0.8) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.3 0.85)
--       |> delay oneSec 0.125 0.25
--       |> perc 10 20 -1
--       |> mul 0.05

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     freqMul1  = sin 0.2  *  0.0035 + sin 0.6 *  0.00025 + 0.5
--     freqMul2  = sin 0.14 *  0.0035 + sin 0.5 * -0.00025 + 0.5
--     freqMul3  = sin 0.23 * -0.0035 + sin 0.4 *  0.00025 + 0.5
--     beatSpeed = 3 // 2
--     badBeat1  = seqSpeed beatSpeed [200 _ 300 <_ 350> 200 400 _ 600 <_ [350:700]> [300:800]]
--     badBeat2  = seqSpeed beatSpeed ([400 _ 600 <_ 700> <_ 1200> [1400:1350]] @* (seqSpeed (1 // 9) [_ _ _ _ 0.25 0.5 0.75 1 1.5]))
--     badBeat3  = seqSpeed (beatSpeed / 8) [100 60 75 100 60 75 80]
--     badSynth1 f =
--       tri (fromFloat f * 0.501) + tri (fromFloat f * freqMul1 + tri 1.33334 * 3) + (sin (fromFloat f) * 0.75)
--       |> mul 0.11
--       |> perc 0.005 2.5 -3.75
--       |> pan 0.375
--     badSynth2 f =
--       tri (fromFloat f * freqMul3 * 2.02) + tri (fromFloat f * 0.998) + (pulse (freqMul1 - 0.175) (fromFloat f * freqMul2 + tri 2.0 * 3) * 0.3)
--       |> mul 0.09
--       |> perc 0.01 3.5 -2.75
--       |> pan 0.625
--     bassSynth f =
--       sin (fromFloat (f * 0.5)) + (0.5 * (tri (fromFloat f - 0.1) + tri (fromFloat f * freqMul1 * 2) + tri (fromFloat f * (1 - freqMul3)) + tri (fromFloat (f * 0.5))))
--       |> mul 0.1
--       |> perc 0.005 5 -1.8
--       |> mixStereo
--     synths =
--       poly badSynth1 badBeat1 +
--       poly badSynth2 badBeat2
--       |> delay oneSec 0.6666667 0.6
--     badAudio =
--       poly bassSynth badBeat3 +
--       synths

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
-- 		  |> printLn (bitNot one |> bitAnd (fromBits negativeBit |> bitNot))
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> bitAnd (bitNot negativeBit |> fromBits)
--     -- unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print negativeBit
--           |> print " -> "
--           |> print negativeOne
--           |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits
--

-- bitOneOne = bitAnd (bitXor (-1) negativeBit) bitOne |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w |> print " -> " |> print bitOne |> print " -> " |> print bitOneOne |> printLn " "
--   where
--     one :: Float
--     one = 1
--     -- negativeBit :: UInt
--     -- negativeBit = bitShiftRight 1 63
--     bitOne = bitShiftLeft one 2
--     bitOneOne = bitShiftRight bitOne 2
--
-- testJit :: *World -> *World
-- testJit w = print f64 w |> print " -> " |> print rF64 |> print " -> " |> print rrF64 |> printLn " "
--   where
--     f64 :: Float
--     f64 = pi
--     rF64 = bitReverse f64
--     rrF64 = bitReverse rF64
--

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     s = seqToAudio <| seqSpeed 4 [3 1 2 <4 3>]
--     t = seqToAudio <| seqSpeed 2 [0.5 1 2 <4 3>]
--     a =
--       pulse 0.125 (440 * stereo s t)
--       |> mul 0.125
--       |> pan 0.5

-- testJit :: *World -> *World
-- testJit w = printLn f64 w |> printLn (bitReverse f64) |> printLn (bitReverse <| bitReverse f64)
--   where
--     f64 :: F64
--     f64 = 5


-----------------------------------------
-- Trig and Complex numbers testing
-- TODO: Move this junk into a separate test file!

printArraySpaced :: Print a => Array n a -> *World -> *World
printArraySpaced a w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    printLoop lw = loop w' = lw for i <- each do
      (print (readArray i a) w' |> printNewline)

printTupleArraySpaced :: (Print a, Print b) => Array n (a, b) -> *World -> *World
printTupleArraySpaced a w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    printLoop lw = loop w' = lw for i <- each do
      (printTuple (readArray i a) w' |> printNewline)

mathTestFloat :: (Float -> Float) -> *World -> *World
mathTestFloat f w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    i2Fs i = (i', f i')
      where
        i' = (fromUInt i - 32) / 32
    a :: Array 64 (Float, Float)
    a = mkArray i2Fs
    printLoop lw =
      loop w' = lw for i <- each do
        (printTuple (readArray i a) w' |> printNewline)

mathTest2D :: (Float -> Float -> Float) -> *World -> *World
mathTest2D f w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    a :: Array 8 Float
    a = mkArray (\i -> (fromUInt i - 4) / 4)
    printLoop lw =
      loop w' = lw for i <- each do
        loop w'' = w' for j <- each do
          let
            fa = readArray i a
            fb = readArray j a
          in
            printTuple (fa, fb) w''
            |> print ' '
            |> print (f fa fb)
            |> printNewline

testComplexArray :: Array 64 Complex
testComplexArray = c
  where
    a :: Array 64 (UInt, Float)
    a = mkArray (\i -> (i, (fromUInt i - 32) / 32))
    c :: Array 64 Complex
    c = map (\(u, f) -> Complex# f (rem (f + fromUInt (u * 2)) 1.0)) a

testComplexTupleArray :: Array 64 (Complex, Complex)
testComplexTupleArray = c
  where
    a :: Array 64 (UInt, Float)
    a = mkArray (\i -> (i, (fromUInt i - 32) / 32))
    ufToComplex u f = Complex# f (rem (f + fromUInt (u * 2)) 1.0)
    c :: Array 64 (Complex, Complex)
    c = map (\(u, f) -> (ufToComplex u f, ufToComplex (64 - u) (1 - f))) a

complexCisTest :: *World -> *World
complexCisTest w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    a :: Array 64 Float
    a = mkArray (\i -> ((fromUInt i - 32) / 32))
    printLoop lw =
      loop w' = lw for i <- each do
        ((print (readArray i a) w') |> printChar ' ' |> (print (cis (readArray i a))) |> printNewline)

complexToPrintableTest :: Print a => (Complex -> a) -> *World -> *World
complexToPrintableTest f w = printArraySpaced (map f testComplexArray) w

complexByComplexTest :: (Complex -> Complex -> Complex) -> *World -> *World
complexByComplexTest f w = printArraySpaced (map complexByComplex testComplexTupleArray) w
  where
    complexByComplex :: (Complex, Complex) -> Complex
    complexByComplex t = case t of
      (a, b) -> f a b

-- TODO: Move this junk into a separate test file!
-- Chad Test!
-- testJit :: *World -> *World
-- testJit w =
-- 	print "fmouse: " w
--     |> printLn fMouse
--     |> print "tan: "
--     |> mathTestFloat tanF64
--     |> print "atan: "
--     |> mathTestFloat atanF64
--     |> print "atan2: "
--     |> mathTest2D atan2
--     |> print "sineh: "
--     |> mathTestFloat sineh
--     |> print "cosineh: "
--     |> mathTestFloat cosineh
--     |> print "testComplexArray: "
--     |> print testComplexArray |> printNewline
--     |> print "cis<complex>: "
--     |> complexCisTest
--     |> print "polar<complex>: "
--     |> printTupleArraySpaced (map polar testComplexArray)
--     |> print "sqrMagnitude<complex>: "
--     |> complexToPrintableTest sqrMagnitude
--     |> print "magnitude<complex>: "
--     |> complexToPrintableTest magnitude
--     |> print "conjugate<complex>: "
--     |> complexToPrintableTest conjugate
--     |> print "phase<complex>: "
--     |> complexToPrintableTest phase
--     |> print "sine<complex>: "
--     |> complexToPrintableTest sine
--     |> print "cosine<complex>: "
--     |> complexToPrintableTest cosine
--     |> print "sineh<complex>: "
--     |> complexToPrintableTest sineh
--     |> print "cosineh<complex>: "
--     |> complexToPrintableTest cosineh
--     |> print "exp<complex>: "
--     |> complexToPrintableTest exp
--     |> print "exp2<complex>: "
--     |> complexToPrintableTest exp2
--     |> print "log<complex>: "
--     |> complexToPrintableTest log
--     |> print "log2<complex>: "
--     |> complexToPrintableTest log2
--     |> print "log10<complex>: "
--     |> complexToPrintableTest log10
--     |> print "sqrt<complex>: "
--     |> complexToPrintableTest sqrt
--     |> print "testComplexTupleArray"
--     |> printTupleArraySpaced testComplexTupleArray |> printNewline
--     |> print "pow<complex>: "
--     |> complexByComplexTest pow
--     |> print "atan2<complex>: "
--     |> complexByComplexTest atan2
--     |> testAssertion True
--   where
--     fMouse = fromInt mouseX

-- testJit :: *World -> *World
-- testJit w =
-- 	print "fmouse: " w
--     |> printLn fMouse
--     |> print "tan -1.8125: "
--     |> printLn (tanF64 -1.8125)
--     |> print "tanF64: "
--     |> printLn (tanF64 fMouse)
--     |> print "atanF64: "
--     |> printLn (atanF64 fMouse)
--     |> print "slowAtanF64: "
--     |> printLn (slowAtanF64 fMouse)
--     |> print "atanF64 -1.8125: "
--     |> printLn (atanF64 -1.8125)
--     |> print "slowAtanF64 -1.8125 "
--     |> printLn (slowAtanF64 -1.8125)
--     |> print "tan -17000: "
--     |> printLn (tanF64 -17000)
--     |> print "sinh -0.0000266618125: "
--     |> printLn (sineh -0.0000266618125)
--     |> print "sinh -0.0266618125: "
--     |> printLn (sineh -0.0266618125)
--     |> print "sinh -0.166618125: "
--     |> printLn (sineh -0.166618125)
--     |> print "sinh -1.133718125: "
--     |> printLn (sineh -1.133718125)
--     |> print "sinh -3.1133718125: "
--     |> printLn (sineh -3.1133718125)
--     |> print "sinh -7: "
--     |> printLn (sineh -7)
--     |> print "sinh -13.9133718125: "
--     |> printLn (sineh -13.9133718125)
--     |> print "sineh: "
--     |> printLn (sineh fMouse)
--     |> print "cosh -0.0266618125: "
--     |> printLn (cosineh -0.0266618125)
--     |> print "cosh -0.166618125: "
--     |> printLn (cosineh -0.166618125)
--     |> print "cosh -1.133718125: "
--     |> printLn (cosineh -1.133718125)
--     |> print "cosh -3.1133718125: "
--     |> printLn (cosineh -3.1133718125)
--     |> print "cosh -7: "
--     |> printLn (cosineh -7)
--     |> print "cosh -13.9133718125: "
--     |> printLn (cosineh -13.9133718125)
--     |> print "cosineh: "
--     |> printLn (cosineh fMouse)
--     |> print "exp (2 + 3i): "
--     |> printLn (exp (Complex# 2 3))
--     |> print "exp2 (2 + 3i): "
--     |> printLn (exp2 (Complex# 2 3))
--     |> print "log (2 + 3i): "
--     |> printLn (log (Complex# 2 3))
--     |> print "log2 (2 + 3i): "
--     |> printLn (log2 (Complex# 2 3))
--     |> print "log10 (2 + 3i): "
--     |> printLn (log10 (Complex# 2 3))
--   where
--     fMouse = fromInt mouseX

--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# 8 2
--     b = Complex# 2 1
--     c = sqrt (Complex# (negate 3.4) pi)
--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# (negate pi) 3
--     b = Complex# 3 4
--     c = a / b


-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]
-- TODO: Move all this junk into a separate Seq test file!

-- TODO: Nat valued constants where the number is applied as a Nat kind
--       to a Type Constructor with a single Unit data constructor, such as NatlVal or Seconds,
--       i.e.:
--          1! :: NatVal 1
--          2! :: Seconds 2
--          3! :: NatVal 3
--          etc
-- TODO: Had to remove HOF caching because the current one over shared causing very bad issues. Find a correct fix
-- TODO: Simultaneous synths panned in the middle cause weird FM?!?!!?!?
-- TODO: Test arg copying

-- TODO: Make seqRepeat repetitions parameter a Seq value
-- TODO: Make seqStutter repetitions parameter a Seq value
-- TODO: (BUG) Comments after where and let break the parser
-- TODO / NOTE: Possible FFT bug fix: Use global block count counter for FFT counters!!!!
-- TODO: Seq lambda lifting bug and/or pure type checking isn't GREAT
-- TODO: Look at copying logic for poly + boxed types (even boxed types nested into unboxed types)
-- TODO: ARRAYS NEED TO BE DEEP COPIED IN STATEFUL VALUES
-- TODO: (BUG) bpf seems broken?
-- TODO: (BUG) Array literals in where statements seems to break type inference? Investigate
-- TODO  (BUG) Poly instance bug, constraints are not properly required
-- TODO: Negative values in d2f not working properly
-- TODO: Softsync Oscillators
-- TODO: optimize perc?
-- TODO: Waveterrain oscillators? Table based? Function Based? Both? Trajectory combinators, etc
-- TODO: Sphereterrain oscillators? Table based? Function Base? Both?
-- TODO: Cepstrum analysis / signal processing?
-- TODO: Loading Audio Files
-- TODO: Comb Filters, All Pass Filters, etc
-- TODO: mandelbulb + strange attractors + delauney triangulation
-- TODO: phase distortion synthesis
-- TODO: Looks like maybe the precedence between (+) and (*) and (|>) is a little wonky?
-- TODO: Multiplication precedence is WRONG!!!!
-- TODO: Generic env
-- TODO: Clipping detection
-- TODO: Set audioSampleOffset to NOT be constant and insure that it is never used at a global scope!!!!! (It is magical...)
-- TODO: Nested case literals seem broken!
-- TODO: Out of order monomorphic instances (i.e. 'instance Ring Complex' textually appearing before 'instance Ring F64') can cause erroneous 'Not An Instance' errors. Maybe need a better dep analysis story to make this work since we don't figure this out until inference which is at that point too late to fix.
-- TODO: Write to log file, perhaps class Log a similar to class Print a
-- TODO: Look at all the .i.i.i weirdness in llvm names???

-- TODO: Optimize const expr globals
-- TODO: Memory access test audio stuff!
-- TODO: type sig coerce constraint!
-- TODO: Put constant check on initializers, not in type signatures. It doesn't need to be in the type system to be checked! Then we can nix Default for Monoid?
-- TODO: Compiler breaks down when a Non-Type kinded type is used in a class declaration!
-- TODO: Immutable and Mutable (Unique) FFT API

-- TODO: Concept of Constant Values somehow being worked into the type system for things like default and mutRef
-- TODO: Inline compose operators! .> and <.
-- TODO: Perhaps function caching is getting off, need more accurate check for HOF caching!
-- TODO: Replace Default with Monoid?
-- TODO: Need partial recursive values to get rid of monoid here
-- TODO: Partially recursive values
-- TODO: Use List type syntax for Sequences?
-- TODO: Partially recursive values
-- TODO: Defunctionalization of function on data structures
-- TODO: Stateful Pattern assignment

-- Sound ideas
--     * Percussive simulations
--     * Strange attractors in FFT?
--     * Cool FFT effects we used: Convolution with voices, Long time stretching


