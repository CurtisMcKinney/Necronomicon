--------------------
-- Necro.Base
--------------------

-- Math constants
pi :: Floating a => a
pi = 3.1415926535897932384626433

twoPi :: Floating a => a
twoPi = pi * 2

twoOverPi :: Floating a => a
twoOverPi = 2 / pi

halfPi :: Floating a => a
halfPi = pi * 0.5

threeHalfPi :: Floating a => a
threeHalfPi = 3 * halfPi

fourOverPi :: Floating a => a
fourOverPi = 4 / pi

quarterPi :: Floating a => a
quarterPi = pi * 0.25

sixthPi :: Floating a => a
sixthPi = pi / 6

twelthPi :: Floating a => a
twelthPi = pi / 12

tanSixthPi :: Float
tanSixthPi = tanF64 sixthPi

tanTwelthPi :: Float
tanTwelthPi = tanF64 twelthPi

tau :: Floating a => a
tau = 2 * pi

recipPi :: Floating a => a
recipPi = 1 / pi

recipTau :: Floating a => a
recipTau = 1 / tau

recipTwoPi :: Floating a => a
recipTwoPi = recipTau

-- -- TODO: Move into tests!
-- data ETest1 a     = ETest1 (Maybe a)
-- data ETest2 a     = ETest2 (Bool, Maybe a)
-- data ETest3 a     = ETest3 (Maybe (Bool, Maybe a))
-- data T3feri a b c = T3feri (a, a) (b, b) (c, c)
-- data HKT  t a     = HKT  (t a)
-- data HTest  a b   = HTest (Maybe a) (Maybe b) (Either a b)
-- data HKT2 t a b   = HKT2 (t a b)

testAssertion :: Bool -> *World -> *World
testAssertion b w = primUndefined

panic :: UInt -> UInt
panic x = primUndefined

boundsCheck :: UInt -> UInt -> UInt
boundsCheck index capacity =
    index
    -- |> traceLn "bounds check FAILED:"
    -- |> trace "| "
    -- |> traceLn str
    -- |> trace "| index:    "
    -- |> traceLn index
    -- |> trace "| capacity: "
    -- |> traceLn capacity
    -- |> traceLn " "
    |> panic

-- testAndPrintAssertion :: (Print a, Eq a) => a -> a -> *World -> *World
-- testAndPrintAssertion x y w = testAssertion (x == y) <| printLn x w

boolToInt :: Bool -> Int
boolToInt b = primUndefined

id :: .a -> .a
id x = x

fst :: (.a, .b) -> .a
fst (x, _) = x

snd :: (.a, .b) -> .b
snd (_, y) = y

fst' :: (#.a, .b#) -> .a
fst' (#x, _#) = x

snd' :: (#.a, .b#) -> .b
snd' (#_, y#) = y

fst3 :: (.a, .b, .c) -> .a
fst3 (x, _, _) = x

snd3 :: (.a, .b, .c) -> .b
snd3 (_, y, _) = y

thd3 :: (.a, .b, .c) -> .c
thd3 (_, _, z) = z

fst3' :: (#.a, .b, .c#) -> .a
fst3' (#x, _, _#) = x

snd3' :: (#.a, .b, .c#) -> .b
snd3' (#_, y, _#) = y

thd3' :: (#.a, .b, .c#) -> .c
thd3' (#_, _, z#) = z

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  if x < y then
    x
  else
    y

-- TODO: Fold into Ord class
max :: Ord a => a -> a -> a
max x y =
  if x > y then
    x
  else
    y

clamp :: Ord a => a -> a -> a -> a
clamp x low high =
  max (min x high) low

uncurry :: .(.a -> .b -> .c) -> (.a, .b) -> .c
uncurry f (x, y) = f x y

uncurry3 :: .(.a -> .b -> .c -> .d) -> (.a, .b, .c) -> .d
uncurry3 f (x, y, z) = f x y z

uncurry' :: .(.a -> .b -> .c) -> (#.a, .b#) -> .c
uncurry' f (#x, y#) = f x y

uncurry3' :: .(.a -> .b -> .c -> .d) -> (#.a, .b, .c#) -> .d
uncurry3' f (#x, y, z#) = f x y z

mouseX :: Int
mouseX = getMouseX ()

mouseY :: Int
mouseY = getMouseY ()

asTypeOf :: a -> a -> a
asTypeOf x _ = x

asTypeOfU :: *a -> *a -> (#*a, *a#)
asTypeOfU x y = (#x, y#)




----------------------
-- Bool
----------------------
data Bool = False | True

-- TODO: primitive for not
not :: .Bool -> .Bool
not b =
  case b of
    True  -> False
    False -> True


----------------------
-- Some Base Classes
----------------------

class Print a where
  print :: a -> *World -> *World

class Semigroup m where
  append :: m -> m -> m

class Semigroup m => Monoid m where
  mempty :: m

class Functor f where
  map :: (a -> b) -> f a -> f b

class UFunctor f where
  umap :: .(.a -> .b) -> f .a -> f .b

class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c
  map3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  map4 :: (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  -- TODO: map4, etc

class Functor f => Applicative f where
  pure :: a -> f a
  ap   :: f (a -> b) -> f a -> f b

class Applicative m => Monad m where
  bind :: m a -> (a -> m b) -> m b

class Applicative f => Alternative f where
  empty       :: f a
  alternative :: f a -> f a -> f a

-- TODO: Implement Bifunctor
-- class Bifunctor f where
--   bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
--   mapFst
--   mapSnd

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

class Foldable f where
  fold   :: Monoid m => f m -> m
  foldl  :: (.b -> a -> .b) -> .b -> .f a -> .b

class Eq a where
  eq  :: a -> a -> Bool
  neq :: a -> a -> Bool

class Eq a => Ord a where
  lt  :: a -> a -> Bool
  gt  :: a -> a -> Bool
  lte :: a -> a -> Bool
  gte :: a -> a -> Bool

class Default a where
  default :: a

printUInt :: UInt -> *World -> *World
printUInt u w = w

printInt :: Int -> *World -> *World
printInt i w = w

printFloat :: Float -> *World -> *World
printFloat i w = w

printChar :: Char -> *World -> *World
printChar c w = w

printTuple :: (Print a, Print b) => (a, b) -> *World -> *World
printTuple t w = case t of
  (a, b) -> print '(' w |> print a |> print ", " |> print b |> print ')'

printNewline :: *World -> *World
printNewline w = printChar '\n' w

instance Print UInt where
  print x w = printUInt x w

instance Print Int where
  print x w = printInt x w

instance Print Float where
  print x w = printFloat x w

instance Print Char where
  print x w = printChar x w

printLn :: Print a => a -> *World -> *World
printLn x w =
  printNewline (print x w)

trace :: Print a => a -> .b -> .b
trace x y =
  case print x primUndefined of
    _ -> y

traceLn :: Print a => a -> .b -> .b
traceLn x y =
  case printLn x primUndefined of
    _ -> y

traceLn2 :: (Print a, Print b) => a -> b -> b
traceLn2 x y =
  case print x primUndefined of
    w ->
      case printLn y w of
        _ -> y

----------------------
-- File IO
----------------------

data File = File

arrayLength :: NatVal n -> Array n a -> UInt
arrayLength n _ = natVal n

-- arrayLengthU :: NatVal n -> .Array n a -> (#UInt, .Array n a#)
arrayLengthU n arr = (#natVal n, arr#)

arrayLengthFromIndex :: NatVal n -> Index n -> UInt
arrayLengthFromIndex n _ = natVal n

unsafeArrayToPtr :: Array n .a -> Ptr .a
unsafeArrayToPtr a = primUndefined

deepCopyArray :: Array n a -> .Array n a
deepCopyArray arr = freezeArray arr2
  where
    arr2 =
      loop arr2 = unsafeEmptyArray () for i <- each do
        writeArray i (readArray i arr) arr2

unsafeOpenFile :: Ptr Char -> UInt -> *File
unsafeOpenFile fileName fileNameLength = primUndefined

openFile :: Array n Char -> *World -> (*File, *World)
openFile fileName w =
  (unsafeOpenFile (unsafeArrayToPtr fileName) (arrayLength NatVal fileName), w)

closeFile :: *File -> ()
closeFile f = primUndefined

writeIntToFile :: Int -> *File -> *File
writeIntToFile x f = primUndefined

writeUIntToFile :: UInt -> *File -> *File
writeUIntToFile x f = primUndefined

writeFloatToFile :: Float -> *File -> *File
writeFloatToFile x f = primUndefined

writeCharToFile :: Char -> *File -> *File
writeCharToFile x f = primUndefined

writeStringToFile :: Array n Char -> *File -> *File
writeStringToFile str file =
  loop f = file for i <- each do
    writeCharToFile (readArray i str) f

writePlot2DToFileOnce :: Array s Char -> Array n Float -> *World -> *World
writePlot2DToFileOnce name dat w0 =
  if epoch > 1 then
    w0
  else
    let
      (f0, w1) = openFile name w0
      f1       =
        loop f = f0 for i <- each do
          writeUIntToFile (indexToUInt i) f
          |> writeCharToFile ' '
          |> writeFloatToFile (readArray i dat)
          |> writeCharToFile '\n'
    in
      case closeFile f1 of
        _ -> printLn "Done writing file" w1
  where
    epoch ~ 0 = epoch + 1

----------------------
-- Numeric Hierarchy
----------------------
class Semiring a where
  zero :: a
  one  :: a
  add  :: a -> a -> a
  mul  :: a -> a -> a

class Semiring a => Ring a where
  sub     :: a -> a -> a
  fromInt :: Int -> a

class Ring a => DivisionRing a where
  recip :: a -> a

class Ring a => EuclideanRing a where
  div :: a -> a -> a
  rem :: a -> a -> a
  -- mod :: a -> a -> a

class (EuclideanRing a, DivisionRing a) => Field a where

class (Eq a, Ring a) => Num a where
  abs      :: a -> a
  signum   :: a -> a
  copysign :: a -> a -> a

class (Num a, EuclideanRing a) => Integral a where
  -- quotient :: a -> a -> a

class (Num a, Field a) => Floating a where
  fromFloat :: Float -> a
  sqrt :: a -> a
  floor :: a -> a
  ceil :: a -> a
  truncate :: a -> a
  round :: a -> a
  -- fmin :: a -> a -> a -- TODO: Remove these for Ord instances once min/max is in Ord
  -- fmax :: a -> a -> a

class Floating a => Trig a where
  sine     :: a -> a
  cosine   :: a -> a
  -- tan      :: a -> a
  -- asine    :: a -> a
  -- acosine  :: a -> a
  -- atan     :: a -> a
  atan2    :: a -> a -> a
  sineh    :: a -> a
  cosineh  :: a -> a
  -- tanh     :: a -> a
  -- asineh   :: a -> a
  -- acosineh :: a -> a
  -- atanh    :: a -> a
  -- atanh2   :: a -> a -> a
  exp      :: a -> a
  exp2     :: a -> a
  log      :: a -> a
  log10    :: a -> a
  log2     :: a -> a
  pow      :: a -> a -> a

  -- atan      :: a -> a
  -- floor'    :: Integral b => a -> b
  -- ceil'     :: Integral b => a -> b

-- toFloating :: (Num' a, Floating b) => a -> b
-- toFloating = fromRational' <. toRational


class Bits a where
  bitAnd         :: a -> a -> a
  bitNot         :: a -> a
  bitOr          :: a -> a -> a
  bitXor         :: a -> a -> a
  bitShiftLeft   :: a -> UInt -> a
  bitShiftRight  :: a -> UInt -> a -- logical right shift
  bitShiftRightA :: a -> UInt -> a -- arithmetic right shift
  bitReverse     :: a -> a
  toBits         :: a -> UInt
  fromBits       :: UInt -> a

sqr :: Semiring a => a -> a
sqr n = n * n

--------------------
-- ()
--------------------
-- TODO: Can't currently parse () in an instance head!
-- instance Eq () where
--   eq  _ _ = True
--   neq _ _ = False
--
-- instance Ord () where
--   lt  _ _ = False
--   gt  _ _ = False
--   lte _ _ = True
--   gte _ _ = True


--------------------
-- Bool
--------------------
instance Eq Bool where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Bool where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

instance Semiring Bool where
  zero    = False
  one     = True
  add x y = x || y
  mul x y = x && y

instance Semigroup Bool where
  append x y = x || y

instance Monoid Bool where
  mempty = False

instance Default Bool where
  default = True


--------------------
-- Int
--------------------
instance Eq Int where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Int where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Int where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Int where
  sub   x y = primUndefined
  fromInt x = x

instance EuclideanRing Int where
  div x y = primUndefined
  rem x y = primUndefined

instance Num Int where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x sign = (abs x) * (signum sign)

instance Integral Int where

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Default Int where
  default = 0


--------------------
-- UInt
-- NOTE: that this is the traditional programming language concept of an unsigned integer (with its idiosyncrasies) and not the more mathematically defined set of Natural Numbers
--------------------
instance Eq UInt where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord UInt where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring UInt where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring UInt where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance EuclideanRing UInt where
  div x y = primUndefined
  rem x y = primUndefined

instance Num UInt where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x _ = x

instance Integral UInt where

instance Bits UInt where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = x
  fromBits       x   = x

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Default UInt where
  default = 0

uintToInt :: UInt -> Int
uintToInt x = primUndefined

fromUInt :: Ring a => UInt -> a
fromUInt x = fromInt (uintToInt x)


--------------------
-- Float
--------------------
instance Eq Float where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Float where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Float where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Float where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num Float where
  abs    x = primUndefined
  copysign x sign = primUndefined
  signum x = if x == 0 then 0 else copysign 1 x

instance EuclideanRing Float where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing Float where
  recip x = 1 / x

instance Field Float where

instance Floating Float where
  fromFloat x = x
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined
  -- fmin      x y = primUndefined
  -- fmax      x y = primUndefined

lerp :: Floating a => a -> a -> Float -> a
lerp x y deltaF =
  (x * (1 - delta)) + (y * delta)
  where
    delta = fromFloat deltaF

cerp :: Floating a => a -> a -> a -> a -> Float -> a
cerp x0 x1 x2 x3 deltaF =
  (a0 * delta * delta2) + ((a1 * delta2) + (a2 * delta) + a3)
  where
    delta  = fromFloat deltaF
    delta2 = delta * delta
    a0     = x3 - x2 - x0 + x1
    a1     = x0 - x1 - a0
    a2     = x2 - x0
    a3     = x1



----------------------------------------
-- Trig Approximation Functions
----------------------------------------

-- -- How to deal with Float maybe 64 vs 32 bit?
-- tanF32 :: Float -> Float
-- tanF32 n = tanResult
--   where
--     x = rem n twoPi
--     octant = floor <| (x * fourOverPi)
--     -- HACK -> Need to be able to convert from Float to
--     octantInt = if octant < 1 then 0
--       else if octant < 2 then 1
--       else if octant < 3 then 2
--       else if octant < 4 then 3
--       else if octant < 5 then 4
--       else if octant < 6 then 5
--       else if octant < 7 then 6
--       else 7
--     -- Accurate to about 8.2 decimal digits over the range (0, pi/4)
--     -- This computes tan (pi * x/4), range reduction must be used before input
--     tan82 x = (x * (c1 + c2 * x2) / (c3 + x2 * (c4 + x2)))
--       where
--         c1 = 211.849369664121
--         c2 = -12.5288887278448
--         c3 = 269.7350131214121
--         c4 = -71.4145309347748
--         x2 = (x * x)
--     tanResult = case octantInt of
--       0 -> tan82 (x * fourOverPi)
--       1 -> 1 / (tan82 ((halfPi - x) * fourOverPi))
--       2 -> -1 / (tan82 ((x - halfPi) * fourOverPi))
--       3 -> negate <| tan82 ((pi - x) * fourOverPi)
--       4 -> tan82 ((x - pi) * fourOverPi)
--       5 -> 1 / (tan82 ((threeHalfPi - x) * fourOverPi))
--       6 -> -1 / (tan82 ((x - threeHalfPi) * fourOverPi))
--       7 -> negate <| tan82 ((twoPi - x) * fourOverPi)
--       _ -> 0 -- ?!?

tanF64 :: Float -> Float
tanF64 n = tanResult
  where
    wrappedN = rem n twoPi
    twoPiN = twoPi + wrappedN
    x = if wrappedN < 0 then twoPiN else wrappedN
    -- TODO: investigate alternatives like masking etc..
    -- signMask = bitShiftRightA wrappedN 63
    -- x = wrappedN + (bitAnd (twoPi - wrappedN - wrappedN) signMask)
    -- x = rem wrappedN twoPi
    octant = truncateToInt <| (x * fourOverPi)
    -- Accurate to about 14 decimal digits over the range (0, pi/4)
    -- This computes tan (pi * x/4), range reduction must be used before input
    tan14s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = -34287.4662577359568109624
        c2 = 2566.7175462315050423295
        c3 = -26.5366371951731325438
        c4 = -43656.1579281292375769579
        c5 = 12244.4839556747426927793
        c6 = -336.611376245464339493
        x2 = (x * x)
    tanResult = case octant of
      0 -> tan14s (x * fourOverPi)
      1 -> 1 / (tan14s ((halfPi - x) * fourOverPi))
      2 -> -1 / (tan14s ((x - halfPi) * fourOverPi))
      3 -> negate <| tan14s ((pi - x) * fourOverPi)
      4 -> tan14s ((x - pi) * fourOverPi)
      5 -> 1 / (tan14s ((threeHalfPi - x) * fourOverPi))
      6 -> -1 / (tan14s ((x - threeHalfPi) * fourOverPi))
      7 -> negate <| tan14s ((twoPi - x) * fourOverPi)
      _ -> 0 -- ?!?


-- create a scalar for branchless selection if x > y
scalarIfGreaterThan :: Float -> Float -> Float
scalarIfGreaterThan x y = bitAnd subtractionMask 1
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF
    subtractionMask = bitShiftRightA subtractionSign 63

-- create a mask (0xFFFFFFFFFFFFFFFF or 0x0000000000000000) for branchless masking if x > y
maskIfGreaterThan :: Float -> Float -> Float
maskIfGreaterThan x y = bitShiftRightA subtractionSign 63
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF

-- Various resources for chebyshev approximation of functions:
-- http://www.ganssle.com/approx.htm
-- Computer Approximations by John Hart
-- Constrained Chebyshev Approximations to Some Elementary Functions Suitable for Evaluation with Floating-point Arithmetic
-- *** ^ note the coefficients tables starting on page 18 ***
-- For general approximation this is a useful resource
-- https://github.com/chebfun/chebfun
-- https://people.maths.ox.ac.uk/trefethen/ATAP/ATAPfirst6chapters.pdf

sinhConstant = log ((1 + (sqrt 5)) / 2)

-- More accurate at extremes of ranges?
sinh64_accurate :: Float -> Float
sinh64_accurate n = copysign z n
  where
    y = (abs n) - sinhConstant
    z = expY + ((expV / 2 - 1) * expY) - ((expNegV / 2) * expNegY)
    expV = exp sinhConstant
    expNegV = exp (negate sinhConstant)
    expY = exp y
    expNegY = exp (negate y)

-- sinh64_broken :: Float -> Float
-- sinh64_broken n = sinh_193s
--   where
--     l = log ((1 + sqrt 5) / 2)
--     -- l = log (1 + sqrt 2)
--     -- remN = rem n l
--     -- x = if remN < 0 then l + remN else remN
--     -- x = remN
--     -- x = remN
--     -- x = remN
--     -- x = rem n twoPi
--     wrappedN = rem n twoPi
--     twoPiN = twoPi + wrappedN
--     x = if wrappedN < 0 then twoPiN else wrappedN
--     -- sinh_193s = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
--     x2 = x * x
--     x3 = x2 * x
--     sinh_193s = x + (x3 / q)
--     -- q = c1 + (c2 * x2) + (c3 * pow x 4) + (c4 * pow x 6) + (c5 * pow x 8) + (c6 * pow x 10)
--     q = c1 + x2 * (c2 + x2 * (c3 + x2 * (c4 + x2 * (c5 + x2 * c6))))
--       where
--         c1 = 6.0000000000000000007
--         c2 = -0.30000000000000008212
--         c3 = 0.0078571428571458936741
--         c4 = -0.00013492063497385892777
--         c5 = 0.0000014507323068404717765
--         c6 = -0.0000000025198955964371314936
--         c7 = -0.00000000028298256368337042599
--     -- q = c1 + x2 * (c2 + x2 * (c3 + x2 * (c4 + x2 * (c5 + x2 * c6))))
--     --   where
--     --     c1 = 6.0000000000000003884
--     --     c2 = -0.30000000000002227888
--     --     c3 = 0.0078571428580357722224
--     --     c4 = -0.0003492064627800558812
--     --     c5 = 0.000004508048887469666981
--     --     c6 = -0.0000000027491054512754144867


-- branchless 64 bit atan
atanF64 :: Float -> Float
atanF64 n = copysign z n
  where
    absN = bitAnd n (bitNot iEEESignMaskF)
    -- absN = abs n
    -- complement = absN > 1
    -- complementCon = if complement then allBitsF else 0
    -- Set sign bit if absN > 1
    complement = bitAnd (1 - (absN + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    complementCon = bitShiftRightA complement 63
    -- x = if complement then 1 / absN else absN
    x = (bitAnd complementCon (1 / absN)) + (bitAnd absN (bitNot complementCon))
    -- region = x > tanTwelthPi
    -- regionCon = if region then 1 else 0
    -- Set sign bit if x > tanTwelthPi
    region = bitAnd (tanTwelthPi - (x + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    regionMask = bitShiftRightA region 63
    -- create scalar from mask for selection
    regionCon = bitAnd regionMask 1
    -- x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    x' = (x - (tanSixthPi * regionCon)) / (1 + (tanSixthPi * x * regionCon))
    -- y = if region then atan137s + sixthPi else atan137s
    y = atan137s + (sixthPi * regionCon)
    -- z = if complement then halfPi - y else y
    z = y + (bitAnd complementCon (halfPi - y - y))
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s = (x' * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x' * x'

slowAtanF64 :: Float -> Float
slowAtanF64 n = if sign then negate z else z
  where
    sign = n < 0
    absN = abs n
    complement = absN > 1
    x = if complement then 1 / absN else absN
    region = x > tanTwelthPi
    x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    y = if region then atanX + sixthPi else atanX
    z = if complement then halfPi - y else y
    atanX = atan137s x'
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x * x
----------------------------------------

instance Bits Float where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = primUndefined
  fromBits       x   = primUndefined

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Default Float where
  default = 0

negate :: Ring a => a -> a
negate x = 0 - x

floatToUInt :: Float -> UInt
floatToUInt x = primUndefined

-- f64ToUInt :: F64 -> UInt
-- f64ToUInt x = primUndefined

-- --------------------
-- -- F64
-- --------------------
-- instance Eq F64 where
--   eq  x y = primUndefined
--   neq x y = primUndefined
--
-- instance Ord F64 where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined
--
-- -- TODO: prim zero / one instances
-- instance Semiring F64 where
--   zero    = primUndefined
--   one     = primUndefined
--   add x y = primUndefined
--   mul x y = primUndefined
--
-- instance Ring F64 where
--   sub   x y = primUndefined
--   fromInt x = primUndefined
--
-- instance Num F64 where
--   abs    x = primUndefined
--   copysign x sign = primUndefined
--   signum x = copysign 1 x
--
-- instance EuclideanRing F64 where
--   div x y = primUndefined
--   rem x y = primUndefined
--
-- instance DivisionRing F64 where
--   recip x = 1 / x
--
-- instance Field F64 where
--
-- instance Floating F64 where
--   fromFloat x = primUndefined
--   sqrt      x = primUndefined
--   floor     x = primUndefined
--   ceil      x = primUndefined
--   truncate  x = primUndefined
--   round     x = primUndefined
--   -- fmin      x y = primUndefined
--   -- fmax      x y = primUndefined
--
-- instance Trig F64 where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined
--
-- instance Bits F64 where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined
--
-- instance Semigroup F64 where
--   append x y = x + y
--
-- instance Monoid F64 where
--   mempty = 0
--
-- instance Default F64 where
--   default = 0

fastFloor :: Float -> Float
fastFloor x = primUndefined

-- floor :: F64 -> F64
-- floor x = primUndefined
--
-- ceil :: F64 -> F64
-- ceil x = primUndefined
--
-- truncate :: F64 -> F64
-- truncate x = primUndefined
--
-- round :: F64 -> F64
-- round x = primUndefined
--
-- copysign :: F64 -> F64 -> F64
-- copysign x sign = primUndefined
--
-- fmin :: F64 -> F64 -> F64
-- fmin x y = primUndefined
--
-- fmax :: F64 -> F64 -> F64
-- fmax x y = primUndefined

floorToInt :: Float -> Int
floorToInt x = primUndefined

ceilToInt :: Float -> Int
ceilToInt x = primUndefined

truncateToInt :: Float -> Int
truncateToInt x = primUndefined

roundToInt :: Float -> Int
roundToInt x = primUndefined

fma :: Float -> Float -> Float -> Float
fma x y z = primUndefined

------------------------------------------------------------
-- iEEE 754 Double Precision Float Format constants
------------------------------------------------------------
iEEESignMask :: UInt
iEEESignMask = bitShiftLeft 1 63

iEEESignMaskF :: Float
iEEESignMaskF = fromBits iEEESignMask

iEEENumExponentBits :: UInt
iEEENumExponentBits = 11

iEEENumSignificandBits :: UInt
iEEENumSignificandBits = 52

iEEEExponentMask :: UInt
iEEEExponentMask = bitShiftLeft (-1) iEEENumSignificandBits |> bitAnd (bitNot iEEESignMask)

iEEEExponentMaskF :: Float
iEEEExponentMaskF = fromBits iEEEExponentMask

iEEESignificandMask :: UInt
iEEESignificandMask = bitAnd (-1) (bitNot (bitOr iEEEExponentMask iEEESignMask))

iEEESignificandMaskF :: Float
iEEESignificandMaskF = fromBits iEEESignificandMask

allBits :: UInt
allBits = -1

allBitsF :: Float
allBitsF = fromBits allBits

f64EpsilonU :: UInt
f64EpsilonU = 4372995238176751616

f64Epsilon :: Float
f64Epsilon = fromBits f64EpsilonU

instance Trig Float where
  sine    x = primUndefined
  cosine  x = primUndefined
  exp     x = primUndefined
  exp2    x = primUndefined
  log     x = primUndefined
  log10   x = primUndefined
  log2    x = primUndefined
  pow   x y = primUndefined
  sineh   x = (exp x - exp (negate x)) * 0.5
  cosineh x = (exp x + exp (negate x)) * 0.5
  atan2 y x =
    let
      halfPiSignY = copysign halfPi y
      atan20Y = if y == 0 then 0 else halfPiSignY -- TODO: use fselect!
      atan2XY =
        if (abs x) > (abs y) then
          (atanF64 (y / x)) + (if x > 0 then 0 else (copysign pi y))
        else
          (negate <| atanF64 (x / y)) + halfPiSignY
    in
      if x == 0 then atan20Y else atan2XY

--------------------
-- FloatVec
--------------------

--TODO: insertelement
--TODO: extractelement

-- TODO: Finish!
instance Eq (FloatVec n) where
  eq  x y = primUndefined
  neq x y = primUndefined

-- instance Ord (FloatVec n) where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring (FloatVec n) where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring (FloatVec n) where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num (FloatVec n) where
  abs      x      = primUndefined
  copysign x sign = primUndefined
  signum   x      = copysign 1 x

instance EuclideanRing (FloatVec n) where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing (FloatVec n) where
  recip x = 1 / x

instance Field (FloatVec n) where

instance Floating (FloatVec n) where
  fromFloat x = primUndefined
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined
  -- fmin      x y = primUndefined
  -- fmax      x y = primUndefined

-- instance Trig (FloatVec n) where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined

-- instance Bits (FloatVec n) where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined

instance Semigroup (FloatVec n) where
  append x y = x + y

instance Monoid (FloatVec n) where
  mempty = 0

instance Default (FloatVec n) where
  default = 0

-- floatVecInsert :: Index n -> Float -> FloatVec n -> FloatVec n
-- floatVecInsert i f v = primUndefined

-- floatVecExtract :: Index n -> FloatVec n -> Float
-- floatVecExtract i v = primUndefined

toFloatVecArray :: .Array n Float -> .Array (NatDiv n vn) (FloatVec vn)
toFloatVecArray a = primUndefined

fromFloatVecArray ::  .Array (NatDiv n vn) (FloatVec vn) -> .Array n Float
fromFloatVecArray v = primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
-- TODO: More efficient gcd algorithm
data Rational = Rational# Int Int

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, a % b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational# (x / d) (y / d)
  where
    d = gcd x y

rational :: Int -> Int -> Rational
rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational# n _) = n

denominator :: Rational -> Int
denominator (Rational# _ d) = d

instance Eq Rational where
  eq  (Rational# xn xd) (Rational# yn yd) = eq (xn * yd) (yn * xd)
  neq (Rational# xn xd) (Rational# yn yd) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational# xn xd) (Rational# yn yd) = lt  (xn * yd) (yn * xd)
  lte (Rational# xn xd) (Rational# yn yd) = lte (xn * yd) (yn * xd)
  gt  (Rational# xn xd) (Rational# yn yd) = gt  (xn * yd) (yn * xd)
  gte (Rational# xn xd) (Rational# yn yd) = gte (xn * yd) (yn * xd)

instance Semiring Rational where
  zero = Rational# 0 1
  one  = Rational# 1 1
  add (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd + yn * xd) (xd * yd)
  mul (Rational# xn xd) (Rational# yn yd) = reduce (xn * yn) (xd * yd)

instance Ring Rational where
  sub (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd - yn * xd) (xd * yd)
  fromInt x                               = Rational# (fromInt x) 1

instance Num Rational where
  abs    (Rational# xn xd) = Rational# (abs xn) xd
  signum (Rational# xn _)  = Rational# (signum xn) 1
  copysign (Rational# xn xd) (Rational#  yn _) = Rational# (copysign xn yn) (abs xd)

instance DivisionRing Rational where
  recip (Rational# n d) =
    if n == 0 then
      Rational# 0 1
    else
      d // n

instance EuclideanRing Rational where
  rem x y = primUndefined
  div x y = x * recip y

instance Field Rational where

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

instance Default Rational where
  default = 0

rationalToFloat :: Rational -> Float
rationalToFloat r = fromInt (numerator r) / fromInt (denominator r)


--------------------
-- Complex
--------------------
data Complex = Complex# Float Float

realPart :: Complex -> Float
realPart (Complex# r _) = r

imagPart :: Complex -> Float
imagPart (Complex# _ i) = i

mkPolar :: Float -> Float -> Complex
mkPolar r theta = Complex# (r * cosine theta) (r * sine theta)

cis :: Float -> Complex
cis theta = Complex# (cosine theta) (sine theta)

polar :: Complex -> (Float, Float)
polar c = (magnitude c, phase c)

polar' :: Complex -> (#Float, Float#)
polar' c = (#magnitude c, phase c#)

sqrMagnitude :: Complex -> Float
sqrMagnitude (Complex# r i) = (r * r) + (i * i)

magnitude :: Complex -> Float
magnitude (Complex# r i) = if ((r == 0) && (i == 0)) then 0 else sqrt ((r * r) + (i * i))

conjugate :: Complex -> Complex
conjugate (Complex# r i) = Complex# r (negate i)

phase :: Complex -> Float
phase (Complex# r i) = atan2 i r

instance Eq Complex where
  eq  (Complex# rx ix) (Complex# ry iy) = rx == ry && ix == iy
  neq (Complex# rx ix) (Complex# ry iy) = rx /= ry || ix /= iy

instance Semiring Complex where
  zero                                  = Complex# 0 0
  one                                   = Complex# 1 0
  add (Complex# rx ix) (Complex# ry iy) = Complex# (rx + ry) (ix + iy)
  mul (Complex# rx ix) (Complex# ry iy) = Complex# (rx * ry - ix * iy) (rx * iy + ix * ry)

instance Ring Complex where
  sub (Complex# rx ix) (Complex# ry iy) = Complex# (rx - ry) (ix - iy)
  fromInt z                             = Complex# (fromInt z) 0

instance EuclideanRing Complex where
  div x y = if yIntoConjugate /= 0
    then
      Complex# (zx / yIntoConjugate) (zi / yIntoConjugate)
    else
      Complex# 0 0
    where
      conjugateY     = conjugate y
      yIntoConjugate = y * conjugateY |> realPart
      Complex# zx zi = x * conjugateY
  rem x y = x - y * w
    where
      z = x / y
      w = case z of
        Complex# rz iz -> Complex# (floor rz) (floor iz)

instance DivisionRing Complex where
  recip (Complex# r i) = Complex# (r / sqrRsqrI) (negate (i / sqrRsqrI))
    where
      sqrRsqrI = (r * r) + (i * i)

instance Num Complex where
  abs z    = Complex# (magnitude z) 0
  signum z =
    case z of
      Complex# r i ->
        if r == 0 && i == 0 then 0 else
          let m = magnitude z in
            Complex# (r / m) (i / m)
  copysign x sign = (abs x) * (signum sign) -- Note: unsure if this is well founded or not?

instance Field Complex where

instance Floating Complex where
  fromFloat f = Complex# (fromFloat f) 0
  sqrt z = case z of
    Complex# r i ->
        let
            halfSqrt2 = (sqrt 2) / 2
            magZ = (magnitude z)
            magZR = r + magZ
            magZNegR = magZ - r
            u = if magZR /= 0 then sqrt magZR else 0
            v = if magZNegR /= 0 then (signum i) * (sqrt magZNegR) else 0
        in
            Complex# (halfSqrt2 * u) (halfSqrt2 * v)
  floor     (Complex# r i) = Complex# (floor r) (floor i)
  ceil      (Complex# r i) = Complex# (ceil r) (ceil i)
  truncate  (Complex# r i) = Complex# (truncate r) (truncate i)
  round     (Complex# r i) = Complex# (round r) (round i)
  -- fmin      x y = if (magnitude x < magnitude y) then x else y -- TODO: branchless versions?
  -- fmax      x y = if (magnitude x > magnitude y) then x else y

instance Trig Complex where
  sine (Complex# r i) = Complex# (sine r * cosineh i) (cosine r * sineh i)
  cosine (Complex# r i) = Complex# (cosine r * cosineh i) (negate (sine r * sineh i))
  sineh (Complex# r i) = Complex# (sineh r * cosine i) (cosineh r * sine i)
  cosineh (Complex# r i) = Complex# (cosineh r * cosine i) (negate (sineh r * sine i))
  exp (Complex# r i) = Complex# (expR * cosine i) (expR * sine i)
    where
      expR = exp r
  exp2 c = case c of
    (Complex# _ i) -> let
        magC = magnitude c
        logTwo = log 2
        iLogTwo = i * log 2
      in
        Complex# (magC * cosine iLogTwo) (magC * sine iLogTwo)
  log c = Complex# (log <| magnitude c) (phase c)
  log2 c = Complex# (log2 <| magnitude c) (phase c)
  log10 c = Complex# (log10 <| magnitude c) (phase c)
  pow n c = exp (c * log n)
  atan2 y x = (Complex# 0 -1) * (log ((x + ((Complex# 0 1) * y)) / (sqrt ((x * x) + (y * y)))))

lerpComplex :: Complex -> Complex -> Float -> Complex
lerpComplex (Complex# rx ix) (Complex# ry iy) delta =
  Complex# r i
  where
    r = rx * (1 - delta) + ry * delta
    i = ix * (1 - delta) + iy * delta


--------------------
-- Vector2D
--------------------
data Vector2D      = Vector2D# Float Float
data AudioVector2D = AudioVector2D# Audio Audio

magnitude2D :: Vector2D -> Float
magnitude2D (Vector2D# x y) = sqrt ((x * x) + (y * y))

magnitudeSquared2D :: Vector2D -> Float
magnitudeSquared2D (Vector2D# x y) = (x * x) + (y * y)

dotProduct2D :: Vector2D -> Vector2D -> Float
dotProduct2D (Vector2D# x0 y0) (Vector2D# x1 y1) = (x0 * x1) + (y0 * y1)

instance Eq Vector2D where
  eq  (Vector2D# x0 y0) (Vector2D# x1 y1) = x0 == x1 && y0 == y1
  neq (Vector2D# x0 y0) (Vector2D# x1 y1) = x0 /= x1 || y0 /= y1

instance Ord Vector2D where
  lt  v0 v1 = lt  (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  lte v0 v1 = lte (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  gt  v0 v1 = gt  (magnitudeSquared2D v0) (magnitudeSquared2D v1)
  gte v0 v1 = gte (magnitudeSquared2D v0) (magnitudeSquared2D v1)

instance Semiring Vector2D where
  zero                                    = Vector2D# 0 0
  one                                     = Vector2D# 1 1
  add (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 + x1) (y0 + y1)
  mul (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 * x1) (y0 * y1)

instance Ring Vector2D where
  sub (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (x0 - x1) (y0 - y1)
  fromInt x                               = Vector2D# (fromInt x) (fromInt x)

instance Num Vector2D where
  abs      (Vector2D# x y)                     = Vector2D# (abs x) (abs y)
  signum   (Vector2D# x y)                     = Vector2D# (signum x) (signum y)
  copysign (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (copysign x0 x1) (copysign y0 y1)

instance DivisionRing Vector2D where
  recip (Vector2D# x y) = Vector2D# (1 / x) (1 / y)

instance EuclideanRing Vector2D where
  rem (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (rem x0 x1) (rem y0 y1)
  div (Vector2D# x0 y0) (Vector2D# x1 y1) = Vector2D# (div x0 x1) (div y0 y1)

instance Field Vector2D where

instance Floating Vector2D where
  fromFloat f              = Vector2D# f f
  sqrt     (Vector2D# x y) = Vector2D# (sqrt x) (sqrt y)
  floor    (Vector2D# x y) = Vector2D# (floor x) (floor y)
  ceil     (Vector2D# x y) = Vector2D# (ceil x) (ceil y)
  truncate (Vector2D# x y) = Vector2D# (truncate x) (truncate y)
  round    (Vector2D# x y) = Vector2D# (round x) (round y)
  -- fmin     (Mono x) (Mono y) = Mono (fmin x y)
  -- fmax     (Mono x) (Mono y) = Mono (fmax x y)

instance Semigroup Vector2D where
  append x y = x + y

instance Monoid Vector2D where
  mempty = 0

instance Default Vector2D where
  default = 0

instance Print Vector2D where
  print (Vector2D# x y) w =
    print '(' w
    |> print x
    |> print ','
    |> print y
    |> print ')'


----------------------
-- Vector3D
----------------------
data Vector3D      = Vector3D# Float Float Float
data AudioVector3D = AudioVector3D# Audio Audio Audio

magnitude3D :: Vector3D -> Float
magnitude3D (Vector3D# x y z) = sqrt ((x * x) + (y * y) + (z * z))

magnitudeSquared3D :: Vector3D -> Float
magnitudeSquared3D (Vector3D# x y z) = (x * x) + (y * y) + (z * z)

dotProduct3D :: Vector3D -> Vector3D -> Float
dotProduct3D (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = (x0 * x1) + (y0 * y1) + (z0 * z1)

-- TODO: VectorType class?

instance Eq Vector3D where
  eq  (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = x0 == x1 && y0 == y1 && z1 == z1
  neq (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = x0 /= x1 || y0 /= y1 || z1 /= z1

instance Ord Vector3D where
  lt  v0 v1 = lt  (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  lte v0 v1 = lte (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  gt  v0 v1 = gt  (magnitudeSquared3D v0) (magnitudeSquared3D v1)
  gte v0 v1 = gte (magnitudeSquared3D v0) (magnitudeSquared3D v1)

instance Semiring Vector3D where
  zero                                          = Vector3D# 0 0 0
  one                                           = Vector3D# 1 1 1
  add (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 + x1) (y0 + y1) (z0 + z1)
  mul (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 * x1) (y0 * y1) (z0 * z1)

instance Ring Vector3D where
  sub (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (x0 - x1) (y0 - y1) (z0 - z1)
  fromInt x                                     = let f = fromInt x in Vector3D# f f f

instance Num Vector3D where
  abs      (Vector3D# x y z)                         = Vector3D# (abs x) (abs y) (abs z)
  signum   (Vector3D# x y z)                         = Vector3D# (signum x) (signum y) (signum z)
  copysign (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (copysign x0 x1) (copysign y0 y1) (copysign z0 z1)

instance DivisionRing Vector3D where
  recip (Vector3D# x y z) = Vector3D# (1 / x) (1 / y) (1 / z)

instance EuclideanRing Vector3D where
  rem (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (rem x0 x1) (rem y0 y1) (rem z0 z1)
  div (Vector3D# x0 y0 z0) (Vector3D# x1 y1 z1) = Vector3D# (div x0 x1) (div y0 y1) (div z0 z1)

instance Field Vector3D where

instance Floating Vector3D where
  fromFloat f                = Vector3D# f f f
  sqrt     (Vector3D# x y z) = Vector3D# (sqrt x) (sqrt y) (sqrt z)
  floor    (Vector3D# x y z) = Vector3D# (floor x) (floor y) (floor z)
  ceil     (Vector3D# x y z) = Vector3D# (ceil x) (ceil y) (ceil z)
  truncate (Vector3D# x y z) = Vector3D# (truncate x) (truncate y) (truncate z)
  round    (Vector3D# x y z) = Vector3D# (round x) (round y) (round z)
  -- fmin     (Mono x) (Mono y) = Mono (fmin x y)
  -- fmax     (Mono x) (Mono y) = Mono (fmax x y)

instance Semigroup Vector3D where
  append x y = x + y

instance Monoid Vector3D where
  mempty = 0

instance Default Vector3D where
  default = 0

instance Print Vector3D where
  print (Vector3D# x y z) w =
    print '(' w
    |> print x
    |> print ','
    |> print y
    |> print ','
    |> print z
    |> print ')'


--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Eq a => Eq (Maybe a) where
  eq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> True
          _       -> False

      Just x ->
        case my of
          Nothing -> False
          Just y  -> eq x y
  neq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> False
          _       -> True

      Just x ->
        case my of
          Nothing -> True
          Just y  -> neq x y

instance Default (Maybe a) where
  default = nothing

instance Semigroup a => Semigroup (Maybe a) where
  append mx my =
    case mx of
      Nothing -> my
      Just x  ->
        case my of
          Nothing -> mx
          Just y  -> Just (append x y)

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance UFunctor Maybe where
  umap f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> Nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)
  map3 f mx my mz =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            case mz of
              Nothing -> nothing
              Just z  ->
                Just (f x y z)
  map4 f mw mx my mz =
    case mw of
      Nothing -> nothing
      Just w  ->
        case mx of
          Nothing -> nothing
          Just x  ->
            case my of
              Nothing -> nothing
              Just y  ->
                case mz of
                  Nothing -> nothing
                  Just z  ->
                    Just (f w x y z)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

instance Alternative Maybe where
  empty           = nothing
  alternative x y =
    case x of
      Nothing -> y
      Just _  -> x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
maybe :: .b -> .(.a -> .b) -> Maybe .a -> .b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
fromMaybe :: .a -> Maybe .a -> .a
fromMaybe defaultValue m =
  case m of
    Nothing -> defaultValue
    Just x  -> x


--------------------
-- Either
--------------------
data Either a b = Left a | Right b

either :: .(.a -> .c) -> .(.b -> .c) -> Either .a .b -> .c
either lf rf e =
  case e of
    Left  lx -> lf lx
    Right rx -> rf rx


--------------------
-- Ptr
--------------------
ptrMalloc :: UInt -> Ptr *a
ptrMalloc capacity =
  primUndefined

ptrRealloc :: UInt -> Ptr *a -> Ptr *a
ptrRealloc capacity ptr =
  primUndefined

ptrFree :: Ptr .a -> *()
ptrFree ptr =
  primUndefined

unsafePtrPeek :: UInt -> Ptr a -> a
unsafePtrPeek index ptr =
  primUndefined

unsafePtrPoke :: UInt -> *a -> Ptr *a -> Ptr *a
unsafePtrPoke index value ptr =
  primUndefined

unsafePtrSwapElement :: UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
unsafePtrSwapElement index element ptr =
  primUndefined

unsafePtrCast :: Ptr a -> Ptr b
unsafePtrCast p =
  primUndefined

--TODO: This is causing strange non-exhaustive case statements at runtime somehow...
ptrEq :: Ptr a -> Ptr a -> Bool
ptrEq x y =
  primUndefined

ptrIsNull :: Ptr a -> Bool
ptrIsNull x =
  ptrEq x primUndefined

-- unsafePtrPokeChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> Ptr *a
-- unsafePtrPokeChecked str capacity index value ptr =
--   unsafePtrPoke (boundsCheck str index capacity) value ptr

-- unsafePtrSwapElementChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
-- unsafePtrSwapElementChecked str capacity index element ptr =
--   unsafePtrSwapElement (boundsCheck str index capacity) element ptr

-- TODO: Checked readArray and writeArray!

----------------------
-- MutRef: A hack to allow for recursively owned types...
----------------------
-- data MutRef a = MutRef (Ptr (Maybe a))

-- HACK / NOTE: mutRef expects the first argument to be CONSTANT (Need to support this concept in the type system...)
mutRef :: Maybe *a -> Ptr (Maybe *a)
mutRef x =
  primUndefined

mutRefTake :: (() -> *a) -> (#*a, Ptr (Maybe *a)#)
mutRefTake mkFn =
  case unsafePtrSwapElement 0 Nothing (mutRef Nothing) of
    (#mx, ptr1#) ->
      case mx of
        Just x  -> (#x, ptr1#)
        Nothing -> (#mkFn (), ptr1#)

mutRefPut :: *a -> Ptr (Maybe *a) -> ()
mutRefPut x ptr =
  case unsafePtrPoke 0 (Just x) ptr of
    _ -> ()


--------------------
-- Array
--------------------

-- TODO: Make range unboxed? Proper unboxed types? End constructor name with # to create unboxed type?
data Range   (n :: Nat)                       = Range# UInt UInt UInt
data Index   (n :: Nat)                       = Index UInt
data NatVal  (n :: Nat)                       = NatVal
data NatVal2 (n :: Nat) (m :: Nat)            = NatVal2
data NatVal3 (n :: Nat) (m :: Nat) (o :: Nat) = NatVal3

natVal :: NatVal n -> UInt
natVal n = primUndefined

natVal2ToNatVals :: NatVal2 w h -> (#NatVal w, NatVal h#)
natVal2ToNatVals _ = (#NatVal, NatVal#)

natVal3ToNatVals :: NatVal3 w h d -> (#NatVal w, NatVal h, NatVal d#)
natVal3ToNatVals _ = (#NatVal, NatVal, NatVal#)

mkRange :: UInt -> UInt -> NatVal n -> Range n
mkRange init inc end = Range# init inc (natVal end)

each :: Range n
each = mkRange 0 1 NatVal

indexBackwards :: NatVal n -> Index n -> Index n
indexBackwards n i =
  unsafeUIntToIndex ((natVal n - 1) - (indexToUInt i))

unsafeIndexToIndex :: Index n -> Index m
unsafeIndexToIndex (Index i) =
  Index i

unsafeEmptyArray :: () -> *Array n a
unsafeEmptyArray u = primUndefined

freezeArray :: *Array n a -> .Array n a
freezeArray a = primUndefined

readArray :: Index n -> Array n a -> a
readArray i a = primUndefined

readArrayU :: Index n -> .Array n a -> (#a, .Array n a#)
readArrayU i a = primUndefined

writeArray :: Index n -> a -> *Array n a -> *Array n a
writeArray i x a = primUndefined

lookupArray :: UInt -> Array n a -> Maybe a
lookupArray i a =
  if i < arrayLength NatVal a then
    Just (readArray (unsafeUIntToIndex i) a)
  else
    Nothing

writeArrayChecked :: Index n -> a -> *Array n a -> *Array n a
writeArrayChecked ind x a =
  writeArray (Index (boundsCheck i capacity)) x a
  where
    capacity = arrayLengthFromIndex NatVal ind
    (Index i) = ind

readArrayChecked :: Index n -> Array n a -> a
readArrayChecked ind a =
  readArray (Index (boundsCheck i capacity)) a
  where
    capacity = arrayLengthFromIndex NatVal ind
    (Index i) = ind

readArrayUChecked :: Index n -> .Array n a -> (#a, .Array n a#)
readArrayUChecked ind a =
  readArrayU (Index (boundsCheck i capacity)) a
  where
    capacity = arrayLengthFromIndex NatVal ind
    (Index i) = ind

zip :: Array n a -> Array n b -> Array n (a, b)
zip a b = freezeArray <|
  loop c = unsafeEmptyArray () for i <- each do
    let
      va = readArray i a
      vb = readArray i b
    in
      writeArray i (va, vb) c


zipWith :: (a -> b -> c) -> Array n a -> Array n b -> Array n c
zipWith f a b = freezeArray <|
  loop c = unsafeEmptyArray () for i <- each do
    let
      va = readArray i a
      vb = readArray i b
    in
      writeArray i (f va vb) c

instance Default a => Default (Array n a) where
  default = arrayFrom default

arrayFrom :: a -> .Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i x a

mkArray :: (UInt -> a) -> .Array n a
mkArray f =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i (f (indexToUInt i)) a

instance Foldable (Array n) where
  fold a =
    loop x = mempty for i <- each do
      x <> readArray i a
  foldl f init a0 =
    fst' <| loop (#x, a1#) = (#init, a0#) for i <- each do
      case readArrayU i a1 of
        (#y, a2#) ->
          (#f x y, a2#)

instance Functor (Array n) where
  map f a = freezeArray b
    where
      b =
        loop a' = unsafeEmptyArray () for i <- each do
          writeArray i (f (readArray i a)) a'

--------------------
-- Index
--------------------
-- TODO: Hide Index constructor outside of base.necro for safety
-- TODO: Use Max to restrict UInt to range?
unsafeUIntToIndex :: UInt -> Index n
unsafeUIntToIndex i = Index i

indexToUInt :: Index n -> UInt
indexToUInt (Index i) = i

indexToFloat :: Index n -> Float
indexToFloat (Index i) = fromUInt i

bitReverseIndex :: Index n -> Index n
bitReverseIndex (Index i) = Index (bitReverse i)

-- toIndexMultiple :: Index n -> Index (NatMul n (NatMax k 1))
-- toIndexMultiple (Index i) = Index i

sampleRate :: UInt
sampleRate = primUndefined

recipSampleRate :: Float
recipSampleRate = primUndefined

audioSampleRate :: UInt
audioSampleRate = 48000

audioBlockSize :: UInt
audioBlockSize = 256

audioBlockSizeMask :: UInt
audioBlockSizeMask = audioBlockSize - 1

audioOverSampleAmount :: UInt
audioOverSampleAmount = 24

audioRecipOverSampleRate :: Float
audioRecipOverSampleRate = recip <| fromUInt <| audioSampleRate * audioOverSampleAmount

-- audioBlockSize :: UInt
-- audioBlockSize = audioBlockSize' * audioOverSampleAmount

audioBlockSizeF :: Float
audioBlockSizeF = fromUInt audioBlockSize

-- audioSampleRate :: UInt
-- audioSampleRate = audioSampleRate' * audioOverSampleAmount

audioSampleRateF :: Float
audioSampleRateF = fromUInt audioSampleRate

audioBlocksPerSecond :: UInt
audioBlocksPerSecond = audioSampleRate / audioBlockSize

audioBlockDelta :: Rational
audioBlockDelta = 1 // fromUInt audioBlocksPerSecond

audioSampleDelta :: Rational
audioSampleDelta = 1 // fromUInt audioSampleRate

-- -- NOTE: Assumes audioBlockSize is a power of 2!
-- audioBlockSizeLog2 :: UInt
-- audioBlockSizeLog2 =
--   fst' <| loop (#bits, n#) = (#0, audioBlockSize#) while n > 0 do
--     (#bits + 1, bitShiftRight n 1#)

audioSampleOffset :: UInt
audioSampleOffset = 0

currBlockTime :: Rational
currBlockTime =
  t
  where
    t ~ 0 = t + audioBlockDelta

currBlockCount :: UInt
currBlockCount =
  t
  where
    t ~ 0 = t + 1

currSampleCount :: UInt
currSampleCount =
  t
  where
    t ~ 0 = t + audioBlockSize

--------------------
-- Audio
--------------------
data Audio = AudioEnd | BlockRate Float | AudioRate (Array BlockSize Float)

silenceAtEnd :: AudioFormat f => f Audio -> f Audio
silenceAtEnd cs =
  map f cs
  where
    f c =
      case c of
        AudioEnd -> BlockRate 0
        _        -> c

outAudioBlock :: UInt -> Array BlockSize Float -> *World -> *World
outAudioBlock c a w = primUndefined

silentBlock :: Array BlockSize Float
silentBlock =
  fromFloatVecArray a
  where
    a :: Array (NatDiv BlockSize 32) (FloatVec 32)
    a = arrayFrom 0

outChannel :: UInt -> Audio -> *World -> *World
outChannel n c w =
  case c of
    AudioEnd    -> outAudioBlock n silentBlock w
    BlockRate _ -> outAudioBlock n silentBlock w
    AudioRate b -> outAudioBlock n b w

-- TODO / NOTE:
--     Take care when creating arrays for usage as audio buffers, they must be 64 BYTE aligned to allow for proper simd usage,
--     Thus audio buffers should always be created in the form:
--         Array (NatDiv BlockSize 32) (FloatVec 32)
--     and then cast to:
--         Array BlockSize Float
--     This will insure that the audio buffer is aligned properly by the llvm back end
audioInitArray :: () -> *Array BlockSize Float
audioInitArray u =
  snd' <| loop (#i, a#) = (#0, fromFloatVecArray ia#) while i < audioSampleOffset do
    (#i + 1, writeArray (Index i) 0 a#)
  where
    ia :: *Array (NatDiv BlockSize 32) (FloatVec 32)
    ia = unsafeEmptyArray ()

mapAudio :: (Float -> Float) -> Audio -> Audio
mapAudio f c =
  case c of
    AudioEnd    -> AudioEnd
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = audioInitArray () for i <- offsetToEndRange do
        writeArray i (f (readArray i b)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal

mapAudio2 :: (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2 f cx cy =
  case cx of
    AudioEnd    -> AudioEnd
    BlockRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y -> BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f x (readArray i y)) a
    AudioRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) y) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) (readArray i y)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()

-- TODO: perc Env state in for loop
mapAudio2Vec :: (FloatVec 32 -> FloatVec 32 -> FloatVec 32) -> (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2Vec f ff cx cy =
  case cx of
    AudioEnd     -> AudioEnd
    BlockRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' -> BlockRate (ff x' y')
        AudioRate y' ->
          let
            x = fromFloat x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f x (readArray i y)) a
    AudioRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' ->
          let
            x = toFloatVecArray x'
            y = fromFloat y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) y) a
        AudioRate y' ->
          let
            x = toFloatVecArray x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) (readArray i y)) a
  where
    ia = toFloatVecArray <| audioInitArray ()

const :: .a -> .b -> .a
const x _ = x

constTrue :: a -> Bool
constTrue _ = True

constTrueU :: .a -> (#.a, Bool#)
constTrueU state = (#state, True#)

accumulateAudio1 :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio
accumulateAudio1 f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#s, a#) ->
          case isRunningFunc s of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio2 :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio
accumulateAudio2 f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#s, a#) ->
              case isRunningFunc s of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio3 :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3 f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#s, a#) ->
                  case isRunningFunc s of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio
accumulateAudio1U mkState f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#isRunning, a#) ->
          case isRunning of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)

accumulateAudio2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio
accumulateAudio2U mkState f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#isRunning, a#) ->
              case isRunning of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


accumulateAudio3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3U mkState f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#isRunning, a#) ->
                  case isRunning of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


instance Eq Audio where
  eq x y =
    case x of
      AudioEnd ->
        case y of
          AudioEnd -> True
          _        -> False

      BlockRate xv ->
        case y of
          BlockRate yv -> xv == yv
          _            -> False

      AudioRate xa ->
        case y of
          AudioRate ya ->
            loop cond = True for i <- each do
              cond && readArray i xa == readArray i ya
          _ -> False

  neq x y = not (eq x y)

instance Semiring Audio where
  zero    = BlockRate 0
  one     = BlockRate 1
  add x y = mapAudio2Vec add add x y
  mul x y = mapAudio2Vec mul mul x y

instance Ring Audio where
  sub x y   = mapAudio2Vec sub sub x y
  fromInt i = BlockRate (fromInt i)

instance EuclideanRing Audio where
  div x y = mapAudio2 div x y
  rem x y = mapAudio2 rem x y

instance DivisionRing Audio where
  recip x = mapAudio recip x

instance Num Audio where
  signum x  = mapAudio signum x
  abs x     = mapAudio abs x
  copysign x sign = mapAudio2 copysign x sign

instance Field Audio where

instance Floating Audio where
  fromFloat f = BlockRate (fromFloat f)
  sqrt x      = mapAudio sqrt x
  floor     x = mapAudio floor x
  ceil      x = mapAudio ceil x
  truncate  x = mapAudio truncate x
  round     x = mapAudio round x
  -- fmin      x y = mapAudio fmin x y
  -- fmax      x y = mapAudio copysign x y

instance Semigroup Audio where
  append x y = x + y

instance Monoid Audio where
  mempty = 0

instance Default Audio where
  default = 0


--------------------
-- FFT
--------------------
-- FFT bins are represented as complex numbers wherein phase is encoded as the angle of a 2D vector and amplitude is encoded as the magnitude of the 2D vector.
data FFT k       = FFT (Array (NatMul BlockSize (NatMul k 4)) Complex) | FFTInterval | FFTNone | FFTEnd
data FFTWindow k = FFTWindow (Array (NatMul BlockSize (NatMul k 2)) Float)

-- TODO: rename all FFT stuff to be prepended by namespace fft
-- TODO: Num instances for FFT or not?

fftSilence :: AudioFormat f => f (FFT k)
fftSilence =
  arrayFrom 0
  |> FFT
  |> pure

mapFFT :: (Complex -> Complex) -> FFT k -> FFT k
mapFFT f c =
  case c of
    FFTEnd      -> FFTEnd
    FFTNone     -> FFTNone
    FFTInterval -> FFTInterval
    FFT b       ->
      FFT
      <| freezeArray
      <| loop a = unsafeEmptyArray () for i <- each do
        writeArray i (f (readArray i b)) a

mapFFT2 :: (Complex -> Complex -> Complex) -> FFT k -> FFT k -> FFT k
mapFFT2 f cx cy =
  case cx of
    FFTEnd      -> FFTEnd
    FFTNone     -> FFTNone
    FFTInterval -> FFTInterval
    FFT x       ->
      case cy of
        FFTEnd      -> FFTEnd
        FFTNone     -> FFTNone
        FFTInterval -> FFTInterval
        FFT y       ->
          FFT
          <| freezeArray
          <| loop a = unsafeEmptyArray () for i <- each do
            writeArray i (f (readArray i x) (readArray i y)) a

mapFFTBuffer ::
  AudioFormat f =>
  (Array (NatMul BlockSize (NatMul k 4)) Complex -> Array (NatMul BlockSize (NatMul k 4)) Complex) ->
  f (FFT k) ->
  f (FFT k)
mapFFTBuffer f c = map mf c
  where
    mf fftChannel =
      case fftChannel of
        FFTEnd -> FFTEnd
        FFTNone -> FFTNone
        FFTInterval -> FFTInterval
        FFT b ->  FFT (f b)

composeFFTBuffers ::
  (Array (NatMul BlockSize (NatMul k 4)) Complex ->
    Array (NatMul BlockSize (NatMul k 4)) Complex ->
    Array (NatMul BlockSize (NatMul k 4)) Complex) ->
  Mono (FFT k) ->
  Mono (FFT k) ->
  Mono (FFT k)
composeFFTBuffers f (Mono cx) (Mono cy) =
  case cx of
    FFTEnd      -> Mono FFTEnd
    FFTNone     ->
      case cy of
        FFTEnd      -> Mono FFTEnd
        FFTInterval -> Mono FFTInterval
        _           -> Mono FFTNone
    FFTInterval ->
      case cy of
        FFTEnd      -> Mono FFTEnd
        _           -> Mono FFTInterval
    FFT x ->
      case cy of
        FFTEnd      -> Mono FFTEnd
        FFTNone     -> Mono FFTNone
        FFTInterval -> Mono FFTInterval
        FFT y       -> Mono (FFT (f x y))

natValFrom :: NatVal k -> f k -> UInt
natValFrom n _ =
  natVal n

windowNone :: FFTWindow k
windowNone =
  FFTWindow (arrayFrom 1)

windowSine :: FFTWindow k
windowSine =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (sine (pi * fromUInt (indexToUInt i) / fromUInt (natValFrom NatVal i))) a

windowMLTSine :: FFTWindow k
windowMLTSine =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (sine ((fromUInt (indexToUInt i) + 0.5) * (pi / fromUInt (natValFrom NatVal i)))) a

windowHann :: FFTWindow k
windowHann =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (0.5 - 0.5 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt (natValFrom NatVal i))) a

windowHamming :: FFTWindow k
windowHamming =
  FFTWindow
  <| freezeArray
  <| loop a = unsafeEmptyArray () for i <- each do
    writeArray i (0.54 - 0.46 * cosine (tau * fromUInt (indexToUInt i) / fromUInt (natValFrom NatVal i))) a

----------------------
-- audioToTimeDomain
-- This preps audio data for FFT analysis
-- Currently uses a fixed hop size of 0.5
-- First it copies the data into a circular buffer (fft needs past audio data to perform overlay-add in ifft)
-- Next it performs zero-phase buffering
-- Then it multiplies the audio by the supplied window function
-- And lastly it stores this in a Complex valued array for the FFT algorithm
-- TODO: use NatNextPowerOfTwo for safer FFT sizes? It would mean even more hilariously large Array types
-- TODO: something is up, maybe with windowing?!?!?!?!?!?
-- TODO: Insure next power of two!

-- audioToTimeDomain :: UInt -> Array BlockSize Float -> Array (NatMul BlockSize 2) Float -> *Array (NatMul BlockSize (NatMax k 2)) Complex
-- audioToTimeDomain fftSize a w =
--   case mutRefTake (\_ -> (#arrayFrom 0, 0#)) of
--     (#(#cBuffer0, cOffset0#), mref#) ->
--       let
--         a2SizeMask = audioBlockSize * 2 - 1
--         cOffset1   = bitAnd (cOffset0 + audioBlockSize) a2SizeMask
--         cBuffer2   =
--           -- Copy data into circular buffer
--           loop cBuffer1 = cBuffer0 for i <- each do
--             writeArray (unsafeUIntToIndex (bitAnd (indexToUInt i + cOffset0) a2SizeMask)) (readArray i a) cBuffer1
--         (#timeDomain, cBuffer5#) =
--           loop (#timeDomain0, cBuffer3#) = (#unsafeEmptyArray (), cBuffer2#) for fftIndex <- each do
--             let
--               fftIndexU  = indexToUInt fftIndex
--             in
--               -- Zero-phase Zero padding
--               if fftIndexU < audioBlockSize then
--                 let
--                   ai               = fftIndexU + audioBlockSize
--                   wi               = unsafeUIntToIndex ai
--                   wx               = readArray wi w
--                   ci               = asTypeOf (unsafeUIntToIndex (bitAnd (ai + cOffset0 + audioBlockSize) a2SizeMask)) wi
--                   (#ax, cBuffer4#) = readArrayU ci cBuffer3
--                   tc               = Complex# (ax * wx) 0
--                 in
--                   (#writeArray fftIndex tc timeDomain0, cBuffer4#)
--               else if fftIndexU >= fftSize - audioBlockSize then
--                 let
--                   ai               = fftIndexU - (fftSize - audioBlockSize)
--                   wi               = unsafeUIntToIndex ai
--                   wx               = readArray wi w
--                   ci               = asTypeOf (unsafeUIntToIndex (bitAnd (ai + cOffset0 + audioBlockSize) a2SizeMask)) wi
--                   (#ax, cBuffer4#) = readArrayU ci cBuffer3
--                   tc               = Complex# (ax * wx) 0
--                 in
--                   (#writeArray fftIndex tc timeDomain0, cBuffer4#)
--               else
--                 (#writeArray fftIndex 0 timeDomain0, cBuffer3#)
--       in
--         case mutRefPut (#cBuffer5, cOffset1#) mref of
--           _ ->
--             timeDomain

fftIndexIsZeroBin :: UInt -> UInt -> Index (NatMul BlockSize (NatMul k 4)) -> Bool
fftIndexIsZeroBin bufferSize fftHalfSize (Index i) =
  if i < fftHalfSize then
    False
  else if i >= (bufferSize - 0) - fftHalfSize then
    False
  else
    True

fftIndexToZeroPhaseIndex :: UInt -> UInt -> Index (NatMul BlockSize (NatMul k 4)) -> Index (NatMul BlockSize (NatMul k 2))
fftIndexToZeroPhaseIndex bufferSize fftHalfSize (Index i) =
  if i < fftHalfSize then
    Index (i + fftHalfSize)
  else if i >= (bufferSize - 0) - fftHalfSize then
    Index (i - ((bufferSize - 0) - fftHalfSize))
  else
    Index i

fftArraySizeGymnastics :: Index (NatMul BlockSize (NatMul k 4)) -> Index (NatMul BlockSize k) -> Index (NatMul BlockSize k)
fftArraySizeGymnastics _ i = i

----------------------
-- Zero-phase Zero padding version
----------------------
-- Useful values
-- BufferSize     size: BufferSize
-- FFTSize        size: BufferSize / 2
-- timeDomain     size: BufferSize
-- cBuffer        size: FFTSize
-- prevTimeDomain size: FFTSize / 2
-- overflowBuffer size: FFTSize / 2
-- window buffer  size: FFTSize

audioToTimeDomain :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Array BlockSize Float -> Maybe (*Array (NatMul BlockSize (NatMul k 4)) Complex)
audioToTimeDomain n (FFTWindow window) audio =
  case mutRefPut (#cBufferEnd, cIndex1#) mref of
    _ -> timeDomainEnd
  where
    (#(#cBuffer0, cIndex0#), mref#) = mutRefTake (\_ -> (#arrayFrom 0, 0#))
    bufferSize                      = natVal n
    fftSize                         = bufferSize / 2
    fftHalfSize                     = fftSize / 2
    fftSizeMask                     = fftSize - 1
    fftScaleFactor                  = 1 / fromUInt fftSize
    cIndex1                         = bitAnd (cIndex0 + audioBlockSize) fftSizeMask
    cBuffer2                        =
      -- Copy data into circular buffer
      loop cBuffer1 = cBuffer0 for i <- each do
        writeArray (unsafeUIntToIndex (bitAnd (indexToUInt i + cIndex0) fftSizeMask)) (readArray i audio) cBuffer1
    (#timeDomainEnd, cBufferEnd#) =
      if cIndex1 == 0 || cIndex1 == fftHalfSize then
        -- Zero-phase zero-padding for FFT analysis
        let
          (#timeDomain, cBuffer5#) =
            loop (#timeDomain0, cBuffer3#) = (#unsafeEmptyArray (), cBuffer2#) for fftIndex <- each do
              if fftIndexIsZeroBin bufferSize fftHalfSize fftIndex then
                -- zero padding
                (#writeArray fftIndex (Complex# 0 0) timeDomain0, cBuffer3#)
              else
                let
                  windowIndex      = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  wx               = readArray windowIndex window
                  circularIndex    = asTypeOf (unsafeUIntToIndex (bitAnd (indexToUInt windowIndex + cIndex1) fftSizeMask)) windowIndex
                  (#ax, cBuffer4#) = readArrayU circularIndex cBuffer3
                  c                = Complex# (ax * wx * fftScaleFactor) 0
                  -- c                = Complex# (wx) 0
                  timeDomain1      = writeArray fftIndex c timeDomain0
                in
                  (#timeDomain1, cBuffer4#)
        in
          (#Just timeDomain, cBuffer5#)
          -- if currBlockCount == 2048 then
          --   case plotFFTChannelOnce "./data/timeDomainTest.dat" (FFT (freezeArray timeDomain)) primUndefined of
          --     _ -> primUndefined
          -- else
      else
        -- In between FFT blocks
        (#Nothing, cBuffer2#)


----------------------
-- timeDomainToAudio
-- Overlap-Add method: dspguide.com/ch18/1.htm
-- Use sine window for FFT and IFFT to combine for a Hann window?
-- This is the inverse of audioToTimeDomain
-- Performs overlay-add with a hop size of 2
-- Undoes zero phase buffering

-- TODO / NOTE: don't padd with zeroes!??!!?
timeDomainToAudio :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Maybe (Array (NatMul BlockSize (NatMul k 4)) Float) -> Audio
timeDomainToAudio n (FFTWindow window) maybeTimeDomain =
  case mutRefPut (#overflowBuffer2, prevTimeDomain1, overflowIndex1#) mref of
    _ -> AudioRate (freezeArray audio)
  where
    (#(#overflowBuffer0, prevTimeDomain0, overflowIndex0#), mref#) =
      mutRefTake (\_ -> (#arrayFrom 0, arrayFrom 0, 0#))

    bufferSize      = natVal n
    fftSize         = bufferSize / 2
    fftHalfSize     = fftSize / 2
    fftSizeMask     = fftSize - 1
    fftHalfSizeMask = fftHalfSize - 1
    overflowIndex1  = bitAnd (overflowIndex0 + audioBlockSize) fftHalfSizeMask
    -- TODO: statefulness in here is causing a crash....wtf???

    -- Resynthesize and fill overflow buffer
    (#overflowBuffer1, prevTimeDomain1#) =
      case maybeTimeDomain of
        Nothing         -> (#overflowBuffer0, prevTimeDomain0#)
        Just timeDomain ->
          loop (#overflowBuffer00, prevTimeDomain00#) = asTypeOfU overflowBuffer0 prevTimeDomain0 for fftIndex0 <- each do
            let
              fftIndex  = indexBackwards NatVal fftIndex0
              fftIndexU = indexToUInt fftIndex
            in
              if fftIndexU < fftHalfSize then
                -- write contents of first half of timeDomain buffer into prevTimeDomain buffer
                let
                  windowIndex      = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  windowSample     = readArray windowIndex window
                  timeDomainSample = readArray fftIndex timeDomain
                  sample           = timeDomainSample * windowSample
                  -- sample           = windowSample
                  -- sample           = indexToFloat index
                  -- sample           = timeDomainSample
                  index            = fftArraySizeGymnastics fftIndex (unsafeUIntToIndex fftIndexU)
                  prevTimeDomain01 = writeArray index sample prevTimeDomain00
                in
                  (#overflowBuffer00, prevTimeDomain01#)
              else if fftIndexU >= (bufferSize - 0) - fftHalfSize then
                -- use contents of second half of timeDomain buffer for resynthesis windowed against prevTimeDomain
                let
                  windowIndex              = fftIndexToZeroPhaseIndex bufferSize fftHalfSize fftIndex
                  w0                       = readArray windowIndex window
                  t0                       = readArray fftIndex timeDomain
                  (#t1, prevTimeDomain01#) = readArrayU (unsafeIndexToIndex windowIndex) prevTimeDomain00
                  sample                   = t0 * w0 + t1
                  -- sample                   = w0 + t1
                  overflowBuffer01         = writeArray (unsafeIndexToIndex windowIndex) sample overflowBuffer00
                in
                  (#overflowBuffer01, prevTimeDomain01#)
              else
                -- zero padding
                (#overflowBuffer00, prevTimeDomain00#)

    -- Fill audio buffer from overflowBuffer
    (#audio, overflowBuffer2#) =
      loop (#audio0, overflowBuffer10#) = (#audioInitArray (), overflowBuffer1#) for i <- each do
        let
          overflowIndex                = unsafeUIntToIndex (bitAnd (indexToUInt i + overflowIndex1) fftHalfSizeMask)
          (#sample, overflowBuffer11#) = readArrayU overflowIndex overflowBuffer10
          audio1                       = writeArray i sample audio0
        in
          (#audio1, overflowBuffer11#)
    -- overflowBuffer2 =
    --   if currBlockCount == 2048 then
    --     case writePlot2DToFileOnce "./data/timeDomainTest.dat" (freezeArray overflowBuffer2') primUndefined of
    --       _ -> primUndefined
    --   else
    --     overflowBuffer2'

-- Useful values
-- FFTSize        size: FFTSize
-- timeDomain     size: FFTSize
-- cBuffer        size: FFTSize
-- prevTimeDomain size: FFTSize / 2
-- overflowBuffer size: FFTSize / 2
-- window buffer  size: FFTSize

-- audioToTimeDomain :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Array BlockSize Float -> Maybe (*Array (NatMul BlockSize (NatMul k 4)) Complex)
-- audioToTimeDomain n (FFTWindow window) audio =
--   case mutRefPut (#cBufferEnd, cIndex1#) mref of
--     _ -> timeDomainEnd
--   where
--     (#(#cBuffer0, cIndex0#), mref#) = mutRefTake (\_ -> (#arrayFrom 0, 0#))
--     fftSize                         = natVal n
--     fftHalfSize                     = fftSize / 2
--     fftSizeMask                     = fftSize - 1
--     fftScaleFactor                  = 1 / fromUInt fftSize
--     cIndex1                         = bitAnd (cIndex0 + audioBlockSize) fftSizeMask
--     cBuffer2                        =
--       -- Copy data into circular buffer
--       loop cBuffer1 = cBuffer0 for i <- each do
--         writeArray (unsafeUIntToIndex (bitAnd (indexToUInt i + cIndex0) fftSizeMask)) (readArray i audio) cBuffer1
--     (#timeDomainEnd, cBufferEnd#) =
--       if cIndex1 == 0 || cIndex1 == fftHalfSize then
--         let
--           (#timeDomain, cBuffer5#) =
--             loop (#timeDomain0, cBuffer3#) = (#unsafeEmptyArray (), cBuffer2#) for fftIndex <- each do
--               let
--                 wx               = readArray fftIndex window
--                 circularIndex    = asTypeOf (unsafeUIntToIndex (bitAnd (indexToUInt fftIndex + cIndex1) fftSizeMask)) fftIndex
--                 (#ax, cBuffer4#) = readArrayU circularIndex cBuffer3
--                 c                = Complex# (ax * wx * fftScaleFactor) 0
--                 timeDomain1      = writeArray fftIndex c timeDomain0
--               in
--                 (#timeDomain1, cBuffer4#)
--         in
--           (#Just timeDomain, cBuffer5#)
--           -- if currBlockCount == 2048 then
--           --   case plotFFTChannelOnce "./data/timeDomainTest.dat" (FFT (freezeArray timeDomain)) primUndefined of
--           --     _ -> primUndefined
--           -- else
--       else
--         -- In between FFT blocks
--         (#Nothing, cBuffer2#)
--
-- ----------------------
-- -- timeDomainToAudio
-- -- Overlap-Add method: dspguide.com/ch18/1.htm
-- -- Use sine window for FFT and IFFT to combine for a Hann window?
-- -- This is the inverse of audioToTimeDomain
-- -- Performs overlay-add with a hop size of 2
-- -- Undoes zero phase buffering
--
-- -- TODO / NOTE: don't padd with zeroes!??!!?
-- timeDomainToAudio :: NatVal (NatMul BlockSize (NatMul k 4)) -> FFTWindow k -> Maybe (Array (NatMul BlockSize (NatMul k 4)) Float) -> Audio
-- timeDomainToAudio n (FFTWindow window) maybeTimeDomain =
--   case mutRefPut (#overflowBuffer2, prevTimeDomain1, overflowIndex1#) mref of
--     _ -> AudioRate (freezeArray audio)
--   where
--     (#(#overflowBuffer0, prevTimeDomain0, overflowIndex0#), mref#) =
--       mutRefTake (\_ -> (#arrayFrom 0, arrayFrom 0, 0#))
--
--     fftSize         = natVal n
--     fftHalfSize     = fftSize / 2
--     fftSizeMask     = fftSize - 1
--     fftHalfSizeMask = fftHalfSize - 1
--     fftScaleFactor  = 1 / fromUInt fftSize
--     overflowIndex1  = bitAnd (overflowIndex0 + audioBlockSize) fftHalfSizeMask
--     -- TODO: statefulness in here is causing a crash....wtf???
--
--     -- Resynthesize and fill overflow buffer
--     (#overflowBuffer1, prevTimeDomain1#) =
--       case maybeTimeDomain of
--         Nothing         -> (#overflowBuffer0, prevTimeDomain0#)
--         Just timeDomain ->
--           loop (#overflowBuffer00, prevTimeDomain00#) = asTypeOfU overflowBuffer0 prevTimeDomain0 for fftIndex <- each do
--             if indexToUInt fftIndex < fftHalfSize then
--               -- use contents of first half of timeDomain buffer for resynthesis windowed against prevTimeDomain
--               let
--                 w0                       = readArray fftIndex window
--                 t0                       = readArray fftIndex timeDomain
--                 (#t1, prevTimeDomain01#) = readArrayU (unsafeIndexToIndex fftIndex) prevTimeDomain00
--                 sample                   = t0 * w0 + t1
--                 -- sample                   = w0 + t1
--                 overflowBuffer01         = writeArray (unsafeIndexToIndex fftIndex) sample overflowBuffer00
--               in
--                 (#overflowBuffer01, prevTimeDomain01#)
--             else
--               -- write contents of second half of timeDomain buffer into prevTimeDomain buffer
--               let
--                 windowSample     = readArray fftIndex window
--                 timeDomainSample = readArray fftIndex timeDomain
--                 sample           = timeDomainSample * windowSample
--                 -- sample           = windowSample
--                 -- sample           = indexToFloat index
--                 -- sample           = timeDomainSample
--                 index            = fftArraySizeGymnastics fftIndex (unsafeUIntToIndex (indexToUInt fftIndex - fftHalfSize))
--                 prevTimeDomain01 = writeArray index sample prevTimeDomain00
--               in
--                 (#overflowBuffer00, prevTimeDomain01#)
--
--     -- Fill audio buffer from overflowBuffer
--     (#audio, overflowBuffer2#) =
--       loop (#audio0, overflowBuffer10#) = (#unsafeEmptyArray (), overflowBuffer1#) for i <- each do
--         let
--           overflowIndex                = unsafeUIntToIndex (bitAnd (indexToUInt i + overflowIndex1) fftHalfSizeMask)
--           (#sample, overflowBuffer11#) = readArrayU overflowIndex overflowBuffer10
--           audio1                       = writeArray i sample audio0
--         in
--           (#audio1, overflowBuffer11#)
--     -- overflowBuffer2 =
--     --   if currBlockCount == 2048 then
--     --     case writePlot2DToFileOnce "./data/timeDomainTest.dat" (freezeArray overflowBuffer2') primUndefined of
--     --       _ -> primUndefined
--     --   else
--     --     overflowBuffer2'


----------------------
-- DFT
-- Naive implementation

-- dftAudio :: NatVal (NatMul BlockSize (NatMax k 2)) -> Array BlockSize Float -> FFTWindow k -> FFT k
-- dftAudio n audio (FFTWindow window) =
--   FFT (freezeArray bins1)
--   where
--     numSamples   = natVal n
--     numSamplesF  = fromUInt numSamples
--     timeDomain   = audioToTimeDomain numSamples audio window |> freezeArray
--     bins1        =
--       loop bins0 = unsafeEmptyArray () for k <- each do
--         let
--           kr  = fromUInt (indexToUInt k)
--           bin =
--             loop (Complex# fr0 fi0) = Complex# 0 0 for i <- each do
--               let
--                 ir             = fromUInt (indexToUInt i)
--                 p              = 2 * pi * kr * ir / numSamplesF
--                 c              = cosine p
--                 s              = 0 - sine p
--                 Complex# tr ti = readArray (asTypeOf i k) timeDomain
--                 fr1            = fr0 + (tr * c - ti * s)
--                 fi1            = fi0 + (tr * s + ti * c)
--               in
--                 Complex# fr1 fi1
--         in
--           writeArray k bin bins0

----------------------
-- FFT
-- radix-2 with decimation in time

fftAudio :: NatVal (NatMul BlockSize (NatMul k 4)) -> *Array (NatMul BlockSize (NatMul k 4)) Complex -> FFT k
fftAudio n timeDomain =
  aout
  |> freezeArray
  |> FFT
  where
    numSamples   = natVal n
    numSamples1  = numSamples - 1
    halfSamples  = numSamples / 2
    shiftN       = bitShiftLeft halfSamples 1
    (#_, _, ar#) = -- bit reverse
      loop (#i, j, ar#) = (#1, 0, timeDomain#) while i < numSamples1 do
        let
          (#j', m#) =
            loop (#jj, mm#) = (#j, halfSamples#) while (jj >= mm) do
              (#jj - mm, bitShiftRight mm 1#)
          j1  = j' + m
          ar1 = if j1 > i then
            let
              (#ci, a1#) = readArrayU (unsafeUIntToIndex i) ar
              (#cj, a2#) = readArrayU (unsafeUIntToIndex j1) a1
            in
              writeArray (unsafeUIntToIndex j1) ci a2 |> writeArray (unsafeUIntToIndex i) cj
            else
              ar
        in
          (#i + 1, j1, ar1#)
    (#_, _, aout#) = -- FFT
      loop (#i, n0, a0#) = (#1, 1, ar#) while (i < shiftN) do
        let
          n1 = n0
          n2 = n1 + n1
          e  = negate (twoPi / fromUInt n2)
          (#_, _, a1#) =
            loop (#j, theta, a1#) = (#0, 0, a0#) while (j < n1) do
              let
                c = cosine theta
                s = sine theta
                (#_, a2#) =
                  loop (#k, a2#) = (#j, a1#) while (k < numSamples) do
                    let
                      kN1 = k + n1
                      (#Complex# kReal kImag, ar#) = readArrayU (unsafeUIntToIndex k) a2
                      (#Complex# nReal nImag, ar1#) = readArrayU (unsafeUIntToIndex kN1) ar
                      tempr = c * nReal - s * nImag
                      tempi = s * nReal + c * nImag
                      ck = Complex# (kReal + tempr) (kImag + tempi)
                      cn = Complex# (kReal - tempr) (kImag - tempi)
                      aw =
                        writeArray (unsafeUIntToIndex k) ck ar1 |>
                        writeArray (unsafeUIntToIndex kN1) cn
                    in
                      (#k + n2, aw#)
              in
                (#j + 1, theta + e, a2#)
        in
          (#bitShiftLeft i 1, n2, a1#)

ifftAudio :: Array (NatMul BlockSize (NatMul k 4)) Complex -> Array (NatMul BlockSize (NatMul k 4)) Float
ifftAudio freqDomain =
  ifftOut
  where
    numSamples   = arrayLength NatVal freqDomain
    numSamplesF  = fromUInt numSamples
    numSamples1  = numSamples - 1
    halfSamples  = numSamples / 2
    shiftN       = bitShiftLeft halfSamples 1
    (#_, _, ar#) = -- bit reverse
      loop (#i, j, ar#) = (#1, 0, deepCopyArray freqDomain#) while i < numSamples1 do
        let
          (#j', m#) =
            loop (#jj, mm#) = (#j, halfSamples#) while (jj >= mm) do
              (#jj - mm, bitShiftRight mm 1#)
          j1  = j' + m
          ar1 = if j1 > i then
            let
              (#ci, a1#) = readArrayU (unsafeUIntToIndex i) ar
              (#cj, a2#) = readArrayU (unsafeUIntToIndex j1) a1
            in
              writeArray (unsafeUIntToIndex j1) ci a2 |> writeArray (unsafeUIntToIndex i) cj
            else
              ar
        in
          (#i + 1, j1, ar1#)
    (#_, _, aout#) = -- IFFT
      loop (#i, n0, a0#) = (#1, 1, ar#) while (i < shiftN) do
        let
          n1 = n0
          n2 = n1 + n1
          e  = (twoPi / fromUInt n2)
          (#_, _, a1#) =
            loop (#j, theta, a1#) = (#0, 0, a0#) while (j < n1) do
              let
                c = cosine theta
                s = sine theta
                (#_, a2#) =
                  loop (#k, a2#) = (#j, a1#) while (k < numSamples) do
                    let
                      kN1 = k + n1
                      (#Complex# kReal kImag, ar#) = readArrayU (unsafeUIntToIndex k) a2
                      (#Complex# nReal nImag, ar1#) = readArrayU (unsafeUIntToIndex kN1) ar
                      tempr = c * nReal - s * nImag
                      tempi = s * nReal + c * nImag
                      ck = Complex# (kReal + tempr) (kImag + tempi)
                      cn = Complex# (kReal - tempr) (kImag - tempi)
                      aw =
                        writeArray (unsafeUIntToIndex k) ck ar1 |>
                        writeArray (unsafeUIntToIndex kN1) cn
                    in
                      (#k + n2, aw#)
              in
                (#j + 1, theta + e, a2#)
        in
          (#bitShiftLeft i 1, n2, a1#)
    -- ifftOut = map (\(Complex# r _) -> r / numSamplesF) (freezeArray aout)
    -- ifftOut = map (\(Complex# r _) -> r * numSamplesF) (freezeArray aout)
    ifftOut = map (\(Complex# r _) -> r) (freezeArray aout)

-- idftAudio :: Array (NatMul BlockSize (NatMax k 2)) Complex -> Audio
-- idftAudio freqDomain =
--   timeDomainToAudio numSamples windowSine (freezeArray bins1)
--   where
--     numSamples   = arrayLength NatVal freqDomain
--     numSamplesF  = fromUInt numSamples
--     bins1        =
--       loop bins0 = unsafeEmptyArray () for k <- each do
--         let
--           kr  = fromUInt (indexToUInt k)
--           bin =
--             loop (Complex# tr0 ti0) = Complex# 0 0 for i <- each do
--               let
--                 ir             = fromUInt (indexToUInt (asTypeOf i k))
--                 p              = 2 * pi * kr * ir / numSamplesF
--                 c              = cosine p
--                 s              = 0 - sine p
--                 Complex# fr fi = readArray i freqDomain
--                 tr1            = tr0 + (fr * c + fi * s)
--                 ti1            = ti0 + (fr * s - fi * c)
--               in
--                 Complex# tr1 ti1
--         in
--           writeArray k (realPart bin / numSamplesF) bins0

-- dft :: AudioFormat f => f Audio -> f (FFT k)
-- dft cs =
--   map f cs
--   where
--     f c =
--       case c of
--         AudioEnd    -> FFTEnd
--         BlockRate _ -> FFTNone
--         AudioRate a -> dftAudio NatVal a windowSine

fft :: AudioFormat f => f Audio -> f (FFT k)
fft cs =
  map f cs
  where
    f c =
      case c of
        AudioEnd        -> FFTEnd
        BlockRate _     -> FFTNone
        AudioRate audio ->
          case audioToTimeDomain NatVal windowSine audio of
            Nothing -> FFTInterval
            Just t  ->
              fftAudio NatVal t
              -- let
              --   bins = fftAudio NatVal t
              -- in
              --   if currBlockCount == 2048 then
              --       case plotFFTChannelOnce "./data/fftTest.dat" bins primUndefined of
              --         _ -> bins
              --   else
              --     bins

fft' :: AudioFormat f => NatVal k -> f Audio -> f (FFT k)
fft' _ cs =
  fft cs

-- idft :: AudioFormat f => f (FFT k) -> f Audio
-- idft cs =
--   map f cs
--   where
--     f c =
--       case c of
--         FFTEnd   -> AudioEnd
--         FFTNone  -> BlockRate 0
--         FFT bins -> idftAudio bins

data IFFTResult a
  = IFFTEnd
  | IFFTNone
  | IFFTResult (Maybe a)

ifft :: AudioFormat f => f (FFT k) -> f Audio
ifft cs =
  map f cs
  where
    f c =
      case result of
        IFFTEnd               -> AudioEnd
        IFFTNone              -> BlockRate 0
        IFFTResult ifftResult -> timeDomainToAudio NatVal windowSine ifftResult
      where
        result =
          case c of
            FFTEnd      -> IFFTEnd
            FFTNone     -> IFFTNone
            FFTInterval -> IFFTResult Nothing
            FFT bins    -> IFFTResult (Just (ifftAudio bins))

--------------------------
-- FFT Effects

convolve :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
convolve a b = map2 (\ca cb -> mapFFT2 (*) ca cb) a b

fftConj :: AudioFormat f => f (FFT k) -> f (FFT k)
fftConj c = mapFFTAudio conjugate c

-- Question: Would this be better named as fftMapBins?
mapFFTAudio :: AudioFormat f => (Complex -> Complex) -> f (FFT k) -> f (FFT k)
mapFFTAudio f c = map (\cc -> mapFFT f cc) c

mapFFTAudio2 :: AudioFormat f => (Complex -> Complex -> Complex) -> f (FFT k) -> f (FFT k) -> f (FFT k)
mapFFTAudio2 f a b = map2 (\ca cb -> mapFFT2 f ca cb) a b

-- negate bins of fft
fftNegate :: AudioFormat f => f (FFT k) -> f (FFT k)
fftNegate a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl (Complex# ar ai) = Complex# (negate ar) (negate ai)

-- Map the supplied function onto the magnitude of the bins, but maintain phase
fftMapMag :: AudioFormat f => (Float -> Float) -> f (FFT k) -> f (FFT k)
fftMapMag f a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl cma = mkPolar (f <| magnitude cma) (phase cma)

-- Map the supplied function using the magnitude of the bins of the two inputs,
-- while maintaining the phase of the first input
fftMapMag2 :: AudioFormat f => (Float -> Float -> Float) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftMapMag2 f a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (f mA mB) (phase cma)
      where
        mA = magnitude cma
        mB = magnitude cmb

-- Multiply magnitudes of a and b, but keep phase of a
fftMagMul :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMul a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (mA * mB) <| phase cma
      where
        mA = magnitude cma
        mB = magnitude cmb

-- Add magnitudes of a and b, but keep phase of a
fftMagAdd :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagAdd a b = fftMapMag2 (+) a b

-- max of magnitudes of a and b, but keep phase of a
fftMagMax :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMax a b = fftMapMag2 max a b

-- min of magnitudes of a and b, but keep phase of a
fftMagMin :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMagMin a b = fftMapMag2 min a b

-- square of magnitudes of fft
fftMagSquared :: AudioFormat f => f (FFT k) -> f (FFT k)
fftMagSquared a = fftMapMag sqr a

-- square root of magnitudes of fft
fftMagSqrRoot :: AudioFormat f => f (FFT k) -> f (FFT k)
fftMagSqrRoot a = fftMapMag sqrt a

fftLerp :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerp delta x y =
  mapFFTAudio2 (\cx cy -> lerpComplex cx cy delta) x y

fftLerpPolar :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerpPolar delta x y =
  mapFFTAudio2 f x y
  where
    f cx cy =
      mkPolar m p
      where
        (#mx, px#) = polar' cx
        (#my, py#) = polar' cy
        m          = lerp mx my delta
        p          = lerp px py delta

fftLerpMag :: AudioFormat f => Float -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftLerpMag delta x y =
  fftMapMag2 (\mx my -> lerp mx my delta) x y

fftMulPolar :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftMulPolar x y =
  mapFFTAudio2 f x y
  where
    f cx cy =
      mkPolar m p
      where
        (#mx, px#) = polar' cx
        (#my, py#) = polar' cy
        m          = mx * my
        p          = px * py

-- Keeps the magnitudes of a, but takes the phase of b
fftCopyPhase :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftCopyPhase a b = mapFFTAudio2 (copyphase) a b
  where
    copyphase cma cmb = Complex# (magnitude cma) (phase cmb)

-- Map the supplied function using the phase of the bins of the two inputs,
-- while maintaining the magnitude of the first input
fftMapPhase2 :: AudioFormat f => (Float -> Float -> Float) -> f (FFT k) -> f (FFT k) -> f (FFT k)
fftMapPhase2 f a b = map2 (\ca cb -> mapFFT2 mImpl ca cb) a b
  where
    mImpl cma cmb = mkPolar (magnitude cma) (f pA pB)
      where
        pA = phase cma
        pB = phase cmb

-- TODO / NOTE: Why can we only shift bins by UInt and not Int?
-- shifts bins by offset
fftShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              bin = readArray index a
            in
              writeArray i bin b
      in
        freezeArray b

-- shift magnitudes of bins
fftMagShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftMagShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              r = readArray index a
              u = readArray i a
              result     = mkPolar (magnitude r) (phase u)
            in
              writeArray i result b
      in
        freezeArray b

-- shift phases of bins
fftPhaseShift :: AudioFormat f => UInt -> f (FFT k) -> f (FFT k)
fftPhaseShift n f = mapFFTBuffer shift f
  where
    shift a =
      let
        numSamples = arrayLength NatVal a
        b =
          loop b = unsafeEmptyArray () for i <- each do
            let
              index = unsafeUIntToIndex ((indexToUInt i + n) % numSamples)
              r = readArray index a
              u = readArray i a
              result     = mkPolar (magnitude u) (phase r)
            in
              writeArray i result b
      in
        freezeArray b

-- use a lambda to map phases (index -> phase -> new phase)
fftMapPhase :: AudioFormat f => (UInt -> Float -> Float) -> f (FFT k) -> f (FFT k)
fftMapPhase p f = mapFFTBuffer mapping f
  where
    mapping a = freezeArray <|
      loop b = unsafeEmptyArray () for i <- each do
        let
          c = readArray i a
          bin = mkPolar (magnitude c) (p (indexToUInt i) (phase c))
        in
          writeArray i bin b

-- project the entire buffer of A onto B,
-- interpretting the buffers as higher dimensional vectors of complex numbers
fftProjection :: Mono (FFT k) -> Mono (FFT k) -> Mono (FFT k)
fftProjection a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        (#sqrNorm, dot#) =
          loop (#sqrNorm, dot#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              cv = conjugate v
              uv = u * cv
              vv = v * cv
            in
              (#sqrNorm + vv, dot + uv#)
        norm = sqrt sqrNorm
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              v = readArray i bb
            in
              writeArray i (v / norm * dot) bc

-- project the entire buffer of A onto B,
-- interpretting the buffers as higher dimensional vectors of complex numbers
fftParallelProjection :: Mono (FFT k) -> Mono (FFT k) -> Mono (FFT k)
fftParallelProjection a b = composeFFTBuffers compose a b
  where
    compose ba bb = bc |> freezeArray
      where
        (#sqrNorm, dot#) =
          loop (#sqrNorm, dot#) = (#Complex# 0 0, Complex# 0 0#) for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
              cv = conjugate v
              uv = u * cv
              vv = v * cv
            in
              (#sqrNorm + vv, dot + uv#)
        norm = sqrt sqrNorm
        bc =
          loop bc = unsafeEmptyArray () for i <- each do
            let
              u = readArray i ba
              v = readArray i bb
            in
              writeArray i (u - (v / norm * dot)) bc

-- projection of the complex bins of a onto b, interpretting each bin as real 2D vectors
fftBinProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = Complex# (nbr * d) (nbi * d)
      where
        mb = magnitude (Complex# br bi)
        (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
        d = (ar * br + ai * bi)

-- projection of the mag/phase of the bins of a onto b,
-- interpretting polar coordinates as real 2D vectors
fftBinPolarProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinPolarProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = mkPolar (nmb * d) (npb * d)
      where
        ca = Complex# ar ai
        cb = Complex# br bi
        ma = magnitude ca
        mb = magnitude cb
        pa = phase ca
        pb = phase cb
        sqa = ma * ma + pa * pa
        pma = if sqa /= 0 then sqrt sqa else 0
        sqb = mb * mb + pb * pb
        pmb = if sqb /= 0 then sqrt (mb * mb + pb * pb) else 0
        (#nmb, npb#) = if pmb > 0 then (#(mb / pmb), (pb / pmb)#) else (#0, 0#)
        d = (ma * mb + pa * pb)

-- parallel projection of the complex bins of a onto b, interpretting each bin as real 2D vectors
fftBinParallelProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinParallelProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = Complex# (ar - nbr * d) (ai - nbi * d)
      where
        mb = magnitude (Complex# br bi)
        (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
        d = (ar * br + ai * bi)

-- parallel projection of the mag/phase of the bins of a onto b,
-- interpretting polar coordinates as real 2D vectors
fftBinPolarParallelProjection :: AudioFormat f => f (FFT k) -> f (FFT k) -> f (FFT k)
fftBinPolarParallelProjection a b = mapFFTAudio2 dot a b
  where
    dot (Complex# ar ai) (Complex# br bi) = mkPolar (ma - (nmb * d)) (pa - (npb * d))
      where
        ca = Complex# ar ai
        cb = Complex# br bi
        ma = magnitude ca
        mb = magnitude cb
        pa = phase ca
        pb = phase cb
        smb = mb * mb + pb * pb
        pmb = if smb /= 0 then sqrt smb else 0
        (#nmb, npb#) = if pmb > 0 then (#(mb / pmb), (pb / pmb)#) else (#0, 0#)
        d = (ma * mb + pa * pb)

-- projection the complex bins of a onto b, interpretting each bin as real 2D vectors
fftComplexProjection :: AudioFormat f => Complex -> f (FFT k) -> f (FFT k)
fftComplexProjection (Complex# br bi) a = mapFFTAudio dot a
  where
    (Complex# nbr nbi) = if mb > 0 then Complex# (br / mb) (bi / mb) else Complex# 0 0
    mb = magnitude (Complex# br bi)
    dot (Complex# ar ai) = Complex# (nbr * d) (nbi * d)
      where
        d = (ar * br + ai * bi)

-- rotate phases by radians
fftPhaseRotate :: AudioFormat f => Float -> f (FFT k) -> f (FFT k)
fftPhaseRotate f a = map (\ca -> mapFFT mImpl ca) a
  where
    mImpl cma = mkPolar (magnitude cma) (phase cma |> add f)

fftComplexPlaneAttack :: AudioFormat f => Complex -> f (FFT k) -> f (FFT k)
fftComplexPlaneAttack z f = mapFFTAudio mapping f
  where
    mapping a = (z - a) / (1 - (z * conjugate a))

fftIsogonalMapA :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapA f = mapFFTAudio mapping f
  where
    sqrt2 = sqrt 2
    mapping z = sqrt2 * (conjugate <| sqrt (1 / z))

fftIsogonalMapB :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapB f = mapFFTAudio mapping f
  where
    mapping z = (pow z 2) / 2

fftIsogonalMapC :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapC f = mapFFTAudio mapping f
  where
    sqrt2 = sqrt 2
    mapping z = sqrt2 * sqrt z

fftIsogonalMapD :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapD f = mapFFTAudio mapping f
  where
    mapping z = 1 / z

fftIsogonalMapE :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapE f = mapFFTAudio mapping f
  where
    mapping z = exp z

fftIsogonalMapF :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapF f = mapFFTAudio mapping f
  where
    mapping z = sine z

fftIsogonalMapG :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapG f = mapFFTAudio mapping f
  where
    mapping z = cosine z

fftIsogonalMapH :: AudioFormat f => f (FFT k) -> f (FFT k)
fftIsogonalMapH f = mapFFTAudio mapping f
  where
    mapping z = sqrt (2 / z)

--------------------------

plotAudioOnce :: Array n Char -> Mono Audio -> *World -> *World
plotAudioOnce name (Mono a) w =
    case a of
      AudioEnd    -> w
      BlockRate _ -> w
      AudioRate audioBuffer -> writePlot2DToFileOnce name audioBuffer w

plotFFTChannelOnce :: Array n Char -> FFT k -> *World -> *World
plotFFTChannelOnce name f w =
  case f of
    FFT fftBuffer ->
      let
        realBuffer =
          freezeArray
          <| loop realBuffer0 = unsafeEmptyArray () for i <- each do
            writeArray i (magnitude (readArray i fftBuffer)) realBuffer0
      in
        writePlot2DToFileOnce name realBuffer w
    _ -> w

plotFFTOnce :: Array n Char -> Mono (FFT k) -> *World -> *World
plotFFTOnce name (Mono fftBuffer) w =
  plotFFTChannelOnce name fftBuffer w


--------------------
-- AudioFormat
--------------------
data Mono a             = Mono a
data Stereo a           = Stereo# a a
data Quad a             = Quad# a a a a
data Ambisonic a        = Ambisonic# a a a a
data Seconds (n :: Nat) = Seconds

-- TODO: Equal power panning
class (Functor f, FunctorN f, Applicative f, Foldable f) => AudioFormat f where
  accumulate1  :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio
  accumulate2  :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio
  accumulate3  :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio -> f Audio
  accumulate1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio
  accumulate2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio
  accumulate3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio -> f Audio
  pan          :: Mono Audio -> f Audio -> Stereo Audio
  mixMono      :: Num a => f a -> Mono a
  mixStereo    :: Num a => f a -> Stereo a
  outAudio     :: UInt -> f Audio -> *World -> *World
  numChannels  :: f Audio -> UInt

stereo :: Mono a -> Mono a -> Stereo a
stereo (Mono l) (Mono r) = Stereo# l r

left :: Stereo a -> Mono a
left (Stereo# l _) = Mono l

right :: Stereo a -> Mono a
right (Stereo# _ r) = Mono r

flipStereo :: Stereo a -> Stereo a
flipStereo (Stereo# l r) = Stereo# r l

instance Functor Mono where
  map f (Mono x) = Mono (f x)

instance FunctorN Mono where
  map2 f (Mono x) (Mono y)                   = Mono (f x y)
  map3 f (Mono x) (Mono y) (Mono z)          = Mono (f x y z)
  map4 f (Mono w) (Mono x) (Mono y) (Mono z) = Mono (f w x y z)

instance Applicative Mono where
  pure x               = Mono x
  ap (Mono f) (Mono x) = Mono (f x)

instance Foldable Mono where
  fold (Mono x)      = x
  foldl f i (Mono x) = f i x

instance AudioFormat Mono where
  outAudio  n (Mono c)  w                                = outChannel n c w
  accumulate1 f isRunning (Mono c)                       = Mono (accumulateAudio1 f isRunning c)
  accumulate2 f isRunning (Mono x) (Mono y)              = Mono (accumulateAudio2 f isRunning x y)
  accumulate3 f isRunning (Mono x) (Mono y) (Mono z)     = Mono (accumulateAudio3 f isRunning x y z)
  accumulate1U mk f isRunning (Mono c)                   = Mono (accumulateAudio1U mk f isRunning c)
  accumulate2U mk f isRunning (Mono x) (Mono y)          = Mono (accumulateAudio2U mk f isRunning x y)
  accumulate3U mk f isRunning (Mono x) (Mono y) (Mono z) = Mono (accumulateAudio3U mk f isRunning x y z)
  pan (Mono amount) (Mono input)                         = Stereo# (input * (1 - amount)) (input * amount)
  mixMono x                                              = x
  mixStereo (Mono x)                                     = Stereo# x x
  numChannels _                                          = 1

instance Functor Stereo where
  map f (Stereo# x y) = Stereo# (f x) (f y)

instance FunctorN Stereo where
  map2 f (Stereo# x1 x2) (Stereo# y1 y2)                                 = Stereo# (f x1 y1) (f x2 y2)
  map3 f (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2)                 = Stereo# (f x1 y1 z1) (f x2 y2 z2)
  map4 f (Stereo# w1 w2) (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2) = Stereo# (f w1 x1 y1 z1) (f w2 x2 y2 z2)

instance Applicative Stereo where
  pure x                             = Stereo# x x
  ap (Stereo# f1 f2) (Stereo# x1 x2) = Stereo# (f1 x2) (f2 x2)

instance Foldable Stereo where
  fold (Stereo# l r)      = l <> r
  foldl f i (Stereo# l r) = f (f i l) r

instance AudioFormat Stereo where
  outAudio  n (Stereo# l r) w                                                 = outChannel (n + 1) r (outChannel n l w)
  accumulate1 f isRunning (Stereo# l r)                                       = Stereo# (accumulateAudio1 f isRunning l) (accumulateAudio1 f isRunning r)
  accumulate2 f isRunning (Stereo# xl xr) (Stereo# yl yr)                     = Stereo# (accumulateAudio2 f isRunning xl yl) (accumulateAudio2 f isRunning xr yr)
  accumulate3 f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr)     = Stereo# (accumulateAudio3 f isRunning xl yl zl) (accumulateAudio3 f isRunning xr yr zr)
  accumulate1U mk f isRunning (Stereo# l r)                                   = Stereo# (accumulateAudio1U mk f isRunning l) (accumulateAudio1U mk f isRunning r)
  accumulate2U mk f isRunning (Stereo# xl xr) (Stereo# yl yr)                 = Stereo# (accumulateAudio2U mk f isRunning xl yl) (accumulateAudio2U mk f isRunning xr yr)
  accumulate3U mk f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr) = Stereo# (accumulateAudio3U mk f isRunning xl yl zl) (accumulateAudio3U mk f isRunning xr yr zr)
  pan (Mono amount) (Stereo# l r)                                             = Stereo# (l * (1 - amount)) (r * amount)
  mixMono (Stereo# l r)                                                       = Mono (l + r)
  mixStereo x                                                                 = x
  numChannels _                                                               = 2

-- Mono
instance Eq a => Eq (Mono a) where
  eq  (Mono x) (Mono y) = eq x y
  neq (Mono x) (Mono y) = neq x y

instance Semiring a => Semiring (Mono a) where
  zero                  = Mono zero
  one                   = Mono one
  add (Mono x) (Mono y) = Mono (x + y)
  mul (Mono x) (Mono y) = Mono (x * y)

instance Ring a => Ring (Mono a) where
  fromInt i             = Mono (fromInt i)
  sub (Mono x) (Mono y) = Mono (x - y)

instance EuclideanRing a => EuclideanRing (Mono a) where
  div (Mono x) (Mono y) = Mono (x / y)
  rem (Mono x) (Mono y) = Mono (rem x y)

instance DivisionRing a => DivisionRing (Mono a) where
  recip (Mono c) = Mono (recip c)

instance Num a => Num (Mono a) where
  signum (Mono c) = Mono (signum c)
  abs    (Mono c) = Mono (abs c)
  copysign (Mono x) (Mono sign) = Mono (copysign x sign)

instance Field a => Field (Mono a) where

instance Floating a => Floating (Mono a) where
  fromFloat f   = Mono (fromFloat f)
  sqrt (Mono c) = Mono (sqrt c)
  floor    (Mono x) = Mono (floor x)
  ceil     (Mono x) = Mono (ceil x)
  truncate (Mono x) = Mono (truncate x)
  round    (Mono x) = Mono (round x)
  -- fmin     (Mono x) (Mono y) = Mono (fmin x y)
  -- fmax     (Mono x) (Mono y) = Mono (fmax x y)

instance Semigroup a => Semigroup (Mono a) where
  append (Mono x) (Mono y) = Mono (append x y)

instance Monoid a => Monoid (Mono a) where
  mempty = Mono mempty

-- Stereo
instance Eq a => Eq (Stereo a) where
  eq  (Stereo# xl xr) (Stereo# yl yr) = eq xl yl && eq xr yr
  neq (Stereo# xl xr) (Stereo# yl yr) = neq xl yl || neq xr yr

instance Semiring a => Semiring (Stereo a) where
  zero                                = Stereo# zero zero
  one                                 = Stereo# one one
  add (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl + yl) (xr + yr)
  mul (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl * yl) (xr * yr)

instance Ring a => Ring (Stereo a) where
  fromInt i                           = let c = fromInt i in Stereo# c c
  sub (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl - yl) (xr - yr)

instance EuclideanRing a => EuclideanRing (Stereo a) where
  div (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl / yl) (xr / yr)
  rem (Stereo# xl xr) (Stereo# yl yr) = Stereo# (rem xl yl) (rem xr yr)

instance DivisionRing a => DivisionRing (Stereo a) where
  recip (Stereo# l r) = Stereo# (recip l) (recip r)

instance Num a => Num (Stereo a) where
  signum (Stereo# l r) = Stereo# (signum l) (signum r)
  abs    (Stereo# l r) = Stereo# (abs l) (abs r)
  copysign (Stereo# lx rx) (Stereo# ly ry) = Stereo# (copysign lx ly) (copysign rx ry)

instance Field a => Field (Stereo a) where

instance Floating a => Floating (Stereo a) where
  fromFloat f        = let c = (fromFloat f) in Stereo# c c
  sqrt (Stereo# l r) = Stereo# (sqrt l) (sqrt r)
  floor    (Stereo# l r) = Stereo# (floor l) (floor r)
  ceil     (Stereo# l r) = Stereo# (ceil l) (ceil r)
  truncate (Stereo# l r) = Stereo# (truncate l) (truncate r)
  round    (Stereo# l r) = Stereo# (round l) (round r)
  -- fmin     (Stereo# lx ry) (Stereo# ly ry) = Stereo# (fmin lx ly) (fmin ry ry)
  -- fmax     (Stereo# lx ry) (Stereo# ly ry) = Stereo# (fmax lx ly) (fmax ry ry)

instance Semigroup a => Semigroup (Stereo a) where
  append (Stereo# xl xr) (Stereo# yl yr)  = Stereo# (append xl yl) (append xr yr)

instance Monoid a => Monoid (Stereo a) where
  mempty = Stereo# mempty mempty


--------------------
-- Audio File
--------------------

data LoopType = Loop | DontLoop

-- TODO: Derive enum with efficient implementations
instance Enum LoopType where
  toEnum   x = if x == 0 then Loop else DontLoop
  fromEnum x =
    case x of
      Loop -> 0
      _    -> 1

instance Eq LoopType where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

data AudioFile =
  AudioFile#
    UInt        -- numChannels
    UInt        -- numSamples
    (Ptr Float) -- data

silentAudioFile :: AudioFile
silentAudioFile =
  AudioFile# 0 0 primUndefined

unsafeAudioFileOpen :: Ptr Char -> UInt -> Ptr ()
unsafeAudioFileOpen fileNamePtr fileNameLength =
  primUndefined

audioFileOpen :: Array n Char -> Maybe AudioFile
audioFileOpen fileName =
  snd' maybeMaybeAudioFile
  where
    maybeMaybeAudioFile ~ (#0, Nothing#) =
      if fst' maybeMaybeAudioFile > 0 then
        maybeMaybeAudioFile
      else
        let
          AudioFile# numChannels numSamples dataPtr =
            unsafeAudioFileOpen (unsafeArrayToPtr fileName) (arrayLength NatVal fileName)
            |> unsafePtrCast
            |> unsafePtrPeek 0
        in
          if numSamples == 0 then
            (#1, Nothing#)
          else
            (#1, Just (AudioFile# numChannels numSamples dataPtr)#)

-- TODO: Loop type!
audioFilePlayTick :: UInt -> LoopType -> UInt -> UInt -> Ptr Float -> Float -> Float -> (#Float, Float#)
audioFilePlayTick channelNum loopType numChannels numSamples dataPtr freq phase0 =
  (#phase1, out#)
  where
    numFrames = numChannels * numSamples
    phase1    = fma freq recipSampleRate phase0
    findex    = phase1 * audioSampleRateF
    delta     = (floor findex + 1) - findex
    index1    = floatToUInt findex * numChannels + channelNum
    index0    = index1 - numChannels
    index2    = index1 + numChannels
    index3    = index2 + numChannels
    out       =
      if (loopType == DontLoop) && (index0 >= numSamples || index1 >= numSamples || index2 >= numSamples || index3 >= numSamples) then
        0
      else
        let
          sample0 = unsafePtrPeek (index0 % numSamples) dataPtr
          sample1 = unsafePtrPeek (index1 % numSamples) dataPtr
          sample2 = unsafePtrPeek (index2 % numSamples) dataPtr
          sample3 = unsafePtrPeek (index3 % numSamples) dataPtr
        in
          cubicInterpolation sample0 sample1 sample2 sample3 delta

-- TODO: data folder?
-- TODO: Sum type for AudioFile instead of manually checking against members for validity
-- TODO / HACK: Punting and doing mono audio files for now. In the future figure out how to map audio files to AudioFormat (maybe stick in class definition?)
audioFilePlay :: LoopType -> Mono Audio -> AudioFile -> Mono Audio
audioFilePlay loopType freq (AudioFile# numChannels numSamples dataPtr) =
  if numChannels == 0 || numSamples == 0 then
    0
  else
    accumulate1 (audioFilePlayTick 0 loopType numChannels numSamples dataPtr) constTrue freq


----------------------
-- AudioBuffer
-- Represents a non-interleaved single channel of audio data inside a dynamically sized array of data
----------------------

data AudioBuffer = AudioBuffer (.Ptr Float) UInt
-- TODO: audioBufferFromFile :: AudioFormat f => AudioFile -> f AudioBuffer
-- TODO: recordIntoAudioBuffer :: AudioFormat f => Nat s -> LoopType -> f Audio -> f AudioBuffer

audioBufferPlayTick :: AudioBuffer -> LoopType -> Float -> Float -> (#Float, Float#)
audioBufferPlayTick (AudioBuffer audioBuffer numSamples) loopType freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    findex = phase1 * audioSampleRateF
    delta  = (floor findex + 1) - findex
    index1 = floatToUInt findex
    index0 = index1 - 1
    index2 = index1 + 1
    index3 = index2 + 1
    out    =
      if (loopType == DontLoop) && (index0 >= numSamples || index1 >= numSamples || index2 >= numSamples || index3 >= numSamples) then
        0
      else
        let
          sample0 = unsafePtrPeek (index0 % numSamples) audioBuffer
          sample1 = unsafePtrPeek (index1 % numSamples) audioBuffer
          sample2 = unsafePtrPeek (index2 % numSamples) audioBuffer
          sample3 = unsafePtrPeek (index3 % numSamples) audioBuffer
        in
          cubicInterpolation sample0 sample1 sample2 sample3 delta

audioBufferPlay :: AudioFormat f => LoopType -> f Audio -> f AudioBuffer -> f Audio
audioBufferPlay loopType freq audioBuffers =
  map2 f audioBuffers freq
  where
    f ab fc =
      accumulateAudio1 (audioBufferPlayTick ab loopType) constTrue fc


----------------------
-- Record Audio
----------------------
-- TODO: Sprinkle World around a bit more in here!

data ScratchBuffer = ScratchBuffer (Ptr (.Ptr ()))

recordAudioBlock :: UInt -> UInt -> Array BlockSize Float -> *ScratchBuffer -> *ScratchBuffer
recordAudioBlock channelIndex channelCount audio scratchBuffer =
  primUndefined

recordAudioBlockFinalize :: Ptr Char -> UInt -> UInt -> *ScratchBuffer -> *ScratchBuffer
recordAudioBlockFinalize name nameLength channelCount scratchBuffer =
  primUndefined

recordAudioChannel :: Array n Char -> UInt -> UInt -> (#UInt, *ScratchBuffer#) -> Audio -> (#UInt, *ScratchBuffer#)
recordAudioChannel name nameLength channelCount (#i, sbuffer#) channel =
  case channel of
    AudioRate abuffer -> (#i + 1, recordAudioBlock i channelCount abuffer sbuffer#)
    BlockRate _       -> (#i + 1, sbuffer#)
    AudioEnd          -> (#i + 1, recordAudioBlockFinalize (unsafeArrayToPtr name) nameLength channelCount sbuffer#)

recordAudio :: AudioFormat f => Array n Char -> f Audio -> *World -> *World
recordAudio name audio world =
  case mutRefTake (\_ -> ScratchBuffer (unsafePtrPoke 0 primUndefined (ptrMalloc 1))) of
    (#scratchBuffer0, mref#) ->
      let
        nameLength            = arrayLength NatVal name
        channelCount          = numChannels audio
        (#_, scratchBuffer1#) =
          foldl (recordAudioChannel name nameLength channelCount) (#0, scratchBuffer0#) audio
      in
        case mutRefPut scratchBuffer1 mref of
          _ -> world



--------------------
-- UGens
--------------------

--------------------
-- downsample oversampled audio
sinc :: Float -> Float
sinc x =
  if x > -0.000001 && x < 0.000001 then 1.0 else
    sine x / x

bessel :: Float -> Float
bessel x =
  add 1 <| snd'<|
    loop (#i, sum#) = (#1, 0#) while i < 10 do
      let
        xpow = pow (x / 2) (fromUInt i)
        fac  =
          fromUInt <| snd' <|
            loop (#j, fac'#) = (#1, 1#) while j <= i do
              (#j + 1, fac' * j#)
      in
        (#i + 1, sum + pow (xpow / fac) 2#)

kaiserBesselWindowFunction :: Float -> Float -> Float -> Float
kaiserBesselWindowFunction i windowSize beta =
  window
  where
    warg   = beta * sqrt (1 - pow (((2 * i + 2) - windowSize) / windowSize) 2)
    window = bessel warg / bessel beta

hannWindowFunction :: Float -> Float -> Float
hannWindowFunction i windowSize =
  0.5 - (0.5 * cosine (tau * (i + 1) / windowSize))

hammingWindowFunction :: Float -> Float -> Float
hammingWindowFunction i windowSize =
  0.54 - (0.46 * cosine (tau * (i + 1) / windowSize))

nuttallBlackmanWindowFunction :: Float -> Float -> Float
nuttallBlackmanWindowFunction i windowSize =
  0.355768 -
  (0.487396 * cosine ((2.0 * pi * i) / windowSize)) +
  (0.144232 * cosine ((4.0 * pi * i) / windowSize)) -
  (0.012604 * cosine ((6.0 * pi * i) / windowSize))

-- downsampleCoefficients :: Array 32 Float
-- downsampleCoefficients =
--   freezeArray coeff3
--   where
--     windowSize = 32
--     freqCutoff = 20000
--     omega      = freqCutoff / (audioSampleRateF * fromUInt audioOverSampleAmount)
--     coeff1     =
--       loop a = unsafeEmptyArray () for i <- each do
--         let
--           iReal       = fromUInt (indexToUInt i)
--           iOffset     = iReal - ((windowSize - 1) / 2)
--           window      = kaiserBesselWindowFunction iReal windowSize 3
--           coefficient = omega * sinc (omega * iOffset * pi) * window
--         in
--           writeArray i coefficient a
--     (#gainSum, coeff2#) =
--       loop (#sum, a0#) = (#0, coeff1#) for i <- each do
--         case readArrayU i a0 of
--           (#x, a1#) ->
--             (#sum + x, a1#)
--     gainAdjust = 1.25 -- (1 / gainSum) * (1 / windowSize)
--     coeff3     =
--       loop a0 = coeff2 for i <- each do
--         case readArrayU i a0 of
--           (#x, a1#) ->
--             writeArray i (x * gainAdjust) a1

-----------
-- saw

-- Oversampling saw wave, Some reading:
--   * PHASESHAPING OSCILLATOR ALGORITHMS FOR MUSICAL SOUND SYNTHESIS:
--       https://eprints.maynoothuniversity.ie/4100/1/SMC2010.pdf
--   * Antialiasing Oscillators in Subtractive Synthesis
--   * Audible Aliasing Distortion in Digital Audio Synthesis
--       https://www.researchgate.net/publication/268382833_Audible_Aliasing_Distortion_in_Digital_Audio_Synthesis

-- data OverSampleSawState = OverSampleSawState# Float UInt (.Array 32 Float)

-- mkOverSampleSawState :: () -> *OverSampleSawState
-- mkOverSampleSawState _ = OverSampleSawState# 0 0 (arrayFrom 0)

-- -- TODO: Replace FIR filter with IIR filter?
-- -- Oversampling saw oscillator, with FIR downsampling
-- accumulateSawFIR :: Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulateSawFIR freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 63)) (fma (phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 63)) (fma (phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 63)) (fma (phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 63)) (fma (phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 63)) (fma (phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 63)) (fma (phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 63)) (fma (phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 63)) (fma (phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 63, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 64 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 63)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 63)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 63)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 63)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 63)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 63)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 63)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 63)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 63, d8, firResult#)
--
-- sawFIR :: AudioFormat f => f Audio -> f Audio
-- sawFIR freq =
--   accumulate1U mkOverSampleSawState accumulateSawFIR constTrueU freq

-- data OverSampleSawStateIIR = OverSampleSawStateIIR# Float Float Float Float Float

-- instance Default OverSampleSawStateIIR where
--   default = OverSampleSawStateIIR# 0 0 0 0 0

-- -- Brickwall filter constants
-- ffreqBrickWall = 20000
-- gainBrickWall  = -28
-- slopeBrickWall = 1
-- bigaBrickWall  = pow 10 (gainBrickWall / 40)
-- omegaBrickWall = ffreqBrickWall * audioRecipOverSampleRate * tau
-- csoBrickWall   = cosine omegaBrickWall
-- alphaBrickWall = sine omegaBrickWall * 0.5 * sqrt (((bigaBrickWall + (1 / bigaBrickWall)) * ((1 / slopeBrickWall) - 1)) + 2)
-- betaBrickWall  = 2 * sqrt bigaBrickWall * alphaBrickWall

-- -- Oversampling saw wave with IIR brickwall filter
-- -- TODO: Upsample frequency?!?!!?
-- accumulateSaw :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateSaw freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (phase1 - floor phase1) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (phase2 - floor phase2) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (phase3 - floor phase3) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (phase4 - floor phase4) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (phase5 - floor phase5) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (phase6 - floor phase6) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (phase7 - floor phase7) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (phase8 - floor phase8) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)

----------------------
-- minBLEP
--
-- Hard Sync Without Aliasing:
--   http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf
--
-- ExperimentalScene article on MinBLEPs with nice code examples
-- https://www.experimentalscene.com/articles/minbleps.php
--
-- Minimum phase filters
--   https://ccrma.stanford.edu/~jos/fp/Creating_Minimum_Phase_Filters.html
----------------------

data MinBlepBuffer z o = MinBlepBuffer (.Array (NatMul (NatMul z 2) o) Float)
data MinBlepFFT    z o = MinBlepFFT (.Array (NatMul (NatMul z 2) o) Complex)

-- Slow n' dirty fft
minBlepFFT :: UInt -> MinBlepFFT z o -> *MinBlepFFT z o
minBlepFFT n (MinBlepFFT timeDomain) =
  MinBlepFFT bins1
  where
    rn           = fromUInt n
    bins0        = arrayFrom (Complex# 0 0)
    (#_, bins1#) =
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = 0 - sine p
                (#Complex# fr fi, b3#) = readArrayU (Index k) b2
                Complex# tr ti         = readArray (Index i) timeDomain
                yr                     = fr + ((tr * sr) - (ti * si))
                yi                     = fi + ((tr * si) + (ti * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          (#k + 1, b4#)

-- Slow n' dirty ifft
minBlepIFFT :: UInt -> MinBlepFFT z o -> MinBlepFFT z o
minBlepIFFT n (MinBlepFFT freqDomain) =
  MinBlepFFT <| freezeArray bins1
  where
    rn    = fromUInt n
    bins0 =
      loop b = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# 0 0) b
    bins1 = snd' <|
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = negate (sine p)
                (#Complex# tr ti, b3#) = readArrayU (Index k) b2
                Complex# fr fi         = readArray (Index i) freqDomain
                yr                     = tr + ((fr * sr) + (fi * si))
                yi                     = ti + ((fr * si) - (fi * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          case readArrayU (Index k) b4 of
            (#Complex# xr xi, b5#) ->
              (#k + 1, writeArray (Index k) (Complex# (xr / rn) (xi / rn)) b5#)

-- Compute real cepstrum
minBlepCepstrum :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepCepstrum n (MinBlepBuffer signal) =
  MinBlepBuffer <| freezeArray realCepstrum
  where
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# (readArray i signal) 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          lcabs                   = log (sqrt ((xr * xr) + (xi * xi)))
          c                       = Complex# lcabs 0
        in
          writeArray i c fd1

    realCepstrum =
      loop rc = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) rc

-- Minimum phase reconstruction
minBlepMinimumPhase :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepMinimumPhase n (MinBlepBuffer realCepstrum) =
  MinBlepBuffer <| freezeArray minimumPhase
  where
    n2                    = n / 2
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        if indexToUInt i == 0 then
          writeArray i (Complex# (readArray i realCepstrum) 0) td
        else if indexToUInt i < n2 then
          writeArray i (Complex# (readArray i realCepstrum * 2) 0) td
        else
          writeArray i (Complex# 0 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          rexp                    = exp xr
          c                       = Complex# (rexp * cosine xi) (rexp * sine xi)
        in
          writeArray i c fd1

    minimumPhase =
      loop mp = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) mp

minBlepN :: NatVal z -> NatVal o -> NatVal (NatMul (NatMul z 2) o)
minBlepN _ _ = NatVal

-- Start with z = 16, o = 32, which should create 1024 table
generateMinBLEP :: NatVal z -> NatVal o -> MinBlepBuffer z o
generateMinBLEP z o =
  minBlep1
  where
    n            = minBlepN z o |> natVal
    rn           = fromUInt n
    b            = natVal z |> fromUInt
    a            = negate b
    windowedSinc = MinBlepBuffer <| freezeArray <|
      loop wsb = unsafeEmptyArray () for i <- each do
        let
          ri = fromUInt (indexToUInt i)
          r  = ri / (rn - 1)
          s  = (a + (r * (b - a))) * pi |> sinc
          ws = hannWindowFunction ri rn * s
        in
          writeArray i ws wsb

    MinBlepBuffer minPhase =
      minBlepCepstrum n windowedSinc
      |> minBlepMinimumPhase n

    (#minBlep0, m#) =
      loop (#mb, m0#) = (#unsafeEmptyArray (), 0#) for i <- each do
        let
          m1 = m0 + readArray i minPhase
        in
          (#writeArray i m1 mb, m1#)

    rm       = 1 / m
    minBlep1 = MinBlepBuffer <| freezeArray <|
      loop mb0 = minBlep0 for i <- each do
        let
          (#x, mb1#) = readArrayU i mb0
        in
          writeArray i (x * rm) mb1

minBLEP :: MinBlepBuffer 16 32
minBLEP =
  generateMinBLEP NatVal NatVal

debugPlotMinBlepBuffer :: Array n Char -> MinBlepBuffer z o -> MinBlepBuffer z o
debugPlotMinBlepBuffer name (MinBlepBuffer buffer) =
  case writePlot2DToFileOnce name buffer primUndefined of
    _ -> MinBlepBuffer buffer

-- NOTE: Circular buffer size is equal to 2 * zcrossings
data MinBlepState = MinBlepState# Float UInt (.Array 32 Float)

mkMinBlepState :: () -> *MinBlepState
mkMinBlepState _ = MinBlepState# 0 0 (arrayFrom 0)

-- NOTE:
--   * zcrossings   = 16
--   * oversampling = 32
--   * buffer size  = 16 * 2 * 32 = 1024
-- TODO: fmin, or branchless min primop
addMinBlep :: Float -> Float -> UInt -> *Array 32 Float -> *Array 32 Float
addMinBlep polarity offset index buffer0 =
  buffer1
  where
    MinBlepBuffer mBuffer = minBLEP
    delta                 = offset % 1
    offsetu               = floorToInt offset |> fromInt
    mOffset               = 0 - polarity
    (#_, buffer1#) =
      loop (#i, b0#) = (#0, buffer0#) while i < 32 do
        let
          ci         = Index (bitAnd (i + index) 31)
          mi         = min 1022 ((i * 32) + offsetu)
          (#cx, b1#) = readArrayU ci b0
          m0         = readArray (Index mi) mBuffer
          m1         = readArray (Index (mi + 1)) mBuffer
          mx         = fma (m0 + (delta * (m1 - m0))) polarity mOffset
        in
          (#i + 1, writeArray ci (cx + mx) b1#)

----------------------
-- minBLEP saw
----------------------

fselect :: Bool -> Float -> Float -> Float
fselect c x y =
  (fc * x) + ((1 - fc) * y)
  where
    fc = fromInt <| boolToInt c

uselect :: Bool -> UInt -> UInt -> UInt
uselect c x y =
  (fc * x) + ((1 - fc) * y)
  where
    fc = fromInt <| boolToInt c

accumulateMinBlepSaw :: Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepSaw freq (MinBlepState# phase0 cIndex0 cBuffer0) =
  (#MinBlepState# phase2 cIndex1 cBuffer3, out#)
  where
    cIndex1   = bitAnd (cIndex0 + 1) 31
    freqDelta = freq * recipSampleRate
    phase1    = phase0 + freqDelta
    (#phase2, cBuffer1#) =
      if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0#)
      else
        (#phase1, cBuffer0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    out              = fma (phase2 + cx) 2 -1

saw :: AudioFormat f => f Audio -> f Audio
saw freq =
  accumulate1U mkMinBlepState accumulateMinBlepSaw constTrueU freq


-----------
-- lfSaw
accumulateLFSaw :: Float -> Float -> (#Float, Float#)
accumulateLFSaw freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    out    = fma phase2 2 -1

lfSaw :: AudioFormat f => f Audio -> f Audio
lfSaw freq =
  accumulate1 accumulateLFSaw constTrue freq

-----------
-- pulse

-- -- Oversampling pulse oscillator, with FIR downsampling
-- accumulatePulseFIR :: Float -> Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulatePulseFIR width freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 31)) (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 31)) (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 31)) (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 31)) (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 31)) (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 31)) (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 31)) (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 31)) (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 31, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 32 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 31)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 31)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 31)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 31)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 31)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 31)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 31)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 31)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 31, d8, firResult#)

-- -- Oversampling pulse oscillator, with FIR downsampling
-- accumulatePulseFIR :: Float -> Float -> Float -> (#Float, Float#)
-- accumulatePulseFIR width freq phaseIn =
--   (#phase, out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, out#) =
--       loop (#i, phase0, out0#) = (#0, phaseIn, 0#) while i < 32 do
--         let
--           phase1  = freqDelta + phase0
--           out1    = fma (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) (readArray (Index i) downsampleCoefficients) out0
--           phase2  = freqDelta + phase1
--           out2    = fma (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) (readArray (Index i) downsampleCoefficients) out1
--           phase3  = freqDelta + phase2
--           out3    = fma (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) (readArray (Index i) downsampleCoefficients) out2
--           phase4  = freqDelta + phase3
--           out4    = fma (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) (readArray (Index i) downsampleCoefficients) out3
--           phase5  = freqDelta + phase4
--           out5    = fma (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) (readArray (Index i) downsampleCoefficients) out4
--           phase6  = freqDelta + phase5
--           out6    = fma (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) (readArray (Index i) downsampleCoefficients) out5
--           phase7  = freqDelta + phase6
--           out7    = fma (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) (readArray (Index i) downsampleCoefficients) out6
--           phase8  = freqDelta + phase7
--           out8    = fma (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) (readArray (Index i) downsampleCoefficients) out7
--         in
--           (#i + 8, phase8, out8#)

-- pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
-- pulse width freq =
--   accumulate2 accumulatePulseFIR constTrue width freq

-----------
-- Oversampling saw wave with IIR brickwall filter

-- b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
-- b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
-- b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
-- a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
-- a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
-- a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
-- ra0       = 1 / a0

-- accumulatePulse :: Float -> Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulatePulse width freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, fma (negate y1Out) 2 -1#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fromInt (boolToInt (gt width (phase1 - floor phase1)))
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fromInt (boolToInt (gt width (phase2 - floor phase2)))
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fromInt (boolToInt (gt width (phase3 - floor phase3)))
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fromInt (boolToInt (gt width (phase4 - floor phase4)))
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fromInt (boolToInt (gt width (phase5 - floor phase5)))
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fromInt (boolToInt (gt width (phase6 - floor phase6)))
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fromInt (boolToInt (gt width (phase7 - floor phase7)))
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fromInt (boolToInt (gt width (phase8 - floor phase8)))
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)

-----------
-- minBLEP pulse

accumulateMinBlepPulse :: Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepPulse width freq (MinBlepState# phase0 indexAndMode0 cBuffer0) =
  (#MinBlepState# phase2 indexAndMode1 cBuffer3, out#)
  where
    mode0     = bitAnd 32 indexAndMode0
    cIndex0   = bitAnd 31 indexAndMode0
    cIndex1   = bitAnd (cIndex0 + 1) 31
    freqDelta = freq * recipSampleRate
    phase1    = phase0 + freqDelta
    (#phase2, cBuffer1, mode1#) =
      if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
          mode1    = uselect (phase2 <= width) 0 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else if (mode0 == 0 && phase1 >= width && freq > 0) || (mode0 == 32 && phase1 < width && freq < 0) then
        let
          polarity = fselect (mode0 == 0) 1 -1
          offset   = ((abs (phase1 - width)) / abs freqDelta) * 32
          mode1    = uselect (mode0 == 0) 32 0
        in
          (#phase1, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else
        (#phase1, cBuffer0, mode0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    y                = fselect (mode1 == 0) 0 1
    out              = fma (y + cx) 2 -1
    indexAndMode1    = bitOr mode1 cIndex1

pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
pulse width freq =
  accumulate2U mkMinBlepState accumulateMinBlepPulse constTrueU width freq

-----------
-- lfPulse
accumulateLFPulse :: Float -> Float -> Float -> (#Float, Float#)
accumulateLFPulse width freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    out    = fma (fromInt (boolToInt (phase2 > width))) 2 -1

lfPulse :: AudioFormat f => f Audio -> f Audio -> f Audio
lfPulse width freq =
  accumulate2 accumulateLFPulse constTrue width freq

-- -----------
-- -- Oversampling saw wave with IIR brickwall filter
-- accumulateTri :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateTri freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (abs (fma (phase1 - floor phase1) 2 -1)) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (abs (fma (phase2 - floor phase2) 2 -1)) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (abs (fma (phase3 - floor phase3) 2 -1)) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (abs (fma (phase4 - floor phase4) 2 -1)) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (abs (fma (phase5 - floor phase5) 2 -1)) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (abs (fma (phase6 - floor phase6) 2 -1)) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (abs (fma (phase7 - floor phase7) 2 -1)) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (abs (fma (phase8 - floor phase8) 2 -1)) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)
--
-- tri' :: AudioFormat f => f Audio -> f Audio
-- tri' freq =
--   accumulate1 accumulateTri constTrue freq

-----------
-- lfTri
accumulateLFTri :: Float -> Float -> (#Float, Float#)
accumulateLFTri freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    saw    = fma phase2 2 -1
    out    = fma (abs saw) 2 -1

tri :: AudioFormat f => f Audio -> f Audio
tri freq =
  accumulate1 accumulateLFTri constTrue freq

-----------
-- perc
-- TODO: Switch to EnvState
data PercState = PercState# Float Float Float Float

mkPercState :: Float -> Float -> Float -> Float -> Float -> () -> *PercState
mkPercState level endLevel length curve currTime _ =
  PercState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

accumulatePerc :: (#Float, Float, Float, Float#) -> Float -> *PercState -> (#*PercState, Float#)
accumulatePerc (#attackTime, decayTime, totalTime, curve#) input (PercState# a20 b10 grow0 currTime0) =
  (#PercState# a2 b12 grow currTime, out#)
  where
    currTime1 = currTime0 + recipSampleRate
    PercState# a2 b1 grow currTime =
      if currTime1 > attackTime && currTime0 <= attackTime then
        mkPercState (a20 - b10) 0 decayTime curve currTime1 ()
      else if currTime1 > totalTime then
        PercState# 0 0 0 currTime1
      else
        PercState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

percIsRunning :: Float -> *PercState -> (#*PercState, Bool#)
percIsRunning totalTime (PercState# a2 b1 grow currTime) =
  (#PercState# a2 b1 grow currTime, currTime < totalTime#)

perc :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
perc attackTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + decayTime
    mk        = mkPercState 0 1 attackTime curve 0
    update    = accumulatePerc (#attackTime, decayTime, totalTime, curve#)
    isRunning = percIsRunning totalTime

-----------
-- Env

data EnvState = EnvState# Float Float Float Float

envMk :: Float -> Float -> Float -> Float -> Float -> () -> *EnvState
envMk level endLevel length curve currTime _ =
  EnvState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

envIsRunning :: Float -> *EnvState -> (#*EnvState, Bool#)
envIsRunning totalTime (EnvState# a2 b1 grow currTime) =
  (#EnvState# a2 b1 grow currTime, currTime < totalTime#)

-----------
-- asr

asrTick :: Float -> Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
asrTick attackTime sustainTime decayTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    attackAndSustainTime          = attackTime + sustainTime
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to sustain
      if currTime1 > attackTime && currTime0 <= attackTime then
        envMk (a20 - b10) 1.0 sustainTime curve currTime1 ()
      -- Switch to decay
      else if currTime1 > attackAndSustainTime && currTime0 <= attackAndSustainTime then
        envMk (a20 - b10) 0 decayTime curve currTime1 ()
      -- End
      else if currTime1 > totalTime then
        EnvState# 0 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

asr :: AudioFormat f => Float -> Float -> Float -> Float -> f Audio -> f Audio
asr attackTime sustainTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + sustainTime + decayTime
    mk        = envMk 0 1 attackTime curve 0
    update    = asrTick attackTime sustainTime decayTime totalTime curve
    isRunning = envIsRunning totalTime

-----------
-- sustainRelease
sustainReleaseTick :: Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
sustainReleaseTick sustainTime decayTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to decay
      if currTime1 > sustainTime && currTime0 <= sustainTime then
        envMk (a20 - b10) 0 decayTime curve currTime1 ()
      -- End
      else if currTime1 > totalTime then
        EnvState# 0 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

sustainRelease :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
sustainRelease sustainTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = sustainTime + decayTime
    mk        = envMk 1 1 sustainTime curve 0
    update    = sustainReleaseTick sustainTime decayTime totalTime curve
    isRunning = envIsRunning totalTime

-----------
-- attackSustain

attackSustainTick :: Float -> Float -> Float -> Float -> Float -> *EnvState -> (#*EnvState, Float#)
attackSustainTick attackTime sustainTime totalTime curve input (EnvState# a20 b10 grow0 currTime0) =
  (#EnvState# a2 b12 grow currTime, out#)
  where
    currTime1                     = currTime0 + recipSampleRate
    EnvState# a2 b1 grow currTime =
      -- Switch to sustain
      if currTime1 > attackTime && currTime0 <= attackTime then
        envMk (a20 - b10) 1 sustainTime curve currTime1 ()
      -- End
      else if currTime1 > totalTime then
        EnvState# 0 0 0 currTime1
      -- Attack / decay
      else
        EnvState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

attackSustain :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
attackSustain attackTime sustainTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + sustainTime
    mk        = envMk 0 1 attackTime curve 0
    update    = attackSustainTick attackTime sustainTime totalTime curve
    isRunning = envIsRunning totalTime


-----------
-- playFor
playFor :: AudioFormat f => Float -> f Audio -> f Audio
playFor length audio =
  if rationalToFloat t >= length then
    pure AudioEnd
  else
    audio
  where
    t ~ 0 = t + audioBlockDelta

-----------
-- Wave tables

data WaveTable = WaveTable (Array 65536 Float)

sinTable :: WaveTable
sinTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (sine ((fromInt (uintToInt i) / 65536) * tau)) a

cosTable :: WaveTable
cosTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (cosine ((fromInt (uintToInt i) / 65536) * tau)) a

-- sinhTable :: WaveTable
-- sinhTable =
--   WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
--     case ix of
--       Index i ->
--         writeArray ix (sinh ((fromInt (uintToInt i) / 65536) * tau)) a

-- TODO: Accumulator will grow very large, reducing precision?
-- TODO: need ceil
accumulateWaveTable :: WaveTable -> Float -> Float -> (#Float, Float#)
accumulateWaveTable (WaveTable buffer) freq phase0 =
  (#phase1, out#)
  where
    phase1  = fma freq recipSampleRate phase0
    findex  = phase1 * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer
    out     = sample1 * delta + sample2 * (1 - delta)

wave :: AudioFormat f => WaveTable -> f Audio -> f Audio
wave buffer freq =
  accumulate1 (accumulateWaveTable buffer) constTrue freq

sin :: AudioFormat f => f Audio -> f Audio
sin freq = wave sinTable freq

-------------
-- Wave Terrain

data WaveTable2D n = WaveTable2D (Array (NatMul (NatNextPowerOfTwo n) (NatNextPowerOfTwo n)) Float)
data WaveTable3D n = WaveTable3D (Array (NatMul (NatNextPowerOfTwo n) (NatMul (NatNextPowerOfTwo n) (NatNextPowerOfTwo n))) Float)

audioVector2DX :: AudioVector2D -> Audio
audioVector2DX (AudioVector2D# x _) = x

audioVector2DY :: AudioVector2D -> Audio
audioVector2DY (AudioVector2D# _ y) = y

audioVector3DX :: AudioVector3D -> Audio
audioVector3DX (AudioVector3D# x _ _) = x

audioVector3DY :: AudioVector3D -> Audio
audioVector3DY (AudioVector3D# _ y _) = y

audioVector3DZ :: AudioVector3D -> Audio
audioVector3DZ (AudioVector3D# _ _ z) = z

accumulateWave2F :: AudioFormat f => (Vector2D -> Float) -> f AudioVector2D -> f Audio
accumulateWave2F f a =
  map (\v -> mapAudio2 (\x y -> f (Vector2D# x y)) (audioVector2DX v) (audioVector2DY v)) a

-- accumulateWave3F :: (Default s, AudioFormat f) => (Vector3D -> s -> (#s, Float#)) -> f AudioVector3D -> f Audio
-- accumulateWave3F f v =
--   accumulate3 (\x y z -> f (Vector3D# x y z)) constTrue (map audioVector3DX v) (map audioVector3DY v) (map audioVector3DZ v)


----------------------
-- Attractor2D
----------------------

data AttractorState2D w h s = AttractorState2D# (.Array (NatMul w h) (#Vector2D, s#)) Float

mkAttractorState2D :: NatVal w -> NatVal h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> () -> *AttractorState2D w h s
mkAttractorState2D wv hv mkArrayFn _ =
  AttractorState2D# a1 0
  where
    width  = natVal wv
    height = natVal hv
    hw     = fromUInt width * 0.5
    hh     = fromUInt height * 0.5
    a1     =
      loop a0 = unsafeEmptyArray () for i <- each do
        let
          ui       = indexToUInt i
          x        = fromUInt (ui % width) - hw
          y        = fromUInt (ui / width) - hh
          (#v, s#) = mkArrayFn ui (Vector2D# x y)
        in
          writeArray i (#v, s#) a0

accumulateAttractor2D :: (p -> Float -> Vector2D -> Vector2D) ->
                         (UInt -> Vector2D -> s -> (#s, Float#)) ->
                         Float -> p -> Float ->
                         *AttractorState2D w h s -> (#*AttractorState2D w h s, Float#)
accumulateAttractor2D attractorF mapF recipSize param speed (AttractorState2D# a0 phase0) =
  (#AttractorState2D# a3 phase1, out#)
  where
    delta       = speed * recipSampleRate
    phase1      = phase0 + delta
    (#a3, out#) =
      loop (#a1, out0#) = (#a0, 0#) for i <- each do
        let
          ui                 = indexToUInt i
          (#(#v0, s0#), a2#) = readArrayU i a1
          v1                 = v0 + (Vector2D# delta delta * attractorF param phase0 v0)
          (#s1, x#)          = mapF ui v1 s0
          out1               = out0 + (x * recipSize)
        in
          (#writeArray i (#v1, s1#) a2, x#)

attractor2D :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (p -> Float -> Vector2D -> Vector2D) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> p -> f Audio -> f Audio
attractor2D size initF attractorF mapF p speed =
  accumulate1U (mkAttractorState2D wv hv initF) (accumulateAttractor2D attractorF mapF recipSize p) constTrueU speed
  where
    (#wv, hv#) = natVal2ToNatVals size
    recipSize  = 1 / (fromUInt (natVal wv) * fromUInt (natVal hv))

----------------------
-- duffingAttractor
duffing :: (#Float, Float, Float#) -> Float -> Vector2D -> Vector2D
duffing (#a, b, w#) t (Vector2D# x y) =
  Vector2D# dx dy
  where
    dx = y
    dy = x - (x * x * x) - (a * y) + (b * cosine (w * t))

duffingAttractor :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> Float -> Float -> Float -> f Audio -> f Audio
duffingAttractor size initF mapF a b w speed =
  attractor2D size initF duffing mapF (#a, b, w#) speed

----------------------
-- ikedaAttractor
ikeda :: Float -> Float -> Vector2D -> Vector2D
ikeda u t (Vector2D# x0 y0) =
  Vector2D# x1 y1
  where
    t  = 0.4 - 6 / (1 + (x0 * x0) + (y0 * y0))
    x1 = 1 + (u * ((x0 * cosine t) - (y0 * sine t)))
    y1 = u * ((x0 * sine t) + (y0 * cosine t))

ikedaAttractor :: (AudioFormat f) => NatVal2 w h -> (UInt -> Vector2D -> (#Vector2D, s#)) -> (UInt -> Vector2D -> s -> (#s, Float#)) -> Float -> f Audio -> f Audio
ikedaAttractor size initF mapF u speed =
  attractor2D size initF ikeda mapF u speed

----------------------
-- Attractor3D
----------------------

data AttractorState3D w h d s = AttractorState3D# (.Array (NatMul (NatMul w h) d) (#Vector3D, s#)) Float

mkAttractorState3D :: NatVal w -> NatVal h -> NatVal d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> () -> *AttractorState3D w h d s
mkAttractorState3D wv hv dv mkArrayFn _ =
  AttractorState3D# a1 0
  where
    width  = natVal wv
    height = natVal hv
    depth  = natVal dv
    hw     = fromUInt width  * 0.5
    hh     = fromUInt height * 0.5
    hd     = fromUInt depth  * 0.5
    a1     =
      loop a0 = unsafeEmptyArray () for i <- each do
        let
          ui       = indexToUInt i
          x        = fromUInt (ui % width) - hw
          y        = fromUInt ((ui / width) % height) - hh
          z        = fromUInt ((ui / width) / height) - hd
          (#v, s#) = mkArrayFn ui (Vector3D# x y z)
        in
          writeArray i (#v, s#) a0

-- -- Euler method
-- accumulateAttractor3D :: (p -> Float -> Vector3D -> Vector3D) ->
--                          (UInt -> Vector3D -> s -> (#s, Float#)) ->
--                          Float -> p -> Float ->
--                          *AttractorState3D w h d s -> (#*AttractorState3D w h d s, Float#)
-- accumulateAttractor3D attractorF mapF recipSize param speed (AttractorState3D# a0 phase0) =
--   (#AttractorState3D# a3 phase1, out#)
--   where
--     delta       = speed * recipSampleRate
--     phase1      = phase0 + delta
--     (#a3, out#) =
--       loop (#a1, out0#) = (#a0, 0#) for i <- each do
--         let
--           ui                 = indexToUInt i
--           (#(#v0, s0#), a2#) = readArrayU i a1
--           v1                 = v0 + (Vector3D# delta delta delta * attractorF param phase0 v0)
--           (#s1, x#)          = mapF ui v1 s0
--           out1               = out0 + (x * recipSize)
--         in
--           (#writeArray i (#v1, s1#) a2, x#)


-- TODO: 4th order Runge-Kutta method
accumulateAttractor3D :: (p -> Float -> Vector3D -> Vector3D) ->
                         (UInt -> Vector3D -> s -> (#s, Float#)) ->
                         Float -> p -> Float ->
                         *AttractorState3D w h d s -> (#*AttractorState3D w h d s, Float#)
accumulateAttractor3D attractorF mapF recipSize param speed (AttractorState3D# a0 time0) =
  (#AttractorState3D# a3 time1, out#)
  where
    delta       = speed * recipSampleRate
    hdelta      = delta / 2
    deltav      = Vector3D# delta delta delta
    time1       = time0 + delta
    oneSixth    = Vector3D# (1/6) (1/6) (1/6)
    (#a3, out#) =
      loop (#a1, out0#) = (#a0, 0#) for i <- each do
        let
          ui                 = indexToUInt i
          (#(#v0, s0#), a2#) = readArrayU i a1
          k1                 = deltav * attractorF param time0 v0
          k2                 = deltav * attractorF param (time0 + hdelta) (v0 + (k1 * 0.5))
          k3                 = deltav * attractorF param (time0 + hdelta) (v0 + (k2 * 0.5))
          k4                 = deltav * attractorF param time1 (v0 + k3)
          v1                 = v0 + (oneSixth * (k1 + (2 * k2) + (2 * k3) + k4))
          (#s1, x#)          = mapF ui v1 s0
          out1               = out0 + (x * recipSize)
        in
          (#writeArray i (#v1, s1#) a2, x#)

attractor3D :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (p -> Float -> Vector3D -> Vector3D) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> p -> f Audio -> f Audio
attractor3D size initF attractorF mapF p speed =
  accumulate1U (mkAttractorState3D wv hv dv initF) (accumulateAttractor3D attractorF mapF recipSize p) constTrueU speed
  where
    (#wv, hv, dv#) = natVal3ToNatVals size
    recipSize      = 1 / (fromUInt (natVal wv) * fromUInt (natVal hv) * fromUInt (natVal dv))

----------------------
-- Lorenz Attractor

-- lorenz 10 28 (8/3) (Vector3D# 0.0001 0.0001 0.0001)
lorenz :: (#Float, Float, Float#) -> Float -> Vector3D -> Vector3D
lorenz (#a, b, c#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = a * (y - x)
    dy = (x * (b - z)) - y
    dz = (x * y) - (c * z)

lorenzAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> Float -> f Audio -> f Audio
lorenzAttractor size initF mapF a b c speed =
  attractor3D size initF lorenz mapF (#a, b, c#) speed

----------------------
-- Rabinovich-Fabrikant Attractor

-- rabinovichFabrikant 0.87 1.1
rabinovichFabrikant :: (#Float, Float#) -> Float -> Vector3D -> Vector3D
rabinovichFabrikant (#a, g#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = (y * (z - 1 + (x * x))) + (g * x)
    dy = (x * ((3 * z) + 1 - (x * x))) + (g * y)
    dz = -2 * z * (a + (x * y))

rabinovichFabrikantAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> f Audio -> f Audio
rabinovichFabrikantAttractor size initF mapF a g speed =
  attractor3D size initF rabinovichFabrikant mapF (#a, g#) speed

----------------------
-- Lu Chen Attractor

-- luChen 36 3 20 -15.5
-- initV: 0.1 0.3 -0.6
luChen :: (#Float, Float, Float, Float#) -> Float -> Vector3D -> Vector3D
luChen (#a, b, c, u#) t (Vector3D# x y z) =
  Vector3D# dx dy dz
  where
    dx = a * (y - x)
    dy = x - (x * z) + (c * y) + u
    dz = (x * y) - (b * z)

luChenAttractor :: (AudioFormat f) => NatVal3 w h d -> (UInt -> Vector3D -> (#Vector3D, s#)) -> (UInt -> Vector3D -> s -> (#s, Float#)) -> Float -> Float -> Float -> Float -> f Audio -> f Audio
luChenAttractor size initF mapF a b c u speed =
  attractor3D size initF luChen mapF (#a, b, c, u#) speed


-----------
-- Sync
-----------

-- TODO: default instance instead of accumulate3U
data SyncState = SyncState# Float Float Float

mkSyncState :: () -> *SyncState
mkSyncState _ = SyncState# 0 1 1

-- Kick Sync
accumulateSyncSaw :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncSaw sync kick freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    posSync = fromInt <| boolToInt <| (prevSync <= 0 && sync > 0)
    negSync = fromInt <| boolToInt <| (prevSync >= 0 && sync < 0)
    delta   = freq * recipSampleRate
    kicks   = posSync * kick + negSync * negate kick
    phase1  = delta + phase0 + kicks
    phase2  = phase1 - floor phase1
    out     = fma phase2 2.0 -1.0

syncSaw :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncSaw sync kickAmount freq =
  accumulate3U mkSyncState accumulateSyncSaw constTrueU sync kickAmount freq

-- Reverse sync
accumulateSyncTri :: Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncTri sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    phase2     = phase1 - floor phase1
    saw        = fma phase2 2.0 -1.0
    out        = fma (abs saw) 2.0 -1.0

syncTri :: AudioFormat f => f Audio -> f Audio -> f Audio
syncTri sync freq =
  accumulate2U mkSyncState accumulateSyncTri constTrueU sync freq

-- TODO: Branchless
-- Hard Sync
accumulateSyncPulse :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncPulse sync width freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    phase1  =
      if prevSync <= 0 && sync > 0 then
        0
      else if prevSync >= 0 && sync < 0 then
        width
      else
        fma freq recipSampleRate phase0
    phase2  = phase1 - floor phase1
    out     = fma (fromInt (boolToInt (phase2 >= width))) 2.0 (-1.0)

syncPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncPulse sync width freq =
  accumulate3U mkSyncState accumulateSyncPulse constTrueU sync width freq

-- Reverse Sync
accumulateSyncWave :: WaveTable -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncWave (WaveTable buffer) sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    findex     = phase1 * 65536
    delta      = (floor findex + 1) - findex
    index1     = bitAnd (floatToUInt findex) 65535
    index2     = bitAnd (index1 + 1) 65535
    sample1    = readArray (Index index1) buffer
    sample2    = readArray (Index index2) buffer
    out        = sample1 * delta + sample2 * (1 - delta)

syncWave :: AudioFormat f => WaveTable -> f Audio -> f Audio -> f Audio
syncWave buffer sync freq =
  accumulate2U mkSyncState (accumulateSyncWave buffer) constTrueU sync freq

syncSin :: AudioFormat f => f Audio -> f Audio -> f Audio
syncSin sync freq = syncWave sinTable sync freq

-----------
-- minBLEP hard sync saw

accumulateMinBlepSawHardSync :: Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepSawHardSync sync freq (MinBlepState# phase0 state0 cBuffer0) =
  (#MinBlepState# phase2 state1 cBuffer3, out#)
  where
    syncPolarity0 = bitAnd 64 state0
    cIndex0       = bitAnd 31 state0
    cIndex1       = bitAnd (cIndex0 + 1) 31
    syncPolarity1 = bitShiftLeft (fromInt <| boolToInt <| sync >= 0) 6
    freqDelta     = freq * recipSampleRate
    phase1        = phase0 + freqDelta
    (#phase2, cBuffer1#) =
      if syncPolarity0 > 0 && syncPolarity1 == 0 then
        (#0, addMinBlep (0 - phase1) 0 cIndex0 cBuffer0#)
      else if syncPolarity0 == 0 && syncPolarity1 > 0 then
        (#0.5, addMinBlep (0.5 - phase1) 0 cIndex0 cBuffer0#)
      else if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0#)
      else
        (#phase1, cBuffer0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    out              = fma (phase2 + cx) 2 -1
    state1           = bitOr syncPolarity1 cIndex1

hardSyncSaw :: AudioFormat f => f Audio -> f Audio -> f Audio
hardSyncSaw sync freq =
  accumulate2U mkMinBlepState accumulateMinBlepSawHardSync constTrueU sync freq

-----------
-- minBLEP hard sync pulse

accumulateMinBlepPulseHardSync :: Float -> Float -> Float -> *MinBlepState -> (#*MinBlepState, Float#)
accumulateMinBlepPulseHardSync sync width freq (MinBlepState# phase0 state0 cBuffer0) =
  (#MinBlepState# phase2 state1 cBuffer3, out#)
  where
    syncPolarity0 = bitAnd 64 state0
    mode0         = bitAnd 32 state0
    cIndex0       = bitAnd 31 state0
    cIndex1       = bitAnd (cIndex0 + 1) 31
    syncPolarity1 = bitShiftLeft (fromInt <| boolToInt <| sync >= 0) 6
    freqDelta     = freq * recipSampleRate
    phase1        = phase0 + freqDelta
    (#phase2, cBuffer1, mode1#) =
      if syncPolarity0 > 0 && syncPolarity1 == 0 then
        let
          phase2   = 0
          mode1    = 0
          cBuffer1 = if mode0 == 0 then cBuffer0 else addMinBlep -1 0 cIndex0 cBuffer0
        in
          (#phase2, cBuffer1, mode1#)
      else if syncPolarity0 == 0 && syncPolarity1 > 0 then
        let
          phase2   = width
          mode1    = 32
          cBuffer1 = if mode0 == 32 then cBuffer0 else addMinBlep 1 0 cIndex0 cBuffer0
        in
          (#phase2, cBuffer1, mode1#)
      else if (phase1 >= 1 && freq > 0) || (phase1 <= 0 && freq < 0) then
        let
          polarity = 0 - copysign 1 freq
          phase2   = phase1 + polarity
          offset   = (abs (fselect (polarity < 0) phase2 phase1) / abs freqDelta) * 32
          mode1    = uselect (phase2 <= width) 0 32
        in
          (#phase2, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else if (mode0 == 0 && phase1 >= width && freq > 0) || (mode0 == 32 && phase1 < width && freq < 0) then
        let
          polarity = fselect (mode0 == 0) 1 -1
          offset   = ((abs (phase1 - width)) / abs freqDelta) * 32
          mode1    = uselect (mode0 == 0) 32 0
        in
          (#phase1, addMinBlep polarity offset cIndex0 cBuffer0, mode1#)
      else
        (#phase1, cBuffer0, mode0#)
    (#cx, cBuffer2#) = readArrayU (Index cIndex0) cBuffer1
    cBuffer3         = writeArray (Index cIndex0) 0 cBuffer2
    y                = fselect (mode1 == 0) 0 1
    out              = fma (y + cx) 2 -1
    state1           = bitOr syncPolarity1 (bitOr mode1 cIndex1)

hardSyncPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
hardSyncPulse sync width freq =
  accumulate3U mkMinBlepState accumulateMinBlepPulseHardSync constTrueU sync width freq

-----------
-- Super Osc
-- Based on Roland JP-8000 super saw oscillator design
data SuperSawState = SuperSawState# Float Float Float Float Float Float Float

-- TODO: Make default instance for SuperSawState instead of relying on accumulate3U, now that init weirdness has been fixed
mkSuperSawState :: () -> *SuperSawState
mkSuperSawState _ = SuperSawState# 0.260786585 0.087023334 0.866947809 0.392499353 0.728213602 0.122864975 0.167605335

accumulateSuperSaw :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperSaw freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (phaseA1 - floor phaseA1) 2 -1 * sideMix
    oscB    = fma (phaseB1 - floor phaseB1) 2 -1 * sideMix
    oscC    = fma (phaseC1 - floor phaseC1) 2 -1 * sideMix
    oscD    = fma (phaseD1 - floor phaseD1) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (phaseE1 - floor phaseE1) 2 -1 * sideMix
    oscF    = fma (phaseF1 - floor phaseF1) 2 -1 * sideMix
    oscG    = fma (phaseG1 - floor phaseG1) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: superoscs are specifically NOT bandlimited,
-- instead the aliasing combined with phase cancelation is considered part of the sound of the oscillator
-- A hpf is put in place to eliminate low frequency aliased frequencies
-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superSaw :: (AudioFormat f, Num (f Audio)) => f Audio -> f Audio -> f Audio -> f Audio
superSaw freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperSaw constTrueU freq depth mix
  |> hpf freq 6

accumulateSuperPulse :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperPulse freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    width   = 0.5 -- need accumulate4U to make this another parameter
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (fromInt <| boolToInt <| (phaseA1 - floor phaseA1) > width) 2 -1 * sideMix
    oscB    = fma (fromInt <| boolToInt <| (phaseB1 - floor phaseB1) > width) 2 -1 * sideMix
    oscC    = fma (fromInt <| boolToInt <| (phaseC1 - floor phaseC1) > width) 2 -1 * sideMix
    oscD    = fma (fromInt <| boolToInt <| (phaseD1 - floor phaseD1) > width) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (fromInt <| boolToInt <| (phaseE1 - floor phaseE1) > width) 2 -1 * sideMix
    oscF    = fma (fromInt <| boolToInt <| (phaseF1 - floor phaseF1) > width) 2 -1 * sideMix
    oscG    = fma (fromInt <| boolToInt <| (phaseG1 - floor phaseG1) > width) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superPulse freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperPulse constTrueU freq depth mix
  |> hpf freq 6

accumulateSuperTri :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperTri freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (abs (fma (phaseA1 - floor phaseA1) 2 -1)) 2 -1 * sideMix
    oscB    = fma (abs (fma (phaseB1 - floor phaseB1) 2 -1)) 2 -1 * sideMix
    oscC    = fma (abs (fma (phaseC1 - floor phaseC1) 2 -1)) 2 -1 * sideMix
    oscD    = fma (abs (fma (phaseD1 - floor phaseD1) 2 -1)) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (abs (fma (phaseE1 - floor phaseE1) 2 -1)) 2 -1 * sideMix
    oscF    = fma (abs (fma (phaseF1 - floor phaseF1) 2 -1)) 2 -1 * sideMix
    oscG    = fma (abs (fma (phaseG1 - floor phaseG1) 2 -1)) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: We don't currently support more complicated contexts in the parser (but we do in type checking)...
-- superTri :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superTri freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperTri constTrueU freq depth mix
  |> hpf freq 6


----------------------
-- RBJ Filters, Audio EQ Cookbook
----------------------

data BiquadState = BiquadState# Float Float Float Float

instance Default BiquadState where
  default = BiquadState# 0 0 0 0

-- fi range: 0 - 1
waveTableFunction :: WaveTable -> Float -> Float
waveTableFunction (WaveTable buffer) fi =
  -- sample1 * delta + sample2 * (1 - delta)
  sample1 * (1 - delta) + sample2 * delta
  where
    findex  = fi * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer

-----------
-- lpf
accumulateLPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 - cso) * 0.5
    b1    =  1 - cso
    b2    = (1 - cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

lpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
lpf freq q input =
  accumulate3 accumulateLPF constTrue freq q input

-----------
-- hpf
accumulateHPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 + cso) * 0.5
    b1    = negate (1 + cso)
    b2    = (1 + cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

hpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
hpf freq q input =
  accumulate3 accumulateHPF constTrue freq q input

-----------
-- bpf
accumulateBPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateBPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = alpha
    b1    = 0
    b2    = negate alpha
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

bpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
bpf freq q input =
  accumulate3 accumulateBPF constTrue freq q input

-----------
-- lowShelf
accumulateLowShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLowShelf slope freq gain x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    biga  = pow 10 (gain / 40)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) - ((biga - 1) * cso) + beta)
    b1    = 2 * biga * ((biga - 1) - ((biga + 1) * cso))
    b2    = biga * ((biga + 1) - ((biga - 1) * cso) - beta)
    a0    = (biga + 1) + ((biga - 1) * cso) + beta
    a1    = -2 * ((biga - 1) + ((biga + 1) * cso))
    a2    = (biga + 1) + ((biga - 1) * cso) - beta
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

lowShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
lowShelf freq gain slope input =
  accumulate3 (accumulateLowShelf slope) constTrue freq gain input

-----------
-- highShelf
accumulateHighShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHighShelf slope freq gain x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    biga  = pow 10 (gain / 40)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) + ((biga - 1) * cso) + beta)
    b1    = -2 * biga * ((biga - 1) + ((biga + 1) * cso))
    b2    = biga * ((biga + 1) + ((biga - 1) * cso) - beta)
    a0    = (biga + 1) - ((biga - 1) * cso) + beta
    a1    = 2 * ((biga - 1) - ((biga + 1) * cso))
    a2    = (biga + 1) - ((biga - 1) * cso) - beta
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

highShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
highShelf freq gain slope input =
  accumulate3 (accumulateHighShelf slope) constTrue freq gain input

----------
-- OnePole
data OnePole = OnePole Float

instance Default OnePole where
  default = OnePole 0

-- Note: expected pole range: 0 - 1
onePoleTick :: Float -> Float -> Float -> OnePole -> (#Float, OnePole#)
onePoleTick pole gain input (OnePole z0) =
  (#z1, OnePole z1#)
  where
    a  = 0 - pole
    b  = if pole < 0 then 1 + pole else 1 - pole
    x  = input * gain
    z1 = b * x - a * z0

-----------
-- lag
accumulateLag :: Float -> Float -> Float -> (#Float, Float#)
accumulateLag lagTime input z =
  (#out, out#)
  where
    a   = exp ((-2 * pi) / (lagTime * audioSampleRateF))
    b   = 1 - a
    out = (input * b) + (z * a)

lag :: AudioFormat f => f Audio -> f Audio -> f Audio
lag lagTime input =
  accumulate2 accumulateLag constTrue lagTime input

-----------
-- range

-- TODO: mapAudio3, mapAudio3Vec
-- mapRange3 :: Float -> Float
-- mapRange3 x =


-----------
-- delay
data DelayState s = DelayState# (.Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) Float) UInt Float

natSecondsToNatBufferSamples :: Seconds n -> NatVal (NatNextPowerOfTwo (NatMul SampleRate (NatMax n 1)))
natSecondsToNatBufferSamples _ = NatVal

-- TODO: Interpolate delayTime!
-- TODO: delay playback speed? Reverse delay? delay bank etc?
-- TODO: initialDelayTime, maxDelayTime, audioBufferSize, etc

accumulateDelay :: UInt -> Float -> Float -> Float -> *DelayState s -> (#*DelayState s, Float#)
accumulateDelay bufferSizeMinus1 targetDelayTime mix input (DelayState# buffer0 index delayTime) =
  (#DelayState# buffer2 index' delayTime', out#)
  where
    delayTime'       = targetDelayTime
    delayIndex       = bitAnd (index + floatToUInt (delayTime' * audioSampleRateF)) bufferSizeMinus1
    (#del, buffer1#) = readArrayU (Index index) buffer0
    out              = input * (1 - mix) + del * mix
    buffer2          = writeArray (Index delayIndex) out buffer1
    index'           = bitAnd (index + 1) bufferSizeMinus1

mkDelayState :: Seconds s -> () -> *DelayState s
mkDelayState _ _ = DelayState# (arrayFrom 0) 0 1

delay :: AudioFormat f => Seconds n -> f Audio -> f Audio -> f Audio -> f Audio
delay maxDelayTime delayTime mix input =
  accumulate3U (mkDelayState maxDelayTime) (accumulateDelay (natVal (natSecondsToNatBufferSamples maxDelayTime) - 1)) (\s -> (#s, True#)) delayTime mix input

oneSec :: Seconds 1
oneSec = Seconds

twoSec :: Seconds 2
twoSec = Seconds

threeSec :: Seconds 3
threeSec = Seconds

fourSec :: Seconds 4
fourSec = Seconds

fiveSec :: Seconds 5
fiveSec = Seconds


-----------
-- Pluck: Karplus Strong

data PluckState n = PluckState# (.Array (NatMul BlockSize n) Float) UInt UInt

accumulatePluck :: UInt -> Float -> Float -> *PluckState s -> (#*PluckState s, Float#)
accumulatePluck bufferSizeMinus1 freq damping (PluckState# buffer0 index0 count) =
  (#PluckState# buffer3 index1 count, out#)
  where
    delaySamples     = min (floatToUInt (audioSampleRateF / freq)) bufferSizeMinus1
    delayIndex1      = (index0 + delaySamples) % delaySamples
    delayIndex2      = (delayIndex1 + 1) % delaySamples
    (#d1, buffer1#)  = readArrayU (Index delayIndex1) buffer0
    (#d2, buffer2#)  = readArrayU (Index delayIndex2) buffer1
    out              = (d1 + d2) * 0.5 * damping
    buffer3          = writeArray (Index index0) out buffer2
    index1           = (index0 + 1) % delaySamples

linearCongruentialGenerator :: UInt -> UInt -> UInt -> UInt -> UInt
linearCongruentialGenerator a c m seed =
  (a * seed + c) % m

randLCG :: Float -> Float -> UInt -> (#UInt, Float#)
randLCG mn mx seed =
  (#s, r#)
  where
    a = 1664525
    c = 1013904223
    m = 4294967296
    s = linearCongruentialGenerator a c m seed
    r = ((fromUInt s / fromUInt m) * (mx - mn)) + mn

-- This is quick'n'dirty linear congruential randomness. Replace with something higher quality!
noiseF :: UInt -> Float -> Float -> Float
noiseF iseed mn mx =
  r2
  where
    seed = 123456789
    s    = seed + iseed
    a    = 1664525
    c    = 1013904223
    m    = 4294967296
    r0   = fromUInt ((a * s + c) % m)
    r1   = (r0 / fromUInt m) * (mx - mn)
    r2   = r1 + mn

randOnceF :: UInt -> Float -> Float -> Float
randOnceF iseed mn mx =
  result |> fromMaybe 0
  where
    result ~ Nothing =
      case result of
        Nothing -> Just (noiseF iseed mn mx)
        Just r  -> Just r

tnoiseF :: UInt -> Float -> Float -> Float
tnoiseF iseed mn mx =
  noiseF tseed mn mx
  where
    tseed = bitShiftLeft (bitOr (t * 37) (iseed * 37)) 1
    t     = currSampleCount + audioSampleOffset

trandOnceF :: UInt -> Float -> Float -> Float
trandOnceF iseed mn mx =
  result |> fromMaybe 0
  where
    result ~ Nothing =
      case result of
        Nothing -> Just (tnoiseF iseed mn mx)
        Just r  -> Just r

trandOnce :: UInt -> Float -> Float -> Mono Audio
trandOnce iseed mn mx =
  fromFloat(trandOnceF iseed mn mx)

-- Note: Fill Buffer with quick'n'dirty random noise
mkPluckState :: NatVal n -> () -> *PluckState n
mkPluckState _ _ =
  PluckState# arr 0 0
  where
    seed       = 123456789
    a          = 1664525
    c          = 1013904223
    m          = 4294967296
    (#arr, _#) =
      loop (#arr, s#) = (#unsafeEmptyArray (), seed#) for i <- each do
        let
          s'   = (a * s + c) % m
          arr' = writeArray i (((fromUInt s' / 1000000) % 2) - 1) arr
        in
          (#arr', s'#)

pluck :: AudioFormat f => NatVal n -> f Audio -> f Audio -> f Audio
pluck maxDelayInBlocks freq damping =
  accumulate2U (mkPluckState maxDelayInBlocks) (accumulatePluck (natVal maxDelayInBlocks * audioBlockSize - 1)) (\s -> (#s, True#)) freq damping

-----------
-- Interlude: Interpolation

cubicInterpolation :: Float -> Float -> Float -> Float -> Float -> Float
cubicInterpolation p0 p1 p2 p3 mu =
  a0 * mu * mewTwo + a1 * mewTwo + a2 * mu + a3
  where
    a0     = p3 - p2 - p0 + p1
    a1     = p0 - p1 - a0
    a2     = p2 - p0
    a3     = p1
    mewTwo = mu * mu -- Get it?

cosineInterpolation :: Float -> Float -> Float -> Float
cosineInterpolation y1 y2 mu =
  y1 * (1 - mu2) + y2 * mu2
  where
    mu2 = (1 - cosine (mu * pi)) / 2

-- Larange interpolation for Fractional Delay lines
-- https://ccrma.stanford.edu/~jos/pasp/Larange_Interpolation.html
-- Thanks ccrma for the great info!
lagrangeInterpolation3 :: Float -> Float -> Float -> Float -> Float -> Float
lagrangeInterpolation3 s0 s1 s2 s3 delta =
  s0 * h0 + s1 * h1 + s2 * h2 + s3 * h3
  where
    h0 = -1 * (((delta - 1) * (delta - 2) * (delta - 3)) / 6)
    h1 = (delta * (delta - 2) * (delta - 3)) / 2
    h2 = -1 * ((delta * (delta - 1) * (delta - 3)) / 2)
    h3 = (delta * (delta - 1) * (delta - 2)) / 6

lagrangeInterpolation4 :: Float -> Float -> Float -> Float -> Float -> Float -> Float
lagrangeInterpolation4 s0 s1 s2 s3 s4 delta =
  s0 * h0 + s1 * h1 + s2 * h2 + s3 * h3 + s4 * h4
  where
    dm1 = delta - 1
    dm2 = delta - 2
    dm3 = delta - 3
    dm4 = delta - 4
    h0  = (dm1 * dm2 * dm3 * dm4) / 24
    h1  = (0 - delta * dm2 * dm3 * dm4) / 6
    h2  = (delta * dm1 * dm3 * dm4) / 4
    h3  = (0 - delta * dm1 * dm2 * dm4) / 6
    h4  = (delta * dm1 * dm2 * dm3) / 24

-----------
-- Delay Line
-- Note: This is a non-fractional delay line which can only perform integral delay lengths
data Delay n = Delay# (.Array (NatNextPowerOfTwo n) Float) UInt UInt UInt

nextPowerOfTwoNatVal :: NatVal n -> NatVal (NatNextPowerOfTwo n)
nextPowerOfTwoNatVal _ = NatVal

mkDelay :: UInt -> NatVal n -> *Delay n
mkDelay delayLength n =
  Delay# arr sizeMask 0 outCursor
  where
    pow2n        = nextPowerOfTwoNatVal n
    sizeMask     = natVal pow2n - 1
    arr          = arrayFrom 0
    outCursor    = bitAnd (0 - delayLength) sizeMask

delayReadOutput :: *Delay n -> (#Float, *Delay n#)
delayReadOutput (Delay# arr0 sizeMask inCursor outCursor) =
  (#out, Delay# arr1 sizeMask inCursor outCursor#)
  where
    (#out, arr1#) = readArrayU (unsafeUIntToIndex outCursor) arr0

delayTick :: Float -> *Delay n -> *Delay n
delayTick sample (Delay# arr0 sizeMask inCursor0 outCursor0) =
  Delay# arr1 sizeMask inCursor1 outCursor1
  where
    inCursor1  = bitAnd (inCursor0 + 1) sizeMask
    outCursor1 = bitAnd (outCursor0 + 1) sizeMask
    arr1       = writeArray (unsafeUIntToIndex inCursor1) sample arr0


-----------
-- Fractional Delay Line
data FractionalDelay n = FractionalDelay# (.Array (NatNextPowerOfTwo n) Float) UInt Float Float UInt UInt

mkFractionalDelay :: NatVal n -> *FractionalDelay n
mkFractionalDelay n =
  FractionalDelay# arr sizeMask stringLength 0 0 0
  where
    sizeMask     = natVal n - 1
    stringLength = fromUInt sizeMask
    arr          = arrayFrom 0

fracDelaySetDelay :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetDelay delayLength (FractionalDelay# arr sizeMask _ _ inCursor _) =
  FractionalDelay# arr sizeMask delayLength delta inCursor outCursor
  where
    outCursor        = bitAnd (inCursor - (floatToUInt delayLength)) sizeMask
    delta            = 1 - (delayLength - floor delayLength)

-- Do we need the + 1 or not?
fracDelaySetDelayFromFreq :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetDelayFromFreq freq (FractionalDelay# arr sizeMask _ _ inCursor _) =
  FractionalDelay# arr sizeMask stringLength delta inCursor outCursor
  where
    stringLength     = ((audioSampleRateF / freq) / 2)
    outCursor        = bitAnd (inCursor - (floatToUInt stringLength)) sizeMask
    delta            = 1 - (stringLength - floor stringLength)

fracDelayReadOutput :: *FractionalDelay n -> (#Float, *FractionalDelay n#)
fracDelayReadOutput (FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor) =
  (#out, FractionalDelay# arr5 sizeMask stringLength delta inCursor outCursor#)
  where
    index0       = outCursor
    indexM1      = bitAnd (index0 - 1) sizeMask
    indexM2      = bitAnd (index0 - 2) sizeMask
    index1       = bitAnd (index0 + 1) sizeMask
    index2       = bitAnd (index0 + 2) sizeMask
    (#s0, arr1#) = readArrayU (unsafeUIntToIndex indexM2) arr0
    (#s1, arr2#) = readArrayU (unsafeUIntToIndex indexM1) arr1
    (#s2, arr3#) = readArrayU (unsafeUIntToIndex index0) arr2
    (#s3, arr4#) = readArrayU (unsafeUIntToIndex index1) arr3
    (#s4, arr5#) = readArrayU (unsafeUIntToIndex index2) arr4
    out          = lagrangeInterpolation4 s0 s1 s2 s3 s4 (2.0 + delta)

fracDelayReadFromPos :: Float -> *FractionalDelay n -> (#Float, *FractionalDelay n#)
fracDelayReadFromPos readPos (FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor) =
  (#out, FractionalDelay# arr5 sizeMask stringLength delta inCursor outCursor#)
  where
    readOffset   = floatToUInt (readPos * stringLength)
    index0       = bitAnd (outCursor - readOffset) sizeMask
    indexM1      = bitAnd (index0 - 1) sizeMask
    indexM2      = bitAnd (index0 - 2) sizeMask
    index1       = bitAnd (index0 + 1) sizeMask
    index2       = bitAnd (index0 + 2) sizeMask
    (#s0, arr1#) = readArrayU (unsafeUIntToIndex indexM2) arr0
    (#s1, arr2#) = readArrayU (unsafeUIntToIndex indexM1) arr1
    (#s2, arr3#) = readArrayU (unsafeUIntToIndex index0) arr2
    (#s3, arr4#) = readArrayU (unsafeUIntToIndex index1) arr3
    (#s4, arr5#) = readArrayU (unsafeUIntToIndex index2) arr4
    out          = lagrangeInterpolation4 s0 s1 s2 s3 s4 (2.0 + delta)

fracDelaySetPos :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelaySetPos inCursorPos (FractionalDelay# arr0 sizeMask stringLength delta _ _) =
  FractionalDelay# arr0 sizeMask stringLength delta inCursor outCursor
  where
    inCursor  = bitAnd (floatToUInt (inCursorPos * stringLength)) sizeMask
    outCursor = bitAnd (inCursor - (floatToUInt stringLength)) sizeMask

fracDelayTick :: Float -> *FractionalDelay n -> *FractionalDelay n
fracDelayTick sample (FractionalDelay# arr0 sizeMask stringLength delta inCursor0 outCursor0) =
  FractionalDelay# arr1 sizeMask stringLength delta inCursor1 outCursor1
  where
    inCursor1  = bitAnd (inCursor0 + 1) sizeMask
    outCursor1 = bitAnd (outCursor0 + 1) sizeMask
    arr1       = writeArray (unsafeUIntToIndex inCursor1) sample arr0


-----------
-- Waveguide Synthesis: Pluck

data WaveGuidePluckState n = WaveGuidePluckState# (.FractionalDelay (NatMul BlockSize n)) (.FractionalDelay (NatMul BlockSize n)) OnePole

waveGuideBridgeReflection :: Float -> Float -> Float -> (#Float, Float#)
waveGuideBridgeReflection sustain sample state0 =
  (#negate state1, state1#)
  where
    state1 = sample * sustain + state0 * (1 - sustain)

accumulateWaveGuidePluck :: Float -> Float -> Float -> Float -> *WaveGuidePluckState n -> (#*WaveGuidePluckState n, Float#)
accumulateWaveGuidePluck brightness sustain freq pickupLocation (WaveGuidePluckState# leftBuffer0 rightBuffer0 bridgeReflectionState0) =
  (#WaveGuidePluckState# leftBuffer4 rightBuffer4 bridgeReflectionState1, out#)
  where
    leftBuffer1                                   = fracDelaySetDelayFromFreq freq leftBuffer0 -- Set Freq
    rightBuffer1                                  = fracDelaySetDelayFromFreq freq rightBuffer0
    -- Read Outputs
    (#pickupSampleLeft,  leftBuffer2#)            = fracDelayReadFromPos pickupLocation leftBuffer1
    (#pickupSampleRight, rightBuffer2#)           = fracDelayReadFromPos pickupLocation rightBuffer1
    (#bridgeSample, leftBuffer3#)                 = fracDelayReadOutput leftBuffer2
    (#nutSample, rightBuffer3#)                   = fracDelayReadOutput rightBuffer2
    -- Nut and Bridge
    invertedNutReflection                         = negate nutSample
    (#bridgeReflection0, bridgeReflectionState1#) = onePoleTick brightness sustain bridgeSample bridgeReflectionState0
    bridgeReflection                              = negate bridgeReflection0

    -- Tick Delays
    leftBuffer4                                   = fracDelayTick invertedNutReflection leftBuffer3
    rightBuffer4                                  = fracDelayTick bridgeReflection rightBuffer3
    -- Out
    out                                           = (pickupSampleLeft + pickupSampleRight) + (bridgeReflection + invertedNutReflection) * 0.125
    -- out                                          = pickupSampleLeft

-- -- Option for either somehow? pizz vs pluck?
-- -- randLCG pluck init
-- mkWaveGuidePluckState :: NatVal n -> Float -> Float -> Float -> () -> *WaveGuidePluckState n
-- mkWaveGuidePluckState n pickLocation pickAmplitude freq _ =
--   WaveGuidePluckState# left3 right3 default
--   where
--     delaySize      = natVal n * audioBlockSize
--     pickAmplitudeN = negate pickAmplitude
--     left0  = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq -- TODO: put freq argument into mkFractionalDelay so that we don't have to set it after we mk it
--     right0 = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
--     (#_, _, left2, right2#) =
--       loop (#i, seed0, left1, right1#) = (#0, 1337, left0, right0#) while i < delaySize do
--         let
--           (#seed1, randL#) = randLCG -1 1 seed0
--           (#seed2, randR#) = randLCG -1 1 seed1
--         in
--           (#i + 1, seed2, fracDelayTick (randL * pickAmplitude) left1, fracDelayTick (randR * pickAmplitudeN) right1#)
--     left3  = fracDelaySetPos pickLocation left2
--     right3 = fracDelaySetPos pickLocation right2

-- Original pluck waveform init
mkWaveGuidePluckState :: NatVal n -> Float -> Float -> Float -> () -> *WaveGuidePluckState n
mkWaveGuidePluckState n pickLocation pickAmplitude freq _ =
  WaveGuidePluckState# left2 right2 default
  where
    pickAmplitudeN = negate pickAmplitude
    fullLength     = ((audioSampleRateF / freq) / 2)
    delaySize      = min (floatToUInt fullLength) (natVal n * audioBlockSize)
    pickSample     = max (fullLength * pickLocation) 1
    pickIndex      = pickSample |> floatToUInt
    upSlope        = 1 / pickSample
    downSlope      = 1 / (fullLength - pickSample - 1)
    left00         = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
    right00        = mkFractionalDelay NatVal |> fracDelaySetDelayFromFreq freq
    (#_, _, left1, right1#) =
      loop (#i, seed0, left0, right0#) = (#0, 1337, left00, right00#) while i < delaySize do
        let
          (#seed1, randL#) = randLCG -1 1 seed0
          (#seed2, randR#) = randLCG -1 1 seed1
          ri          = (delaySize - 1) - i
          rightSample =
            if i < pickIndex then
              (upSlope * fromUInt i) * pickAmplitude
            else
              (downSlope * (fullLength - 1 - fromUInt i))
          leftSample =
            if ri < pickIndex then
              (upSlope * fromUInt ri)
            else
              (downSlope * (fullLength - 1 - fromUInt ri))
          leftSample2  = lerp randL (leftSample * 2 - 1) 0.8 * pickAmplitude
          rightSample2 = lerp (randR * -1) ((rightSample * 2 - 1) * -1) 0.8 * pickAmplitude
          -- leftSample2  = (leftSample * 2 - 1)
          -- rightSample2 = ((rightSample * 2 - 1) * -1)
        in
          (#i + 1, seed2, fracDelayTick leftSample2 left0, fracDelayTick rightSample2 right0#)
    left2  = fracDelaySetPos pickLocation left1
    right2 = fracDelaySetPos (1 - pickLocation) right1

waveGuidePluck :: NatVal n -> Float -> Float -> Float -> Float -> Float -> Mono Audio -> Mono Audio
waveGuidePluck maxDelayInBlocks pickLocation pickAmplitude brightness sustain freq pickupLocation =
  accumulate1U (mkWaveGuidePluckState maxDelayInBlocks pickLocation pickAmplitude freq) (accumulateWaveGuidePluck (clamp brightness 0 1) (clamp sustain 0 1) freq) (\s -> (#s, True#)) pickupLocation

-----------
-- Waveguide Synthesis: Bow
-- based on:
--   https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Bowed_String.html

-- Collapse this into only 2 fractional delays
data WaveGuideBowState n =
  WaveGuideBowState#
    (.FractionalDelay (NatMul BlockSize n)) -- Neck Delay
    (.FractionalDelay (NatMul BlockSize n)) -- Bridge Delay
    OnePole
    ViolinBodyFilter

-- TODO: Start at bow location???
mkWaveGuideBowState :: NatVal n -> () -> *WaveGuideBowState n
mkWaveGuideBowState _ _ =
  WaveGuideBowState#
    (mkFractionalDelay NatVal)
    (mkFractionalDelay NatVal)
    default
    default

bowTable :: Float -> Float -> Float -> Float -> Float -> Float
bowTable diffVelocity offset slope minOut maxOut =
  x4
  where
    x0 = diffVelocity + offset
    x1 = x0 * slope
    x2 = abs x1 + 0.75
    x3 = pow x2 -4
    x4 = clamp x3 minOut maxOut

accumulateWaveGuideBow :: Float -> Float -> Float -> Float -> Float -> Float -> *WaveGuideBowState n -> (#*WaveGuideBowState n, Float#)
accumulateWaveGuideBow bowLocation brightness sustain bowSlope bowVelocity freq (WaveGuideBowState# neckDelay0 bridgeDelay0 bridgeReflectionState0 bodyState0) =
  (#stateOut, out#)
  where
    fullStringLength                              = (audioSampleRateF / freq) - 2
    bowToNutLength                                = fullStringLength * (1 - bowLocation)
    bridgeToBowLength                             = fullStringLength * bowLocation

    -- Update delay lengths
    neckDelay1                                    = fracDelaySetDelay bowToNutLength neckDelay0
    bridgeDelay1                                  = fracDelaySetDelay bridgeToBowLength bridgeDelay0

    -- Read outputs from delays
    (#neckSample,   neckDelay2#)                  = fracDelayReadOutput neckDelay1
    (#bridgeSample, bridgeDelay2#)                = fracDelayReadOutput bridgeDelay1

    -- Values
    invertedNutReflection                         = negate neckSample
    pole                                          = 0.65 - (brightness * 48000 * 0.5 * recipSampleRate)
    (#bridgeReflection0, bridgeReflectionState1#) = onePoleTick pole sustain bridgeSample bridgeReflectionState0
    bridgeReflection1                             = negate bridgeReflection0
    (#bodyState1, bodyResonance#)                 = violinBodyfilterAccumulate (bridgeSample * 0.8 * sustain) bodyState0
    bridgeReflection                              = bridgeReflection1 * 0.75 + bodyResonance * 0.25

    -- Nonlinear scattering junction
    stringVelocity                                = bridgeReflection + invertedNutReflection
    differentialVelocity                          = bowVelocity - stringVelocity
    newVelocity                                   = bowTable differentialVelocity 0 bowSlope 0 1 * differentialVelocity
    neckDelayInput                                = bridgeReflection + newVelocity
    bridgeDelayInput                              = invertedNutReflection + newVelocity

    -- Write inputs to delays
    neckDelay3                                    = fracDelayTick neckDelayInput neckDelay2
    bridgeDelay3                                  = fracDelayTick bridgeDelayInput bridgeDelay2

    -- Out
    -- out                                           = (bowToBridgeSample + bridgeReflection) * 0.5
    -- out                                           = bridgeReflection
    -- out                                           = bridgeSample * 0.75 + bridgeReflection * 0.25
    out                                           = bodyResonance
    -- out                                           = bridgeSample
    stateOut                                      = WaveGuideBowState# neckDelay3 bridgeDelay3 bridgeReflectionState1 bodyState1

waveGuideBow :: NatVal n -> Float -> Float -> Float -> Float -> Mono Audio -> Mono Audio -> Mono Audio
waveGuideBow maxDelayInBlocks bowLocation brightness sustain bowSlope bowVelocity freq =
  accumulate2U
    (mkWaveGuideBowState maxDelayInBlocks)
    (accumulateWaveGuideBow (clamp bowLocation 0 1) (clamp brightness 0 1) (clamp sustain 0 1) (max bowSlope 0))
    (\s -> (#s, True#))
    bowVelocity
    freq

-- Cascaded second order sections via Esteban Maestre
data ViolinBodyFilter =
  ViolinBodyFilter# BiquadState BiquadState BiquadState BiquadState BiquadState BiquadState

instance Default ViolinBodyFilter where
  default = ViolinBodyFilter# default default default default default default

violinBodyFilterTick :: Float -> Float -> Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
violinBodyFilterTick b0 b1 b2 a1 a2 x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 y0 y1, y0#)
  where
    y0 =
      (b0 * x0 + b1 * x1 + b2 * x2) -
      (a2 * y2 + a1 * y1)

violinBodyfilterAccumulate :: Float -> ViolinBodyFilter -> (#ViolinBodyFilter, Float#)
violinBodyfilterAccumulate input (ViolinBodyFilter# bq0 bq1 bq2 bq3 bq4 bq5) =
  (#ViolinBodyFilter# bq0' bq1' bq2' bq3' bq4' bq5', output5 * 0.1248#)
  where
    (#bq0', output0#) = violinBodyFilterTick 1  1.5667 0.3133 -0.5509 -0.3925 input   bq0
    (#bq1', output1#) = violinBodyFilterTick 1 -1.9537 0.9542 -1.6357  0.8697 output0 bq1
    (#bq2', output2#) = violinBodyFilterTick 1 -1.6683 0.8852 -1.7674  0.8735 output1 bq2
    (#bq3', output3#) = violinBodyFilterTick 1 -1.8585 0.9653 -1.8498  0.9516 output2 bq3
    (#bq4', output4#) = violinBodyFilterTick 1 -1.9299 0.9621 -1.9354  0.9590 output3 bq4
    (#bq5', output5#) = violinBodyFilterTick 1 -1.9800 0.9888 -1.9867  0.9923 output4 bq5

violinBodyFilter :: AudioFormat f => f Audio -> f Audio
violinBodyFilter input =
  accumulate1 violinBodyfilterAccumulate constTrue input


----------------------
-- Modal Bar
-- https://ccrma.stanford.edu/workshops/dsp2008/prc/PDFs/stringbar.pdf
----------------------

data ModalFrequency = ModalFrequency# Float Float Float Float -- 4 Modes
data ModalResonance = ModalResonance# Float Float Float Float -- 4 Modes
data ModalAmplitude = ModalAmplitude# Float Float Float Float -- 4 Modes
data ModalStickSig  = ModalStickSig#  Float Float Float       -- Hardness Position Gain
data ModalSignature =
  ModalSignature
    ModalFrequency
    ModalResonance
    ModalAmplitude
    ModalStickSig

marimbaSig :: ModalSignature
marimbaSig =
  ModalSignature
    (ModalFrequency# 1 3.99 10.65 -2443)
    (ModalResonance# 0.9996 0.9994 0.9994 0.999)
    (ModalAmplitude# 0.04 0.01 0.01 0.008)
    (ModalStickSig# 0.429688 0.445312 0.093750)

woodSig :: ModalSignature
woodSig =
  ModalSignature
    (ModalFrequency# 1 2.777 7.378 15.377)
    (ModalResonance# 0.996 0.994 0.994 0.99)
    (ModalAmplitude# 0.04 0.01 0.01 0.008)
    (ModalStickSig# 0.460938 0.375 0.046875)

resoSig :: ModalSignature
resoSig =
  ModalSignature
    (ModalFrequency# 1 2.777 7.378 15.377)
    (ModalResonance# 0.99996 0.99994 0.99994 0.9999)
    (ModalAmplitude# 0.02 0.005 0.005 0.004)
    (ModalStickSig# 0.453125 0.25 0.101562)

-- WaveTable

data Biquad   = Biquad# Float Float Float Float Float
data ModalBar =
  ModalBar#
    BiquadState
    BiquadState
    BiquadState
    BiquadState
    OnePole
    EnvState

-- TODO: biquadTick
-- TODO: Make AudioBuffer (Array n Float)
-- TODO: audioFileToBuffer :: AudioFormat f => AudioFile -> f (AudioBuffer)
-- TODO: Strike waveform
-- modalBar :: AudioBuffer -> ModalSignature -> (Float, Float, Float) -> Float -> Float

-- myCoolSynth =
--   modalBar woodStrike woodSig (0.01, 0.5, -1) 0.1 0.2

biquadTick :: Biquad -> Float -> BiquadState -> (#BiquadState, Float#)
biquadTick (Biquad# b0 b1 b2 a1 a2) x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 y0 y1, y0#)
  where
    y0 =
      (b0 * x0 + b1 * x1 + b2 * x2) -
      (a2 * y2 + a1 * y1)

modalBarMkModeBiquad :: Float -> Float -> Float -> Biquad
modalBarMkModeBiquad ratio radius baseFreq =
  Biquad# b0 b1 b2 a1 a2
  where
    freq = if ratio >= 0 then ratio * baseFreq else ratio
    a1   = radius * radius
    a2   = -2 * radius * cosine (tau * freq * recipSampleRate)
    b0   = 1
    b1   = 0
    b2   = -1
    -- b0   = 0.5 - 0.5 * a2
    -- b1   = 0
    -- b2   = negate b0

-- onePoleTick

-- modalBarTick :: Biquad -> Biquad -> Biquad -> Biquad -> Float

natOne :: NatVal 1
natOne = NatVal

natTwo :: NatVal 2
natTwo = NatVal

natThree :: NatVal 3
natThree = NatVal

natFour :: NatVal 4
natFour = NatVal

natFive :: NatVal 5
natFive = NatVal

natSix :: NatVal 6
natSix = NatVal

natSeven :: NatVal 7
natSeven = NatVal

natEight :: NatVal 8
natEight = NatVal

natSixteen :: NatVal 16
natSixteen = NatVal

clip :: AudioFormat f => f Audio -> f Audio
clip cs =
  map f cs
  where
    f ia =
      case ia of
        AudioEnd    -> AudioEnd
        BlockRate x -> BlockRate (clamp x -1 1)
        AudioRate c ->
          AudioRate <|
            freezeArray <|
              loop oa = audioInitArray () for i <- each do
                writeArray i (clamp (readArray i c) -1 1) oa


----------------------
-- Freeverb
----------------------

-- TODO / HACK / CRASH: Preset Nat values in data constructors is causing the compiler to crash!!!!!
-- We SHOULD be able to do:
-- data FreeVerbCombFilter = FreeVerbCombFilter# (.FractionalDelay 2048) Float

-- A Lowpass Feedback Combfilter
data FreeVerbCombFilter n = FreeVerbCombFilter# (.Delay n) Float
data FreeVerbAllPass    n = FreeVerbAllPass (.Delay n)
data FreeVerb c a         =
  FreeVerb#
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbCombFilter c)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)
    (.FreeVerbAllPass a)

mkFreeVerb :: UInt -> () -> *FreeVerb 2048 1024
mkFreeVerb stereoSpread _ =
  FreeVerb# c0 c1 c2 c3 c4 c5 c6 c7 a0 a1 a2 a3
  where
    c0 = FreeVerbCombFilter# (mkDelay (1557 + stereoSpread) NatVal) 0
    c1 = FreeVerbCombFilter# (mkDelay (1617 + stereoSpread) NatVal) 0
    c2 = FreeVerbCombFilter# (mkDelay (1491 + stereoSpread) NatVal) 0
    c3 = FreeVerbCombFilter# (mkDelay (1422 + stereoSpread) NatVal) 0
    c4 = FreeVerbCombFilter# (mkDelay (1277 + stereoSpread) NatVal) 0
    c5 = FreeVerbCombFilter# (mkDelay (1356 + stereoSpread) NatVal) 0
    c6 = FreeVerbCombFilter# (mkDelay (1188 + stereoSpread) NatVal) 0
    c7 = FreeVerbCombFilter# (mkDelay (1116 + stereoSpread) NatVal) 0
    a0 = FreeVerbAllPass (mkDelay (225 + stereoSpread) NatVal)
    a1 = FreeVerbAllPass (mkDelay (556 + stereoSpread) NatVal)
    a2 = FreeVerbAllPass (mkDelay (441 + stereoSpread) NatVal)
    a3 = FreeVerbAllPass (mkDelay (341 + stereoSpread) NatVal)

freeVerbCombFilterTick :: Float -> Float -> Float -> *FreeVerbCombFilter 2048 -> (#*FreeVerbCombFilter 2048, Float#)
freeVerbCombFilterTick roomSize damp x (FreeVerbCombFilter# delay0 zs0) =
  (#FreeVerbCombFilter# delay2 zs1, y0#)
  where
    damp1          = damp * 0.4
    damp2          = 1 - damp1
    feedback       = roomSize * 0.28 + 0.7
    (#y0, delay1#) = delayReadOutput delay0
    zs1            = y0 * damp2 + zs0 * damp1
    y1             = x * 0.015 + zs1 * feedback
    delay2         = delayTick y1 delay1

freeVerbAllPassTick :: Float -> Float -> *FreeVerbAllPass 1024 -> (#*FreeVerbAllPass 1024, Float#)
freeVerbAllPassTick feedback x (FreeVerbAllPass delay0) =
  (#FreeVerbAllPass delay2, y0#)
  where
    (#delayOut, delay1#) = delayReadOutput delay0
    y0                   = negate x + delayOut
    y1                   = x + delayOut * feedback
    delay2               = delayTick y1 delay1

freeVerbTick :: Float -> Float -> Float -> Float -> *FreeVerb 2048 1024 -> (#*FreeVerb 2048 1024, Float#)
freeVerbTick mix roomSize damp x (FreeVerb# c0 c1 c2 c3 c4 c5 c6 c7 a0 a1 a2 a3) =
  (#FreeVerb# c0' c1' c2' c3' c4' c5' c6' c7' a0' a1' a2' a3', y#)
  where
    (#c0', sc0#) = freeVerbCombFilterTick roomSize damp x c0 -- Comb Filters, in parallel
    (#c1', sc1#) = freeVerbCombFilterTick roomSize damp x c1
    (#c2', sc2#) = freeVerbCombFilterTick roomSize damp x c2
    (#c3', sc3#) = freeVerbCombFilterTick roomSize damp x c3
    (#c4', sc4#) = freeVerbCombFilterTick roomSize damp x c4
    (#c5', sc5#) = freeVerbCombFilterTick roomSize damp x c5
    (#c6', sc6#) = freeVerbCombFilterTick roomSize damp x c6
    (#c7', sc7#) = freeVerbCombFilterTick roomSize damp x c7
    combsOut     = sc0 + sc1 + sc2 + sc3 + sc4 + sc5 + sc6 + sc7
    (#a0', sa0#) = freeVerbAllPassTick 0.5 combsOut a0 -- Allpass filters, in series
    (#a1', sa1#) = freeVerbAllPassTick 0.5 sa0 a1
    (#a2', sa2#) = freeVerbAllPassTick 0.5 sa1 a2
    (#a3', sa3#) = freeVerbAllPassTick 0.5 sa2 a3
    y            = x * (1 - mix) + sa3 * mix

-- mix: 0 - 1
-- roomSize: 0 - 1
-- damp: 0 - 1
freeVerb :: Float -> Float -> Float -> Stereo Audio -> Stereo Audio
freeVerb mix roomSize damp (Stereo# l0 r0) =
  Stereo# l1 r1
  where
    l1 = accumulateAudio1U (mkFreeVerb 0) (freeVerbTick mix roomSize damp) constTrueU l0
    r1 = accumulateAudio1U (mkFreeVerb 23) (freeVerbTick mix roomSize damp) constTrueU r0


--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue# Rational SeqControl (Maybe a)
data Seq a      = Seq (() -> SeqValue a)

mergeSeqValueTimes :: Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes xt xc yt yc =
  case xc of
    SeqPure -> yt
    _ ->
      case yc of
        SeqPure -> xt
        _       -> min xt yt

mergeSeqValueTimes3 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes3 xt xc yt yc zt zc =
  case xc of
    SeqPure -> mergeSeqValueTimes yt yc zt zc
    _ ->
      case yc of
        SeqPure -> mergeSeqValueTimes xt xc zt zc
        _       ->
          case zc of
            SeqPure -> mergeSeqValueTimes xt xc yt yc
            _       -> min (min xt yt) zt

mergeSeqValueTimes4 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes4 wt wc xt xc yt yc zt zc =
  case wc of
    SeqPure -> mergeSeqValueTimes3 xt xc yt yc zt zc
    _       ->
      case xc of
        SeqPure -> mergeSeqValueTimes3 wt wc yt yc zt zc
        _ ->
          case yc of
            SeqPure -> mergeSeqValueTimes3 wt wc xt xc zt zc
            _       ->
              case zc of
                SeqPure -> mergeSeqValueTimes3 wt wc xt xc yt yc
                _       -> min (min (min wt xt) yt) zt

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

instance Eq SeqControl where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

seqControlFromEnumAlt :: SeqControl -> Int
seqControlFromEnumAlt s =
  case s of
    SeqNormal   -> 0
    SeqLoopEnd  -> 1
    SeqPure     -> 2
    SeqBlockEnd -> 3
    SeqEnd      -> 4

seqControlAlternative :: SeqControl -> SeqControl -> SeqControl
seqControlAlternative x y =
  if lt (seqControlFromEnumAlt x) (seqControlFromEnumAlt y) then
    x
  else
    y

instance Functor SeqValue where
  map f (SeqValue# t c x) =
    SeqValue# t c (map f x)

instance FunctorN SeqValue where
  map2 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (xc <> yc) (map2 f xv yv)
  map3 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes3 xt xc yt yc zt zc) (xc <> yc <> zc) (map3 f xv yv zv)
  map4 f (SeqValue# wt wc wv) (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes4 wt wc xt xc yt yc zt zc) (wc <> xc <> yc <> zc) (map4 f wv xv yv zv)

instance Applicative SeqValue where
  pure x = SeqValue# 1 SeqPure (Just x)
  ap (SeqValue# ft fc fv) (SeqValue# xt xc xv) =
    SeqValue# (mergeSeqValueTimes xt xc ft fc) (fc <> xc) (ap fv xv)

instance Semigroup a => Semigroup (SeqValue a) where
  append (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (append xc yc) (append xv yv)

instance Monoid (SeqValue a) where
  mempty = SeqValue# 1 SeqPure nothing

instance Alternative SeqValue where
  empty = SeqValue# 1 SeqEnd nothing
  alternative (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (seqControlAlternative xc yc) (alternative xv yv)

instance Default (SeqValue a) where
  default = SeqValue# 1 SeqPure nothing

instance Eq a => Eq (SeqValue a) where
  eq  (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt == yt && xc == tc && xv == yv
  neq (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt /= yt || xc /= tc || xv /= yv

instance Semiring a => Semiring (SeqValue a) where
  zero    = SeqValue# 1 SeqPure (Just zero)
  one     = SeqValue# 1 SeqPure (Just one)
  add x y = map2 add x y
  mul x y = map2 mul x y

instance Ring a => Ring (SeqValue a) where
  sub x y   = map2 sub x y
  fromInt i = SeqValue# 1 SeqPure (Just (fromInt i))

instance EuclideanRing a => EuclideanRing (SeqValue a) where
  div x y = map2 div x y
  rem x y = map2 rem x y

instance DivisionRing a => DivisionRing (SeqValue a) where
  recip x = map recip x

instance Num a => Num (SeqValue a) where
  signum x  = map signum x
  abs x     = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (SeqValue a) where

instance Floating a => Floating (SeqValue a) where
  fromFloat f = SeqValue# 1 SeqPure (Just (fromFloat f))
  sqrt f      = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x
  -- fmin      x y = map2 fmin x y
  -- fmax      x y = map2 fmax x y

runSeq :: Seq a -> () -> SeqValue a
runSeq (Seq stepFunc) _ = stepFunc ()

runSeq2 :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeq2 sx sy =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv#) ->
          let
            t = min xt yt
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
          in
            (#x, y#)

runSeq3 :: Seq a -> Seq b -> Seq c -> (#SeqValue a, SeqValue b, SeqValue c#)
runSeq3 sx sy sz =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min xt yt) zt
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz () else SeqValue# (zt - t) zc zv
          in
            (#x, y, z#)

runSeq4 :: Seq a -> Seq b -> Seq c -> Seq d -> (#SeqValue a, SeqValue b, SeqValue c, SeqValue d#)
runSeq4 sw sx sy sz =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# wt wc wv, SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min (min wt xt) yt) zt
            w = if wt <= t then runSeq sw () else SeqValue# (wt - t) wc wv
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz () else SeqValue# (zt - t) zc zv
          in
            (#w, x, y, z#)

seqValueDuration :: SeqValue a -> Rational
seqValueDuration (SeqValue# t _ _) = t

seqValueControl :: SeqValue a -> SeqControl
seqValueControl (SeqValue# _ c _) = c

runSeqOnLeft :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnLeft ls rs =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc _, SeqValue# rt rc rv#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue# (lt - t) lc nothing
            r = if rt <= t then runSeq rs () else SeqValue# (rt - t) rc rv
          in
            (#l, r#)

runSeqOnRight :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnRight ls rs =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc lv, SeqValue# rt rc _#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue# (lt - t) lc lv
            r = if rt <= t then runSeq rs () else SeqValue# (rt - t) rc nothing
          in
          (#l, r#)

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy       = Seq (\_ -> let (#x, y#)       = runSeq2 sx sy       in map2 f x y)
  map3 f sx sy sz    = Seq (\_ -> let (#x, y, z#)    = runSeq3 sx sy sz    in map3 f x y z)
  map4 f sw sx sy sz = Seq (\_ -> let (#w, x, y, z#) = runSeq4 sw sx sy sz in map4 f w x y z)

instance Eq a => Eq (Seq a) where
  eq  sx sy = let (#x, y#) = runSeq2 sx sy in x == y
  neq sx sy = let (#x, y#) = runSeq2 sx sy in x == y

instance Semiring a => Semiring (Seq a) where
  zero      = Seq (\_ -> pure zero)
  one       = Seq (\_ -> pure one)
  add sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 add x y)
  mul sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 mul x y)

instance Ring a => Ring (Seq a) where
  sub sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 sub x y)
  fromInt i = Seq (\_ -> pure (fromInt i))

instance EuclideanRing a => EuclideanRing (Seq a) where
  div sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 div x y)
  rem sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 rem x y)

instance DivisionRing a => DivisionRing (Seq a) where
  recip x = Seq (\_ -> map recip (runSeq x ()))

instance Num a => Num (Seq a) where
  signum x  = map signum x
  abs x     = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (Seq a) where

instance Floating a => Floating (Seq a) where
  fromFloat f = Seq (\_ -> pure (fromFloat f))
  sqrt f = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x
  -- fmin      x y = map2 fmin x y
  -- fmax      x y = map2 fmax x y

instance Semigroup (Seq a) where
  append sx sy = [sx sy]

instance Monoid (Seq a) where
  mempty = Seq (\_ -> SeqValue# 1 SeqPure nothing)

instance Alternative Seq where
  empty             = Seq (\_ -> SeqValue# 1 SeqPure nothing)
  alternative sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in alternative x y)

-- TODO: <|>

-- Biased BinOps
-- +@  @+  +
-- -@  @-  -
-- *@  @*  *
-- /@  @/  /
-- <@  @< @<@
-- >@  @> @>@

-- TODO:
-- %@ @%

leftConst :: a -> b -> a
leftConst x _ = x

rightConst :: a -> b -> b
rightConst _ y = y

addSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
addSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 add l r)

addSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
addSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 add l r)

subSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
subSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 sub l r)

subSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
subSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 sub l r)

mulSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 mul l r)

mulSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 mul l r)

divSeqOnLeft :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 div l r)

divSeqOnRight :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 div l r)

leftConstSeqOnLeft :: Seq a -> Seq b -> Seq a
leftConstSeqOnLeft ls _ = ls

leftConstSeqOnRight :: Seq a -> Seq b -> Seq a
leftConstSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 leftConst l r)

rightConstSeqOnLeft :: Seq a -> Seq b -> Seq b
rightConstSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 rightConst l r)

rightConstSeqOnRight :: Seq a -> Seq b -> Seq b
rightConstSeqOnRight _ rs = rs

leftConstSeqOnBoth :: Seq a -> Seq b -> Seq a
leftConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 leftConst l r)

rightConstSeqOnBoth :: Seq a -> Seq b -> Seq b
rightConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 rightConst l r)


-- addSeqOnLeftTest :: Seq Int
-- addSeqOnLeftTest =
--   [1 _ <2 3>] @+ [4 <5 6> <7 8 9>] *@ [1 2 _ 5] @- <3 4 5> @> fromInt mouseX

-- mouseBeat :: Seq Float
-- mouseBeat = fromInt mouseX <@ coolBeat

-- addSeqOnRightTest :: SeqValue Int
-- addSeqOnRightTest = runSeq (rightConstSeqOnLeft 1 2) ()

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue# 1 SeqPure nothing

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

seqValueDurationMul :: Rational -> SeqValue a -> SeqValue a
seqValueDurationMul speed (SeqValue# t c v) =
  SeqValue# (t * speed) c v

seqSpeed :: Rational -> Seq a -> Seq a
seqSpeed speed seq =
  Seq (\_ -> seqValueDurationMul (recip speed) (runSeq seq ()))

bpm :: Int -> Rational
bpm tempoInBPM =
  tempoInBPM // 60

toSeq :: SeqValue a -> Seq a
toSeq sv =
  Seq (\_ -> sv)

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  if (slot + 1) < maxSlot then
    SeqNormal
  else
    SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue# t c v ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#(slot + 1) % maxSlot, SeqValue# t controlIfNotNormal v#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (seqValueDurationMul (1 // maxSlot) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqLoopEnd sv

repeat :: UInt -> Seq a -> Seq a
repeat repetitions s = Seq go
  where
    go _ =
      case runSeq s () of
        SeqValue# dur control value ->
          case control of
            SeqLoopEnd ->
              let
                currentRepetition ~ 0 = (currentRepetition + 1) % repetitions
              in
                if currentRepetition == 0 then
                  SeqValue# dur SeqLoopEnd value
                else
                  SeqValue# dur SeqNormal value
            _  -> SeqValue# dur control value


--------------------
-- Print
--------------------

instance Print Complex where
  print (Complex# r i) w =
    print '(' w
    |> print r
    |> print ' ' |> print '+' |> print ' ' |> print 'i' -- hack for array print dependency :(
    |> print i
    |> print ')'

instance Print a => Print (Array n a) where
  print a w =
    loop w' = w for i <- each do
      print (readArray i a) w'

instance Print Bool where
  print x w =
    case x of
      True -> print "True" w
      _    -> print "False" w

instance Print Rational where
  print (Rational# n d) w =
    print '(' w |> print n |> print " // " |> print d |> print ')'

instance Print a => Print (Maybe a) where
  print mx w =
    case mx of
      Nothing -> print '_' w
      Just x  -> print x w

instance Print a => Print (SeqValue a) where
  print (SeqValue# t _ v) w =
    print '(' w
    |> print t
    |> print ':'
    |> print v
    |> print ')'

printBarOnLoop :: SeqControl -> *World -> *World
printBarOnLoop c w =
  case c of
    SeqLoopEnd -> print '|' w |> print ' '
    _          -> w

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + audioBlockDelta
      (#_, _, wout#) =
        loop (#cont, time, w'#) = (#True, 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#False, 0, w'#)
            else
              case runSeq s () of
                SeqValue# t c mx ->
                  case mx of
                    Just x -> (#True, t, print x w' |> print ' ' |> printBarOnLoop c#)
                    _      -> (#True, t, printBarOnLoop c w'#)

instance Print Audio where
  print c w =
    case c of
      AudioEnd    -> print "AudioEnd" w
      BlockRate x -> print "BlockRate " w |> print x
      AudioRate b ->
        print '}' <| loop w' = (print '{' w) for i <- each do
          print (readArray i b) w' |> print ',' |> print ' '

instance Print a => Print (Mono a) where
  print (Mono c) w = print c w

instance Print a => Print (Stereo a) where
  print (Stereo# l r) w = print l (print ',' (print r w))

instance Print (FFT k) where
  print (FFT c) w =
    print "FFT [" w
    |> printNewline
    |> printNewline
    |> print c
    |> print ']'
    |> printNewline

-- foldp :: (b -> a -> b) -> f a -> b

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue# t _ (Just x) -> (#tick, time + t, f acc x#)
--             SeqValue# t _ _        -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- seqTest :: Seq Float
-- -- seqTest :: Seq Int
-- seqTest =
--   [0 _ 1 2] + [<3 4> _ <5 6> <7 8 9>]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- notAnInt :: Seq Float
-- notAnInt = 2 / 3

-- doubleTrouble :: SeqValue Int
-- doubleTrouble =
--   runSeq (2 * <33 44 <0 _ 1 2>>) ()

-- appendSeq :: Seq a -> Seq a -> Seq a
-- appendSeq x y = [x y]

-- appendGo :: SeqValue Rational
-- appendGo = runSeq (appendSeq 1 2) ()


----------------------
-- DynArray
----------------------
data PolyThunkState = PolyThunkAlloc | PolyThunkInit | PolyThunkEval
data PolyThunk a    = PolyThunk# (Ptr .()) (Ptr .()) a PolyThunkState Float
-- UpdateState, CopyState, Arg, ThunkState, SampleOffset

data DynTier      a = DynTier# UInt UInt UInt (Ptr (.PolyThunk a))
data DynArray     a = DynArray# (.DynTier a) (.DynTier a)
data DynTierIndex   = DynTierLow | DynTierHigh
data DynArrayIndex  = DynArrayIndex# DynTierIndex UInt

-- dynTierTrace :: *DynTier a -> *DynTier a
-- dynTierTrace (DynTier# cap count hwm ptr) =
--   DynTier# cap count hwm ptr
--   |> trace "    DynTier { cap: "
--   |> trace cap
--   |> trace ", count: "
--   |> trace count
--   |> trace ", hwm: "
--   |> trace hwm
--   |> traceLn " }"

-- dynArrayTrace :: Array n Char -> *DynArray a -> *DynArray a
-- dynArrayTrace opName (DynArray# low high) =
--   let low'  = dynTierTrace <| traceLn "  {" <| traceLn "  DynArray " <| traceLn opName low in
--   let high' = traceLn " " <| traceLn "  }" <| dynTierTrace high in
--   DynArray# low' high'

dynArrayIndexEmpty :: DynArrayIndex
dynArrayIndexEmpty = DynArrayIndex# DynTierLow 0

dynTierEmpty :: UInt -> *DynTier a
dynTierEmpty capacity =
  DynTier# capacity 0 0 (ptrMalloc capacity)

dynArrayEmpty :: UInt -> *DynArray a
dynArrayEmpty capacity =
  DynArray# (dynTierEmpty 0) (dynTierEmpty capacity)

dynTierSwapToEndAndDelete :: UInt -> *DynTier a -> *DynTier a
dynTierSwapToEndAndDelete index (DynTier# capacity count highWaterMark ptr) =
  if index >= capacity then
    DynTier# capacity count highWaterMark ptr
  else if index == (count - 1) then
    DynTier# capacity (count - 1) highWaterMark ptr
  else
    case unsafePtrSwapElement index primUndefined ptr of
      (#indexElement, ptr2#) ->
        case unsafePtrSwapElement (count - 1) indexElement ptr2 of
          (#endElement, ptr3#) ->
            DynTier# capacity (count - 1) highWaterMark (unsafePtrPoke index endElement ptr3)

-- NOTE: This assumes that the tier is correctly sized!
dynTierAppend :: *PolyThunk a -> *DynTier a -> *DynTier a
dynTierAppend element (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > count then
    case unsafePtrSwapElement count element ptr of
      (#hwmElement, ptr'#) ->
        DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr')
  else
    DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke count element ptr)

  -- |> trace "dynTierAppend, capacity: "
  -- |> trace capacity
  -- |> trace ", count: "
  -- |> traceLn count

data DynTierPromotePopResult a = DynTierPromotePopEmpty | DynTierPromotePopLive (.PolyThunk a) | DynTierPromotePopInactive (.PolyThunk a)
dynTierPromotePop :: *DynTier a -> (#*DynTierPromotePopResult a, *DynTier a#)
dynTierPromotePop (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > 0 && highWaterMark > count && highWaterMark <= capacity then
    case unsafePtrSwapElement (highWaterMark - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopInactive element, DynTier# capacity count (highWaterMark - 1) ptr'#)
  else if count > 0 && count <= capacity then
    case unsafePtrSwapElement (count - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopLive element, DynTier# capacity (count - 1) (count - 1) ptr'#)
  else
    (#DynTierPromotePopEmpty, DynTier# capacity count highWaterMark ptr#)

-- TODO: Nested case branching seems broken!?!?!?
dynArrayPromoteElement :: *DynArray a -> *DynArray a
dynArrayPromoteElement (DynArray# low (DynTier# capacity count highWaterMark ptr)) =
  case dynTierPromotePop low of
    (#m, low'#) ->
      case m of
        DynTierPromotePopEmpty ->
          DynArray# low' (DynTier# capacity count highWaterMark ptr)

        DynTierPromotePopInactive element ->
          DynArray# low' (DynTier# capacity count (highWaterMark + 1) (unsafePtrPoke highWaterMark element ptr))

        DynTierPromotePopLive element ->
          case unsafePtrSwapElement count element ptr of
            (#hwmElement, ptr'#) ->
              DynArray# low' (DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr'))

-- NOTE: This assumes that the low tier has been completely moved to the high tier
dynArrayResize :: *DynArray a -> *DynArray a
dynArrayResize (DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)) =
  if highCount < highCapacity && hhwm < highCapacity then
    DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)
  else
    let
      newCap  = highCapacity * 2
      newLow  = DynTier# highCapacity highCount hhwm highPtr
      newHigh = DynTier# newCap 0 0 (ptrRealloc newCap lowPtr)
    in
      DynArray# newLow newHigh

dynArrayAppend :: *PolyThunk a -> *DynArray a -> *DynArray a
dynArrayAppend element (DynArray# low high) =
  DynArray# low (dynTierAppend element high)

dynTierModifyElement :: UInt -> (*PolyThunk a -> *PolyThunk a) -> *DynTier a -> *DynTier a
dynTierModifyElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    DynTier# capacity count highWaterMark ptr0
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element, ptr1#) ->
        DynTier# capacity count highWaterMark (unsafePtrPoke index (f element) ptr1)

data DynArrayResult a = DynArrayEnd | DynArrayNothing | DynArrayJust a

dynTierWithElement :: UInt -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynTier a -> (#Maybe b, *DynTier a#)
dynTierWithElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    (#Nothing, DynTier# capacity count highWaterMark ptr0#)
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element0, ptr1#) ->
        case f element0 of
          (#result, element1#) ->
            (#Just result, DynTier# capacity count highWaterMark (unsafePtrPoke index element1 ptr1)#)

dynArrayWithElement :: DynArrayIndex -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArray a -> (#DynArrayResult b, *DynArray a#)
dynArrayWithElement (DynArrayIndex# tier index) f (DynArray# low high) =
  case tier of
    DynTierLow ->
      case dynTierWithElement index f low of
        (#result, low'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low' high#)
            _            -> (#DynArrayNothing, DynArray# low' high#)
    DynTierHigh ->
      case dynTierWithElement index f high of
        (#result, high'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low high'#)
            _            -> (#DynArrayEnd, DynArray# low high'#)

dynArrayDelete :: DynArrayIndex -> *DynArray a -> *DynArray a
dynArrayDelete (DynArrayIndex# tier index) (DynArray# low high) =
  case tier of
    DynTierLow  -> DynArray# (dynTierSwapToEndAndDelete index low) high
    DynTierHigh -> DynArray# low (dynTierSwapToEndAndDelete index high)

dynArrayEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArray a -> *DynArray a
dynArrayEmplaceOrAppend emplaceInit appendMk (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr)) =
  if highCount < highWaterMark then
    DynArray# low (dynTierModifyElement highCount emplaceInit <| DynTier# highCapacity (highCount + 1) highWaterMark highPtr)
  else
    dynArrayAppend (appendMk ()) (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr))

data DynArrayIterator a = DynArrayIterator# DynArrayIndex (.DynArray a)

dynArrayIterator :: *DynArray a -> *DynArrayIterator a
dynArrayIterator x = DynArrayIterator# dynArrayIndexEmpty x

dynArrayIteratorEnd :: *DynArrayIterator a -> *DynArray a
dynArrayIteratorEnd (DynArrayIterator# _ array) = array

dynArrayIteratorEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorEmplaceOrAppend emplaceInit appendMk (DynArrayIterator# _ array) =
  DynArrayIterator# dynArrayIndexEmpty <| dynArrayEmplaceOrAppend emplaceInit appendMk <| dynArrayResize <| dynArrayPromoteElement array

dynArrayIteratorWithElement :: (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArrayIterator a -> (#DynArrayResult b, *DynArrayIterator a#)
dynArrayIteratorWithElement f (DynArrayIterator# index array) =
  case dynArrayWithElement index f array of
    (#result, array'#) ->
      (#result, DynArrayIterator# index array'#)

dynArrayIteratorNext :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorNext (DynArrayIterator# (DynArrayIndex# tier index) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))) =
  case tier of
    DynTierLow ->
      if index < lcount then
        DynArrayIterator# (DynArrayIndex# DynTierLow (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
      else
        DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
    DynTierHigh ->
      DynArrayIterator# (DynArrayIndex# DynTierHigh (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))

dynArrayIteratorFree :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorFree (DynArrayIterator# index array) =
  case dynArrayDelete index array of
    DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr) ->
      case index of
        DynArrayIndex# tier _ ->
          case tier of
            DynTierLow ->
              if lcount > 0 then
                DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
              else
                DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
            DynTierHigh ->
              DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))


--------------------
-- PolyThunks
--------------------
-- NOTE on Propagation:
--    * All Type variables are propagating
--    * In data constructors type variables are always polymorphic in uniqueness
--    * In data constructors monomorphic types default to shared uniqueness
--    * Uniqueness notation is allowed in data constructors only on monomorphic type cons
--    * Higher Kinded Types do not have uniqueness types and do not propagate uniqueness, instead Type Applications have uniqueness types associated with them and are propagating!
--    * Propagation behavior is enforced by the type of the data constructor function!
dynDeepCopy :: a -> (#Ptr *(), a#)
dynDeepCopy x =
  primUndefined

dynDeepCopyInto :: Ptr *() -> a -> (#Ptr *(), a#)
dynDeepCopyInto copyState x =
  primUndefined

polyThunkAlloc :: a -> Float -> () -> *PolyThunk a
polyThunkAlloc x sampleOffset u =
  case dynDeepCopy x of
    (#copyState, x'#) ->
      PolyThunk# primUndefined copyState x' PolyThunkAlloc sampleOffset

polyThunkInit :: a -> Float -> *PolyThunk a -> *PolyThunk a
polyThunkInit x sampleOffset (PolyThunk# updateState copyState _ _ _)  =
  case dynDeepCopyInto copyState x of
    (#copyState', x'#) ->
      PolyThunk# updateState copyState' x' PolyThunkInit sampleOffset

-- compiler magic prevents this from inlining, which is required for poly to function properly
polyThunkEvalGo :: (a -> b) -> a -> b
polyThunkEvalGo f x = f x

polyThunkEval :: (a -> b) -> *PolyThunk a -> (#b, *PolyThunk a#)
polyThunkEval f t =
  let
    dummy = polyThunkEvalGo f primUndefined
  in
    primUndefined


----------------------
-- Poly
----------------------
class Finite a where
  isRunning :: a -> Bool

class (Monoid p, Finite p) => Poly p where

instance Finite Audio where
  isRunning c =
    case c of
      AudioEnd -> False
      _        -> True

instance Finite a => Finite (Mono a) where
  isRunning (Mono x) = isRunning x

instance Finite a => Finite (Stereo a) where
  isRunning (Stereo# l r) = isRunning l && isRunning r

instance Poly Audio where
instance Poly (Mono a) where
instance Poly a => Poly (Stereo a) where

calculateAudioSampleOffset :: Rational -> Rational -> Float
calculateAudioSampleOffset valueTime tickTime =
  (fromInt n / fromInt d) * fromUInt audioBlockSize
  where
    Rational# n d =
      (valueTime - (tickTime - audioBlockDelta)) / audioBlockDelta

seqToAudio :: (AudioFormat f) => Seq Float -> f Audio
seqToAudio s =
  pure (AudioRate (freezeArray aout))
  where
    (#_, aout#) =
      loop (#i0, a#) = (#audioSampleOffset, audioInitArray ()#) while i0 < audioBlockSize do
        let
          i1        = i0 + 1
          time ~ 0  = time + audioSampleDelta
          value ~ 0 =
            thd3' <| loop (#cont, seqDuration0, prevValue#) = (#True, 0, value#) while cont do
              let
                nextValueTime ~ 0 = nextValueTime + seqDuration0
              in
                if nextValueTime >= time then (#False, 0, prevValue#) else
                  case runSeq s () of
                    SeqValue# seqDuration1 _ msv ->
                      case msv of
                        Just seqValue -> (#True, seqDuration1, seqValue#)
                        Nothing       -> (#True, seqDuration1, prevValue#)
        in
          (#i1, writeArray (Index i0) (fromFloat value) a#)

poly :: Poly b => (a -> b) -> Seq a -> b
poly f s =
  case mutRefTake (\_ -> dynArrayEmpty 8) of
    (#thunks0, mref#) ->
      let
        tick ~ 0                = tick + audioBlockDelta
        (#_, _, acc', thunks4#) =
          loop (#cont, time, acc, thunks1#) = (#True, 0, mempty, dynArrayIterator thunks0#) while cont do
            let nextValueTime ~ 0 = nextValueTime + time in
              if nextValueTime < tick then
                case runSeq s () of
                  SeqValue# t _ mx ->
                    case mx of
                      Just x  -> (#True, t, acc, dynArrayIteratorEmplaceOrAppend (polyThunkInit x (calculateAudioSampleOffset nextValueTime tick)) (polyThunkAlloc x (calculateAudioSampleOffset nextValueTime tick)) thunks1#)
                      Nothing -> (#True, t, acc, thunks1#)
              else
                case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                  (#maybeEvalResult, thunks2#) ->
                    case maybeEvalResult of
                      DynArrayJust evalResult ->
                        if isRunning evalResult then
                          (#True, 0, append acc evalResult, dynArrayIteratorNext thunks2#)
                        else
                          (#True, 0, acc, dynArrayIteratorFree thunks2#)
                      DynArrayNothing -> (#True,  0, acc, dynArrayIteratorNext thunks2#)
                      DynArrayEnd     -> (#False, 0, acc, thunks2#)
      in
        case mutRefPut (dynArrayIteratorEnd thunks4) mref of
          _ -> acc'

poly2 :: Poly c => (a -> b -> c) -> Seq a -> Seq b -> c
poly2 f x y = poly (uncurry' f) (map2 (\x' y' -> (#x', y'#)) x y)

poly3 :: Poly d => (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> d
poly3 f x y z = poly (uncurry3' f) (map3 (\x' y' z' -> (#x', y', z'#)) x y z)

-- testJit :: *World -> *World
-- testJit w = w

-- somePow :: F64
-- somePow = pow pi 5

-- testJit :: *World -> *World
-- testJit w =
--     print "halfPi: " w
--     |> printLn halfPi
--     |> print "floor halfPi: "
--     |> printLn (floor halfPi)
--     |> print "floor -halfPi: "
--     |> printLn (floor <| negate halfPi)
--     |> print "ceil halfPi: "
--     |> printLn (ceil halfPi)
--     |> print "ceil -halfPi: "
--     |> printLn (ceil <| negate halfPi)
--     |> print "truncate halfPi: "
--     |> printLn (truncate halfPi)
--     |> print "truncate -halfPi: "
--     |> printLn (truncate <| negate halfPi)
--     |> print "round halfPi: "
--     |> printLn (round halfPi)
--     |> print "round -halfPi: "
--     |> printLn (round <| negate halfPi)
--     |> print "copysign 666 halfPi: "
--     |> printLn (copysign 666 halfPi)
--     |> print "copysign 666 -halfPi: "
--     |> printLn (copysign 666 <| negate halfPi)
--     |> print "signum halfPi: "
--     |> printLn (signum halfPi)
--     |> print "signum -halfPi: "
--     |> printLn (signum <| negate halfPi)
--     |> print "floorToInt halfPi: "
--     |> printLn (floorToInt halfPi)
--     |> print "floorToInt -halfPi: "
--     |> printLn (floorToInt <| negate halfPi)
--     |> print "ceilToInt halfPi: "
--     |> printLn (ceilToInt halfPi)
--     |> print "ceilToInt -halfPi: "
--     |> printLn (ceilToInt <| negate halfPi)
--     |> print "truncateToInt halfPi: "
--     |> printLn (truncateToInt halfPi)
--     |> print "truncateToInt -halfPi: "
--     |> printLn (truncateToInt <| negate halfPi)
--     |> print "roundToInt halfPi: "
--     |> printLn (roundToInt halfPi)
--     |> print "roundToInt -halfPi: "
--     |> printLn (roundToInt <| negate halfPi)

-- copysign :: F64 -> F64 -> F64
-- fmin :: F64 -> F64 -> F64
-- fmax :: F64 -> F64 -> F64
-- floorToInt :: F64 -> Int
-- ceilToInt :: F64 -> Int
-- truncateToInt :: F64 -> Int
-- roundToInt :: F64 -> Int

-- testJit :: *World -> *World
-- testJit w = printLn "IEEE format=========================================" w
--           |> print "iEEESignMask"
-- 		  |> print " -> "
--           |> printLn iEEESignMask
--           |> print "iEEESignMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignMaskF
--           |> print "iEEEExponentMask"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMask
--           |> print "iEEEExponentMaskF"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMaskF
--           |> print "iEEESignificandMask"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMask
--           |> print "iEEESignificandMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMaskF
--           |> print "all bits"
-- 		  |> print " -> "
--           |> printLn allBits
--           |> print "all bits F"
-- 		  |> print " -> "
--           |> printLn allBitsF
--     where
--       allBits :: UInt
--       allBits = -1
--       allBitsF :: Float
--       allBitsF = fromBits allBits

----------------------
-- Oscillator tests
----------------------

oscTest :: (Mono Audio -> Mono Audio) -> Stereo Audio
oscTest f =
  perc 10 1 3 6000 + 50
  |> f
  |> perc 5 5 -1
  |> mul 0.2
  |> mixStereo

-- -- Arrays of Audio seems broken at the moment :\
-- oscTestMany :: (Mono Audio -> Mono Audio) -> Stereo Audio
-- oscTestMany f =
--   s
--   |> mul 0.01
--   |> perc 5 5 -1
--   |> mul 0.1
--   |> mixStereo
--   where
--     freq = perc 10 1 3 6000 + 50
--     r :: Range 100
--     r = each
--     s     =
--       loop o = 0 for i <- r do
--         f freq + o

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest sin) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest tri) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (lfPulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (pulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       pulse ((sin 0.2 * 0.4) + 0.5) 440
--       |> perc 5 5 -1
--       |> mul 0.1
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest lfSaw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest saw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTestMany saw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lpf (perc 10 1 4 5000 + 330) 0.075
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> hpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf 2000 (abs (sin 0.5 * 3) + 0.01)
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lowShelf (5110 - perc 10 1 -4 5000) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> highShelf (perc 10 1 -4 5000 + 220) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       perc 10 1 3 6000 + 50
--       |> lfSaw
--       |> highShelf 20000 -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superSaw 440 0.1 0.7
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superPulse 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superTri 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 200 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.125 * 0.125)
--     osc  =
--       syncTri sync 200
--       |> perc 5 15 0.1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.25 * 0.125)
--     osc  =
--       syncPulse 0.66667 sync 100
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       hardSyncPulse sync 0.5 100
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 240 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.2 * 0.35)
--     osc  =
--       syncSaw sync 0.495 80
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync =
--       ([1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 400)
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lag 0.085
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       perc 10 1 3 4000 + 50
--       |> hardSyncSaw sync
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync =
--       ([1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 50)
--       |> seqSpeed 6
--       |> seqToAudio
--       |> lag 0.085
--       |> lfPulse (0.5 + (sin 0.25 * 0.125))
--     osc  =
--       perc 10 1 3 4000 + 5
--       |> hardSyncPulse sync 0.5
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     ikedaSize :: NatVal2 2 25
--     ikedaSize = NatVal2
--     ikedaFn (Vector2D# x y) s = (#s + ((abs x + abs y) * recipSampleRate * 0.05), 0.25 * (sine s + sine x + sine ((y * 2) + (sine (x * 0.0001) * 5)))#)
--     a =
--       ikedaAttractor ikedaSize ikedaFn 0.99925 (stereo 120 80)
--       |> perc 10 20 -1
--       |> mul 0.5

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal2 4 4
--     size = NatVal2
--     ifn i (Vector2D# x y)   = (#Vector2D# (x * 0.1) (y * 0.1), fromUInt i#)
--     mfn i (Vector2D# x y) s = (#s, 0.25 * (sine (x * 0.1) + sine ((y * 0.2) + (sine (x * 0.0001) * 5)))#)
--     a =
--       ikedaAttractor size ifn mfn 0.1 (stereo 5 10)
--       |> perc 10 20 -1
--       |> mul 0.4

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal2 8 8
--     size = NatVal2
--     ifn i (Vector2D# x y)   = (#Vector2D# (x * 1) (y * 1), fromUInt i#)
--     mfn i (Vector2D# x y) s = (#s, sine (((x + ((s * 10)) + 1) * 200) + (sine (y * 0.4) * -200)) + sine ((y * 200) + (sine (x * 0.4) * 200))#)
--     a =
--       duffingAttractor size ifn mfn 0.27 0.3 1 (stereo 10 20)
--       |> perc 10 20 -1
--       |> mul 0.5

    -- mfn i (Vector3D# x y z) s = (#s, sine (x * 400) + sine (y * 400) + sine (z * 400)#)

-- -- TODO: Use dot product vs forward/up vector for oscillator frequency
-- -- Doom Bubbles
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 5 5 5
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# (x * 0.1) (y * 0.1) (z * 0.1), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s + ((magnitude3D (Vector3D# x y z)) * 30 * recipSampleRate), ((sine s + sine (s * 0.5)) * 0.5) + (sine (x * 4.00) * 0.5) + sine (z * 1)#)
--     a =
--       lorenzAttractor size ifn mfn 10 38 (8/3) (perc 15 15 1 11 + stereo 6 6.01)
--       |> lpf (perc 20 10 1 4000 + 50) 0.5
--       |> delay twoSec (stereo 1 2) 0.3
--       |> perc 10 20 -1
--       |> mul 0.15

data Scale (t :: Nat) (d :: Nat) = Scale (Array t Rational) (Array d UInt) Float

-- equalTuning :: A.Array Int Rational
-- equalTuning =

-- equalTuning :: Array 12 Rational
-- equalTuning =
--   { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
--   |> map (\x -> pow 2 (x / 12))

-- arrayFromList $ map (\x -> toRational $ 2 ** (x / 12)) [0.0..11.0 :: Double]

justTuning :: Array 12 Rational
justTuning =
  {1, 16//15, 9//8, 6//5, 5//4, 4//3, 45//32, 3//2, 8//5, 5//3, 9//5, 15//8}

partch43Tuning :: Array 43 Rational
partch43Tuning =
  {
    1, 81//80, 33/32, 21//20, 16//15, 12//11, 11//10, 10//9, 9//8, 8//7,
    7//6, 32//27, 6//5, 11//9, 5//4, 14//11, 9//7, 21//16, 4//3, 27//20,
    11//8, 7//5, 10//7, 16//11, 40//27, 3//2, 32//21, 14//9, 11//7, 8//5,
    18//11, 5//3, 27//16, 12//7, 7//4, 16//9, 9//5, 20//11, 11//6, 15//8,
    40//21, 64//33, 160//81
  }

egyptianTuning :: Array 12 Rational
egyptianTuning =
  {1//2, 107//96, 9//8, 11//9, 59//48, 4//3, 1//1, 3//2, 5//3, 121//72, 11//6, 133//72}

justMajor :: Scale 12 7
justMajor =
  Scale justTuning {0, 2, 4, 5, 7, 9, 11} 261.6255653006

justChromatic :: Scale 12 12
justChromatic =
  -- Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 150
  Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 200
  -- Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 200

-- justChromaticTest :: Scale 12 12
-- justChromaticTest =
--   Scale justTuning {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11} 266.668

coleJI :: Scale 12 12
coleJI =
  Scale {1,10//9,9//8,8//7,6//5,4//3,11//8,3//2,8//5,7//4,16//9,9//5} {0,1,2,3,4,5,6,7,8,9,10,11} 261.6255653006

partch43 :: Scale 43 43
partch43 =
  -- Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 250
  Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 300
  -- Scale partch43Tuning {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42} 261.6255653006

degreeToFrequency :: Scale t d -> Int -> Float
degreeToFrequency (Scale tuning degrees rootFreq) degree =
  pitch * octave * rootFreq
  where
    numDegrees = arrayLength NatVal degrees |> fromUInt
    octave     = fromInt (max (div degree numDegrees) 0) |> pow 2.0
    degree'    = lookupArray (fromInt (rem degree numDegrees)) degrees |> fromMaybe 0
    pitch      = lookupArray degree' tuning |> fromMaybe 0 |> rationalToFloat

d2f :: Scale t d -> Int -> Float
d2f = degreeToFrequency

testJit :: *World -> *World
testJit w = plotFFTOnce "fftOut.dat" fftOut w
  where
    fftOut :: Mono (FFT 1)
    fftOut = fft p
    p =
      pluck natEight 50 1.0 +
      pluck natFour 100 1.0

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 p w
--   where
--     p =
--       pluck natEight 50 1.0 +
--       pluck natFour 100 1.0
--       |> pan 0.5
--       |> mul 0.1

-- -- Look into alternative to euler method...
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 4 4 4
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# (x * 0.1) (y * 0.3) (z * -0.6), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s, sine (x * 200)#)
--     a =
--       luChenAttractor size ifn mfn 36 3 20 -15.5 1
--       |> perc 10 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     size :: NatVal3 1 1 1
--     size = NatVal3
--     ifn i (Vector3D# x y z)   = (#Vector3D# -1 0 0.5 + Vector3D# (x * 0.05) (y * 0.05) (z * 0.05), fromUInt i#)
--     mfn i (Vector3D# x y z) s = (#s, sine ((x * 4000) + sine (y * 4000) + sine (z * 4000))#)
--     a =
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.5 0.75) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.6 0.7) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.4 0.8) +
--       rabinovichFabrikantAttractor size ifn mfn 1.1 0.87 (stereo 0.3 0.85)
--       |> delay oneSec 0.125 0.25
--       |> perc 10 20 -1
--       |> mul 0.05

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.125 * 0.125)
--     osc  =
--       syncSin sync 200
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       let feed ~ 0 = syncTri feed (stereo 660 500 + sin 2.0 * 50 + sin 0.1 * -50 + (delay oneSec 0.25 0.4 <| feed * -60)) in
--       feed
--       |> delay oneSec 0.25 0.2
--       |> perc 5 20 -1
--       |> mul 0.5

-- -- TODO: Perhaps upsample freq argument to saw and pulse?
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (10 + perc 5 20 -1 200) * perc 5 20 -1 4000)
--       |> sin
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (10 + perc 5 20 -1 200) * perc 5 20 -1 2000)
--       |> tri
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (1 + perc 5 20 -1 30) * perc 5 20 -1 4000)
--       |> pulse 0.5
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (1 + perc 5 20 -1 30) * perc 5 20 -1 4000)
--       |> saw
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     freqMul1  = sin 0.2  *  0.0035 + sin 0.6 *  0.00025 + 0.5
--     freqMul2  = sin 0.14 *  0.0035 + sin 0.5 * -0.00025 + 0.5
--     freqMul3  = sin 0.23 * -0.0035 + sin 0.4 *  0.00025 + 0.5
--     beatSpeed = 3 // 2
--     badBeat1  = seqSpeed beatSpeed [200 _ 300 <_ 350> 200 400 _ 600 <_ [350:700]> [300:800]]
--     badBeat2  = seqSpeed beatSpeed ([400 _ 600 <_ 700> <_ 1200> [1400:1350]] @* (seqSpeed (1 // 9) [_ _ _ _ 0.25 0.5 0.75 1 1.5]))
--     badBeat3  = seqSpeed (beatSpeed / 8) [100 60 75 100 60 75 80]
--     badSynth1 f =
--       tri (fromFloat f * 0.501) + tri (fromFloat f * freqMul1 + tri 1.33334 * 3) + (sin (fromFloat f) * 0.75)
--       |> mul 0.11
--       |> perc 0.005 2.5 -3.75
--       |> pan 0.375
--     badSynth2 f =
--       tri (fromFloat f * freqMul3 * 2.02) + tri (fromFloat f * 0.998) + (pulse (freqMul1 - 0.175) (fromFloat f * freqMul2 + tri 2.0 * 3) * 0.3)
--       |> mul 0.09
--       |> perc 0.01 3.5 -2.75
--       |> pan 0.625
--     bassSynth f =
--       sin (fromFloat (f * 0.5)) + (0.5 * (tri (fromFloat f - 0.1) + tri (fromFloat f * freqMul1 * 2) + tri (fromFloat f * (1 - freqMul3)) + tri (fromFloat (f * 0.5))))
--       |> mul 0.1
--       |> perc 0.005 5 -1.8
--       |> mixStereo
--     synths =
--       poly badSynth1 badBeat1 +
--       poly badSynth2 badBeat2
--       |> delay oneSec 0.6666667 0.6
--     badAudio =
--       poly bassSynth badBeat3 +
--       synths

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
-- 		  |> printLn (bitNot one |> bitAnd (fromBits negativeBit |> bitNot))
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> bitAnd (bitNot negativeBit |> fromBits)
--     -- unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print negativeBit
--           |> print " -> "
--           |> print negativeOne
--           |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits
--

-- bitOneOne = bitAnd (bitXor (-1) negativeBit) bitOne |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w |> print " -> " |> print bitOne |> print " -> " |> print bitOneOne |> printLn " "
--   where
--     one :: Float
--     one = 1
--     -- negativeBit :: UInt
--     -- negativeBit = bitShiftRight 1 63
--     bitOne = bitShiftLeft one 2
--     bitOneOne = bitShiftRight bitOne 2
--
-- testJit :: *World -> *World
-- testJit w = print f64 w |> print " -> " |> print rF64 |> print " -> " |> print rrF64 |> printLn " "
--   where
--     f64 :: Float
--     f64 = pi
--     rF64 = bitReverse f64
--     rrF64 = bitReverse rF64
--

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     s = seqToAudio <| seqSpeed 4 [3 1 2 <4 3>]
--     t = seqToAudio <| seqSpeed 2 [0.5 1 2 <4 3>]
--     a =
--       pulse 0.125 (440 * stereo s t)
--       |> mul 0.125
--       |> pan 0.5

-- testJit :: *World -> *World
-- testJit w = printLn f64 w |> printLn (bitReverse f64) |> printLn (bitReverse <| bitReverse f64)
--   where
--     f64 :: F64
--     f64 = 5


-----------------------------------------
-- Trig and Complex numbers testing

printArraySpaced :: Print a => Array n a -> *World -> *World
printArraySpaced a w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    printLoop lw = loop w' = lw for i <- each do
      (print (readArray i a) w' |> printNewline)

printTupleArraySpaced :: (Print a, Print b) => Array n (a, b) -> *World -> *World
printTupleArraySpaced a w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    printLoop lw = loop w' = lw for i <- each do
      (printTuple (readArray i a) w' |> printNewline)

mathTestFloat :: (Float -> Float) -> *World -> *World
mathTestFloat f w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    i2Fs i = (i', f i')
      where
        i' = (fromUInt i - 32) / 32
    a :: Array 64 (Float, Float)
    a = mkArray i2Fs
    printLoop lw =
      loop w' = lw for i <- each do
        (printTuple (readArray i a) w' |> printNewline)

mathTest2D :: (Float -> Float -> Float) -> *World -> *World
mathTest2D f w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    a :: Array 8 Float
    a = mkArray (\i -> (fromUInt i - 4) / 4)
    printLoop lw =
      loop w' = lw for i <- each do
        loop w'' = w' for j <- each do
          let
            fa = readArray i a
            fb = readArray j a
          in
            printTuple (fa, fb) w''
            |> print ' '
            |> print (f fa fb)
            |> printNewline

testComplexArray :: Array 64 Complex
testComplexArray = c
  where
    a :: Array 64 (UInt, Float)
    a = mkArray (\i -> (i, (fromUInt i - 32) / 32))
    c :: Array 64 Complex
    c = map (\(u, f) -> Complex# f (rem (f + fromUInt (u * 2)) 1.0)) a

testComplexTupleArray :: Array 64 (Complex, Complex)
testComplexTupleArray = c
  where
    a :: Array 64 (UInt, Float)
    a = mkArray (\i -> (i, (fromUInt i - 32) / 32))
    ufToComplex u f = Complex# f (rem (f + fromUInt (u * 2)) 1.0)
    c :: Array 64 (Complex, Complex)
    c = map (\(u, f) -> (ufToComplex u f, ufToComplex (64 - u) (1 - f))) a

complexCisTest :: *World -> *World
complexCisTest w = print "[" w |> printNewline |> printLoop |> printChar ']' |> printNewline
  where
    a :: Array 64 Float
    a = mkArray (\i -> ((fromUInt i - 32) / 32))
    printLoop lw =
      loop w' = lw for i <- each do
        ((print (readArray i a) w') |> printChar ' ' |> (print (cis (readArray i a))) |> printNewline)

complexToPrintableTest :: Print a => (Complex -> a) -> *World -> *World
complexToPrintableTest f w = printArraySpaced (map f testComplexArray) w

complexByComplexTest :: (Complex -> Complex -> Complex) -> *World -> *World
complexByComplexTest f w = printArraySpaced (map complexByComplex testComplexTupleArray) w
  where
    complexByComplex :: (Complex, Complex) -> Complex
    complexByComplex t = case t of
      (a, b) -> f a b

-- Chad Test!
-- testJit :: *World -> *World
-- testJit w =
-- 	print "fmouse: " w
--     |> printLn fMouse
--     |> print "tan: "
--     |> mathTestFloat tanF64
--     |> print "atan: "
--     |> mathTestFloat atanF64
--     |> print "atan2: "
--     |> mathTest2D atan2
--     |> print "sineh: "
--     |> mathTestFloat sineh
--     |> print "cosineh: "
--     |> mathTestFloat cosineh
--     |> print "testComplexArray: "
--     |> print testComplexArray |> printNewline
--     |> print "cis<complex>: "
--     |> complexCisTest
--     |> print "polar<complex>: "
--     |> printTupleArraySpaced (map polar testComplexArray)
--     |> print "sqrMagnitude<complex>: "
--     |> complexToPrintableTest sqrMagnitude
--     |> print "magnitude<complex>: "
--     |> complexToPrintableTest magnitude
--     |> print "conjugate<complex>: "
--     |> complexToPrintableTest conjugate
--     |> print "phase<complex>: "
--     |> complexToPrintableTest phase
--     |> print "sine<complex>: "
--     |> complexToPrintableTest sine
--     |> print "cosine<complex>: "
--     |> complexToPrintableTest cosine
--     |> print "sineh<complex>: "
--     |> complexToPrintableTest sineh
--     |> print "cosineh<complex>: "
--     |> complexToPrintableTest cosineh
--     |> print "exp<complex>: "
--     |> complexToPrintableTest exp
--     |> print "exp2<complex>: "
--     |> complexToPrintableTest exp2
--     |> print "log<complex>: "
--     |> complexToPrintableTest log
--     |> print "log2<complex>: "
--     |> complexToPrintableTest log2
--     |> print "log10<complex>: "
--     |> complexToPrintableTest log10
--     |> print "sqrt<complex>: "
--     |> complexToPrintableTest sqrt
--     |> print "testComplexTupleArray"
--     |> printTupleArraySpaced testComplexTupleArray |> printNewline
--     |> print "pow<complex>: "
--     |> complexByComplexTest pow
--     |> print "atan2<complex>: "
--     |> complexByComplexTest atan2
--     |> testAssertion True
--   where
--     fMouse = fromInt mouseX

-- testJit :: *World -> *World
-- testJit w =
-- 	print "fmouse: " w
--     |> printLn fMouse
--     |> print "tan -1.8125: "
--     |> printLn (tanF64 -1.8125)
--     |> print "tanF64: "
--     |> printLn (tanF64 fMouse)
--     |> print "atanF64: "
--     |> printLn (atanF64 fMouse)
--     |> print "slowAtanF64: "
--     |> printLn (slowAtanF64 fMouse)
--     |> print "atanF64 -1.8125: "
--     |> printLn (atanF64 -1.8125)
--     |> print "slowAtanF64 -1.8125 "
--     |> printLn (slowAtanF64 -1.8125)
--     |> print "tan -17000: "
--     |> printLn (tanF64 -17000)
--     |> print "sinh -0.0000266618125: "
--     |> printLn (sineh -0.0000266618125)
--     |> print "sinh -0.0266618125: "
--     |> printLn (sineh -0.0266618125)
--     |> print "sinh -0.166618125: "
--     |> printLn (sineh -0.166618125)
--     |> print "sinh -1.133718125: "
--     |> printLn (sineh -1.133718125)
--     |> print "sinh -3.1133718125: "
--     |> printLn (sineh -3.1133718125)
--     |> print "sinh -7: "
--     |> printLn (sineh -7)
--     |> print "sinh -13.9133718125: "
--     |> printLn (sineh -13.9133718125)
--     |> print "sineh: "
--     |> printLn (sineh fMouse)
--     |> print "cosh -0.0266618125: "
--     |> printLn (cosineh -0.0266618125)
--     |> print "cosh -0.166618125: "
--     |> printLn (cosineh -0.166618125)
--     |> print "cosh -1.133718125: "
--     |> printLn (cosineh -1.133718125)
--     |> print "cosh -3.1133718125: "
--     |> printLn (cosineh -3.1133718125)
--     |> print "cosh -7: "
--     |> printLn (cosineh -7)
--     |> print "cosh -13.9133718125: "
--     |> printLn (cosineh -13.9133718125)
--     |> print "cosineh: "
--     |> printLn (cosineh fMouse)
--     |> print "exp (2 + 3i): "
--     |> printLn (exp (Complex# 2 3))
--     |> print "exp2 (2 + 3i): "
--     |> printLn (exp2 (Complex# 2 3))
--     |> print "log (2 + 3i): "
--     |> printLn (log (Complex# 2 3))
--     |> print "log2 (2 + 3i): "
--     |> printLn (log2 (Complex# 2 3))
--     |> print "log10 (2 + 3i): "
--     |> printLn (log10 (Complex# 2 3))
--   where
--     fMouse = fromInt mouseX

--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# 8 2
--     b = Complex# 2 1
--     c = sqrt (Complex# (negate 3.4) pi)
--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# (negate pi) 3
--     b = Complex# 3 4
--     c = a / b


-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- proceduralBeat :: Seq Float
-- proceduralBeat = Seq <| \_ ->
--   let
--     tick ~ 0 = tick + 1
--     value    = tick * 100 + fromInt mouseY * fromInt mouseX
--   in
--     SeqValue# 2 SeqNormal (Just value)

-- seqTest :: Seq Float
-- seqTest =
--   [x 100 200 <300 x> [400:500]]
--   where
--     x = <30 40 <50 60 70> 80> + 3

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX * 100

-- TODO: Nat valued constants where the number is applied as a Nat kind
--       to a Type Constructor with a single Unit data constructor, such as NatlVal or Seconds,
--       i.e.:
--          1! :: NatVal 1
--          2! :: Seconds 2
--          3! :: NatVal 3
--          etc
-- TODO: Had to remove HOF caching because the current one over shared causing very bad issues. Find a correct fix
-- TODO: Simultaneous synths panned in the middle cause weird FM?!?!!?!?
-- TODO: Test arg copying

-- TODO: Softsync Oscillators
-- TODO: optimize perc?
-- TODO: Waveterrain oscillators? Table based? Function Based? Both? Trajectory combinators, etc
-- TODO: Sphereterrain oscillators? Table based? Function Base? Both?
-- TODO: Cepstrum analysis / signal processing?
-- TODO: Loading Audio Files
-- TODO: Comb Filters, All Pass Filters, etc
-- TODO: mandelbulb + strange attractors + delauney triangulation
-- TODO: phase distortion synthesis
-- TODO: Looks like maybe the precedence between (+) and (*) and (|>) is a little wonky?
-- TODO: Multiplication precedence is WRONG!!!!
-- TODO: Generic env
-- TODO: Clipping detection
-- TODO: Set audioSampleOffset to NOT be constant and insure that it is never used at a global scope!!!!! (It is magical...)
-- TODO: repeat combinator
-- TODO: Nested case literals seem broken!
-- TODO: Out of order monomorphic instances (i.e. 'instance Ring Complex' textually appearing before 'instance Ring F64') can cause erroneous 'Not An Instance' errors. Maybe need a better dep analysis story to make this work since we don't figure this out until inference which is at that point too late to fix.
-- TODO: Write to log file, perhaps class Log a similar to class Print a
-- TODO: Look at all the .i.i.i weirdness in llvm names???

-- TODO: Optimize const expr globals
-- TODO: Memory access test audio stuff!
-- TODO: type sig coerce constraint!
-- TODO: Put constant check on initializers, not in type signatures. It doesn't need to be in the type system to be checked! Then we can nix Default for Monoid?
-- TODO: Compiler breaks down when a Non-Type kinded type is used in a class declaration!
-- TODO: Immutable and Mutable (Unique) FFT API

-- TODO: Concept of Constant Values somehow being worked into the type system for things like default and mutRef
-- TODO: Inline compose operators! .> and <.
-- TODO: Perhaps function caching is getting off, need more accurate check for HOF caching!
-- TODO: Replace Default with Monoid?
-- TODO: Need partial recursive values to get rid of monoid here
-- TODO: Partially recursive values
-- TODO: Use List type syntax for Sequences?
-- TODO: Partially recursive values
-- TODO: Defunctionalization of function on data structures
-- TODO: Stateful Pattern assignment

-- Sound ideas
--     * Percussive simulations
--     * Strange attractors in FFT?
--     * Cool FFT effects we used: Convolution with voices, Long time stretching

