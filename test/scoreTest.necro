
----------------------
-- Score API usage example
----------------------

-- TODO: monadic control flow (case, if/then/else)
-- TODO: Actually synchronizing using Score
-- TODO: Actually using Score sections without fuckin' crashing
-- TODO: Lambda lift compiler bug on scoreSection (fml)
-- TODO: Score determined Quantization?
-- TODO: End?
-- TODO: scoreSection >>= \s ->

----------------------
-- No Score
----------------------

-- data NoScore = NoScore
-- instance ScoreType NoScore where
--   score = scoreNew {Section HoldForever A (Tempo 12)}

----------------------
-- Simple Score
----------------------

data SimpleScore = SimpleScore Alphabet

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Eq SimpleScore where
  eq  (SimpleScore xSection) (SimpleScore ySection) = xSection == ySection
  neq (SimpleScore xSection) (SimpleScore ySection) = xSection /= ySection

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Default SimpleScore where
  default = SimpleScore A

instance ScoreType SimpleScore where
  score =
    {
      Section (Beats 999) (SimpleScore A) (Tempo 103),
      -- Section (Beats 12) (SimpleScore B) (Tempo  90),
      -- Section (Beats  4) (SimpleScore D) (Tempo 135),
      -- Section (Beats 12) (SimpleScore A) (Tempo 135),
      -- Section (Beats 12) (SimpleScore C) (Tempo  90),
    }
    |> scoreNew
    -- |> scoreNewWith 1

simpleScore :: Score SimpleScore
simpleScore =
  score

simpleScoreSection :: Seq SimpleScore
simpleScoreSection =
  Seq (\p -> pure (scoreSectionWithOffset score (seqParamGetTimeOffset p)))

simpleScoreSeq :: Seq Float
simpleScoreSeq =
  simpleScoreSection >>= \s ->
  case s of
    SimpleScore A -> [1 2 [3:3.25] 5]
    SimpleScore B -> [6 3 2 [0.5:1:1.5]]
    SimpleScore C -> [4 2 [1:1.5] 2]
    _             -> [7 0.5]

simpleScoreSeq2 :: Seq Float
simpleScoreSeq2 =
  simpleScoreSection >>= \s ->
  case s of
    SimpleScore A -> [<1 2 3> 5]
    _             -> [7 _ 0.5]

simpleSynth1 :: Float -> Stereo Audio
simpleSynth1 f =
  sin (fromFloat f * 110) |> perc 0.01 1.5 -1

simpleSynth2 :: Float -> Stereo Audio
simpleSynth2 f =
  sin (fromFloat f * 220) |> mul 0.5 |> perc 0.01 1 -1

-- weirdTempo

simpleScoreTest :: Stereo Audio
simpleScoreTest =
  polyScore simpleScore simpleSynth1 simpleScoreSeq * 0.1 + s2
  -- poly simpleSynth1 (simpleScoreSeq |> seqSpeed (bpm 103)) * 0.1 + s2
  -- s2
  where
    s2 =
      if currBlockTime < 1 then 0 else
        polyScore simpleScore simpleSynth1 simpleScoreSeq
        -- poly simpleSynth1 (simpleScoreSeq |> seqSpeed (bpm 103))
        -- polyScore simpleScore simpleSynth2 simpleScoreSeq2
        |> mul 0.1

-- simpleScoreTest :: Stereo Audio
-- simpleScoreTest =
--   poly simpleSynth1 (simpleScoreSeq |> seqSpeed (bpm 135)) * 0.1 + s2
--   where
--     s2 =
--       if currBlockTime < 2 then 0 else
--         poly simpleSynth1 (simpleScoreSeq |> seqSpeed (bpm 135))
--         -- poly simpleScore simpleSynth2 simpleScoreSeq2
--         |> mul 0.1

-- ----------------------
-- -- Complex Score
-- ----------------------
--
-- data ComplexScore = ComplexScore Alphabet UInt SectionType
--
-- -- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
-- instance Eq ComplexScore where
--   eq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
--     xSection == ySection && xSubSection == ySubSection && xSectionMod == ySectionMod
--   neq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
--     xSection /= ySection || xSubSection /= ySubSection || xSectionMod /= ySectionMod
--
-- instance Default ComplexScore where
--   default = ComplexScore A 1 First
--
-- instance Print ComplexScore where
--   print _ w =
--     print "ComplexScore" w

-- instance ScoreType ComplexScore where
--   score =
--     {
--       Section (Beats 24) (ComplexScore A 1 First) (Tempo 180),
--       Section (Beats  8) (ComplexScore A 1 Trans) (TempoChange 180 90 3),
--       Section (Beats 32) (ComplexScore A 2 First) (Tempo  90),
--       Section (Beats 64) (ComplexScore B 1 First) (TempoChange 90 120 -1),
--       Section (Beats 64) (ComplexScore B 2 First) (Tempo 120),
--       Section (Beats 64) (ComplexScore B 2 Trans) (TempoChange 120 180 -4),
--       Section (Beats 32) (ComplexScore A 1 Prime) (Tempo 180),
--       Section (Beats 16) (ComplexScore A 2 Prime) (Tempo 180),
--       Section (Beats 32) (ComplexScore A 3 Prime) (Tempo 180)
--     }
--     |> scoreNew

-- complexScore :: Score ComplexScore
-- complexScore = score
--
-- -- complexScoreSeq :: Seq ComplexScore Float
-- -- complexScoreSeq =
-- --   caseM section of
-- --     ComplexSection A 1 First -> [0 1 2 3]
-- --     ComplexSection A 1 Trans -> [0 1 2 3]
-- --     ComplexSection A 2 _     -> [3 2 1 0]
-- --     ComplexSection B 1 First -> [4 _ 4 _]
-- --     ComplexSection B 2 First -> [_ 4 _ 4]
-- --     ComplexSection B 2 Trans -> [4 5 6 7]
-- --     ComplexSection A 1 Prime -> [0 1 8 3]
-- --     ComplexSection A 3 Prime -> [3 2 8 9]
-- --     _                        -> rest
-- --


----------------------
-- Main
----------------------

main :: *World -> *World
main w =
  outAudio 0 simpleScoreTest w

