
----------------------
-- Score API usage example
----------------------

-- TODO: Look at defunctionalization sharing
-- TODO: Fix compiling complex case expressions
-- TODO: playDuringSection, playAtSection, playRange, playThenFadeRange, etc
-- TODO: Deriving capability
-- TODO: Pitch detection
-- TODO: "Tonal" Remapper via pitch detection
-- TODO: Frequency shifting
-- TODO: default score
-- TODO: End?

----------------------
-- Simple Score
----------------------

-------------
-- Set up --
data SimpleScore = SimpleScore Alphabet

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Eq SimpleScore where
  eq  (SimpleScore xSection) (SimpleScore ySection) = xSection == ySection
  neq (SimpleScore xSection) (SimpleScore ySection) = xSection /= ySection

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Default SimpleScore where
  default = SimpleScore A

instance ScoreType SimpleScore where
  score =
    {
      Section (Beats 12) (SimpleScore A) (Tempo 103),
      Section (Beats 12) (SimpleScore B) (Tempo 150),
      Section (Beats  4) (SimpleScore D) (Tempo 122),
      Section (Beats 12) (SimpleScore A) (Tempo 122),
      Section (Beats 12) (SimpleScore C) (Tempo  80),
    }
    |> scoreNew
    -- |> scoreNewAt 1

simpleScore :: Score SimpleScore
simpleScore =
  score

-- defaultScore :: Score SimpleScore

-------------
-- Usage --

simpleScoreSeq1 :: Seq Float
simpleScoreSeq1 =
  scoreSection >>= \s ->
  case s of
    SimpleScore A -> [1 2 [3:2] 5]
    SimpleScore B -> [6 3 2 [3:1:2]]
    SimpleScore C -> [4 2 <1 3> 2]
    _             -> [5 0.5 4 1]

simpleScoreSeq2 :: Seq Float
simpleScoreSeq2 =
  scoreSection >>= \s ->
  case s of
    SimpleScore A -> [<1 2 3> 5]
    _             -> [7 _ 0.5 8]

simpleSynth1 :: Float -> Stereo Audio
simpleSynth1 f =
  sin (fromFloat f * 110) |> perc 0.01 1.5 -1

simpleSynth2 :: Float -> Stereo Audio
simpleSynth2 f =
  sin (fromFloat f * 220) |> mul 0.5 |> perc 0.01 1 -1

simpleSynth3 :: Stereo Audio
simpleSynth3 =
  sin (seqToAudioScore simpleScore simpleScoreSeq1 * 110)
  |> mul 0.5 |> asr 1 1000 1 1 |> silenceAtEnd

simpleSynth4 :: Stereo Audio
simpleSynth4 =
  sin (seqToAudioScore simpleScore simpleScoreSeq2 * 220)
  |> mul 0.5 |> asr 1 1000 1 1 |> silenceAtEnd

-- -- polyScore test
-- simpleScoreTest :: Stereo Audio
-- simpleScoreTest =
--   polyScore simpleScore simpleSynth1 simpleScoreSeq1 +
--   polyScore simpleScore simpleSynth2 simpleScoreSeq2
--   |> mul 0.1

-- -- seqToAudioScore test
-- simpleScoreTest :: Stereo Audio
-- simpleScoreTest =
--   simpleSynth3 +
--   simpleSynth4
--   |> mul 0.1

-- -- ...great. Crash. fml
-- -- Offset test
-- simpleScoreTest :: Stereo Audio
-- simpleScoreTest =
--   polyScore simpleScore simpleSynth1 simpleScoreSeq1 * 0.1 + s2
--   where
--     s2 = if currBlockTime < 3 then 0 else
--       polyScore simpleScore simpleSynth2 simpleScoreSeq1
--       |> mul 0.1

----------------------
-- Complex Score
----------------------

data ComplexScore = ComplexScore Alphabet Int SectionType

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Eq ComplexScore where
  eq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
    xSection == ySection && xSubSection == ySubSection && xSectionMod == ySectionMod
  neq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
    xSection /= ySection || xSubSection /= ySubSection || xSectionMod /= ySectionMod

instance Default ComplexScore where
  default = ComplexScore A 1 First

instance Print ComplexScore where
  print _ w =
    print "ComplexScore" w

instance ScoreType ComplexScore where
  score =
    {
      Section (Beats 12) (ComplexScore A 1 First) (Tempo 180),
      Section (Beats  8) (ComplexScore A 1 Trans) (Tempo 120),
      Section (Beats 12) (ComplexScore A 2 First) (Tempo  90),
      Section (Beats 12) (ComplexScore B 1 First) (Tempo 150),
      Section (Beats 12) (ComplexScore B 2 First) (Tempo 120),
      Section (Beats  8) (ComplexScore B 2 Trans) (Tempo  90),
      Section (Beats 12) (ComplexScore A 1 Prime) (Tempo 180),
      Section (Beats  8) (ComplexScore A 2 Prime) (Tempo 180),
      Section (Beats 16) (ComplexScore A 3 Prime) (Tempo 180)
    }
    |> scoreNew

complexScore :: Score ComplexScore
complexScore = score

-- Seq optimization: [0 1 2 3] Seq expression with all contants contained into it is desugared into
-- Seq (\_ -> let i ~ 0 = i + 1 in readArray (Index (i - 1)) {0, 1, 2, 3})

complexScoreSeq :: Seq Float
complexScoreSeq =
  scoreSection >>= \s ->
  case s of
    ComplexScore A 1 First -> [0 1 2 3]
    ComplexScore A 1 Trans -> [0 1 2 3]
    ComplexScore A 2 _     -> [3 2 1 2]
    ComplexScore B 1 First -> [4 _ 4 _]
    ComplexScore B 2 First -> [_ 4 _ 4]
    ComplexScore B 2 Trans -> [4 5 6 7]
    ComplexScore A 1 Prime -> [2 1 8 3]
    ComplexScore A 3 Prime -> [3 2 8 9]
    _                      -> rest

-- Complex polyScore test
complexScoreTest :: Stereo Audio
complexScoreTest =
  polyScore complexScore simpleSynth1 complexScoreSeq
  |> mul 0.2


----------------------
-- Main
----------------------

main :: *World -> *World
main w =
  outAudio 0 complexScoreTest w
  -- outAudio 0 simpleScoreTest w

