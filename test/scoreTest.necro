
----------------------
-- Score API usage example
----------------------

-- TODO: Pitch detection
-- TODO: "Tonal" Remapper via pitch detection
-- TODO: Frequency shifting
-- TODO: Monomorphization lambda lift bug
-- TODO: seqToAudioScore
-- TODO: default score
-- TODO: monadic control flow (case, if/then/else)
-- TODO: Lambda lift compiler bug on scoreSection (fml)
-- TODO: Score determined Quantization?
-- TODO: End?
-- TODO: scoreSection >>= \s ->

-- DONE: Seq is instance of Monad
-- DONE: Return functions from if/case
-- DONE: Partially, Score system

----------------------
-- Simple Score
----------------------

-------------
-- Set up --
data SimpleScore = SimpleScore Alphabet

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Eq SimpleScore where
  eq  (SimpleScore xSection) (SimpleScore ySection) = xSection == ySection
  neq (SimpleScore xSection) (SimpleScore ySection) = xSection /= ySection

-- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
instance Default SimpleScore where
  default = SimpleScore A

instance ScoreType SimpleScore where
  score =
    {
      Section (Beats 12) (SimpleScore A) (Tempo 103),
      Section (Beats 12) (SimpleScore B) (Tempo 150),
      Section (Beats  4) (SimpleScore D) (Tempo 122),
      Section (Beats 12) (SimpleScore A) (Tempo 122),
      Section (Beats 12) (SimpleScore C) (Tempo  80),
    }
    |> scoreNew
    -- |> scoreNewAt 4

simpleScore :: Score SimpleScore
simpleScore =
  score

-------------
-- Usage --

simpleScoreSeq :: Seq Float
simpleScoreSeq =
  scoreSection >>= \s ->
  case s of
    SimpleScore A -> [1 2 [3:2] 5]
    SimpleScore B -> [6 3 2 [3:1:2]]
    SimpleScore C -> [4 2 <1 3> 2]
    _             -> [5 0.5 4 1]

simpleScoreSeq2 :: Seq Float
simpleScoreSeq2 =
  scoreSection >>= \s ->
  case s of
    SimpleScore A -> [<1 2 3> 5]
    _             -> [7 _ 0.5]

simpleSynth1 :: Float -> Stereo Audio
simpleSynth1 f =
  sin (fromFloat f * 110) |> perc 0.01 1.5 -1

simpleSynth2 :: Float -> Stereo Audio
simpleSynth2 f =
  sin (fromFloat f * 220) |> mul 0.5 |> perc 0.01 1 -1

-- defaultScore :: Score SimpleScore

-- Normal test
simpleScoreTest :: Stereo Audio
simpleScoreTest =
  polyScore simpleScore simpleSynth1 simpleScoreSeq +
  polyScore simpleScore simpleSynth2 simpleScoreSeq2
  |> mul 0.1

-- -- Offset test
-- simpleScoreTest :: Stereo Audio
-- simpleScoreTest =
--   polyScore simpleScore simpleSynth1 simpleScoreSeq * 0.1 + s2
--   where
--     s2 = if currBlockTime < 3 then 0 else
--       polyScore simpleScore simpleSynth2 simpleScoreSeq
--       |> mul 0.1

-- ----------------------
-- -- Complex Score
-- ----------------------
--
-- data ComplexScore = ComplexScore Alphabet UInt SectionType
--
-- -- NOTE: This boilerplate won't need to be here once we have 'deriving' capability in the compiler!
-- instance Eq ComplexScore where
--   eq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
--     xSection == ySection && xSubSection == ySubSection && xSectionMod == ySectionMod
--   neq (ComplexScore xSection xSubSection xSectionMod) (ComplexScore ySection ySubSection ySectionMod) =
--     xSection /= ySection || xSubSection /= ySubSection || xSectionMod /= ySectionMod
--
-- instance Default ComplexScore where
--   default = ComplexScore A 1 First
--
-- instance Print ComplexScore where
--   print _ w =
--     print "ComplexScore" w

-- instance ScoreType ComplexScore where
--   score =
--     {
--       Section (Beats 24) (ComplexScore A 1 First) (Tempo 180),
--       Section (Beats  8) (ComplexScore A 1 Trans) (TempoChange 180 90 3),
--       Section (Beats 32) (ComplexScore A 2 First) (Tempo  90),
--       Section (Beats 64) (ComplexScore B 1 First) (TempoChange 90 120 -1),
--       Section (Beats 64) (ComplexScore B 2 First) (Tempo 120),
--       Section (Beats 64) (ComplexScore B 2 Trans) (TempoChange 120 180 -4),
--       Section (Beats 32) (ComplexScore A 1 Prime) (Tempo 180),
--       Section (Beats 16) (ComplexScore A 2 Prime) (Tempo 180),
--       Section (Beats 32) (ComplexScore A 3 Prime) (Tempo 180)
--     }
--     |> scoreNew

-- complexScore :: Score ComplexScore
-- complexScore = score
--
-- -- complexScoreSeq :: Seq ComplexScore Float
-- -- complexScoreSeq =
-- --   caseM section of
-- --     ComplexSection A 1 First -> [0 1 2 3]
-- --     ComplexSection A 1 Trans -> [0 1 2 3]
-- --     ComplexSection A 2 _     -> [3 2 1 0]
-- --     ComplexSection B 1 First -> [4 _ 4 _]
-- --     ComplexSection B 2 First -> [_ 4 _ 4]
-- --     ComplexSection B 2 Trans -> [4 5 6 7]
-- --     ComplexSection A 1 Prime -> [0 1 8 3]
-- --     ComplexSection A 3 Prime -> [3 2 8 9]
-- --     _                        -> rest
-- --


----------------------
-- Main
----------------------

main :: *World -> *World
main w =
  outAudio 0 simpleScoreTest w

