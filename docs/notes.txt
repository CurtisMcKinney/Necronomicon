coolPattern :: Event Audio
coolPattern = pattern times values
    where
        times  = seq [0.25, 0.5, 0.25]
        values = seq [countUp, mouseX |> take 1, countDown]

mouseX    = {0, 100, 200..N*100}
countUp   = {1,2}
countDown = { -1, -2 }

-- Embed coeffects DIRECTLY into language, akin to two ways of approaching monads,
-- as presented by Moggi and coeffects thesis

-- coolPattern used in context 1:
stream time = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
item  time  = { 0, 1, 0,    0,  1, 0, 1,   0,  0,  1 }
globaltime  = { 0, 1, 2,    3,  4, 5, 6,   7,  8,  9 }
values      = { 1, 2, 200, -1, -2, 1, 2, 700, -1, -2 }

-- coolPattern used in context 2:
stream  time = { 0, 1, 2,    3,  4,  5,  6,    7,  8,  9 }
item  time   = { 0, 1, 0,    0,  1,  0,  1,    0,  0,  1 }
global time  = { 5, 6, 7,    8,  9, 10, 11,   12, 13, 14 }
values       = { 1, 2, 700, -1, -2,  1,  2, 1200, -1, -2 }

-- Cool, semantically that works, but how does this affect
-- reuse and variable binding?
-- Values are now associated with a context comprised of TWO time streams: static time and dynamic time
-- Static time is the time of the scope where the was value declared.
-- Dynamic time is the time of the scope where the value is being used.
-- Thus when a value is constructed it is can be stored as such:
-- coolPattern 1: [(0, 0), (1, 1), (2, 2)]
-- coolPattern 2: [(0, 5), (1, 6), (2, 7)]
-- The semantics are still pure as multiple accesses to the same stream within the same context
-- always provide the same result

-- Ok, but does that work with feedback:
countUp    = {1,2}
countDown  = {9,8}
mouseX     = {0, 100, 200..N*100}

feedBack    = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {0, 1, 2, 3, 4, 5}
values      = {1, 2, 9, 8, 1, 2}

feedBack2   = seq [countUp, countDown, feedBack]
stream time = {0, 1, 2, 3, 4, 5}
item time   = {0, 1, 0, 1, 0, 1}
global time = {5, 6, 7, 8, 9, 10}
values      = {1, 2, 9, 8, 1, 2}

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

noFeedback  = seq [countUp, mouseX |> take 1, countDown]
stream time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
item time   = {0, 1,   0, 0, 1, 0, 1,   2, 3, 4}
global time = {0, 1,   2, 3, 4, 5, 6,   7, 8, 9}
values      = {1, 2, 200, 9, 8, 1, 2, 200, 9, 8}

-- New idea:
-- Use Monad to enforce current value, everything else is a pure lazy stream.
-- No need for keeping track of "Contexts" or clocks
-- Needs garbage collection, but naturally handles feed back, cycles, and "current" values
-- Prevents top level "current" computations
-- Resolves ambiguity of "current" value times (value is from the time at which it was bound)
-- Enforces purity (the current value is bound to a single value which can be shared).
-- Don't need to record entire history of inputs
-- Feeback can still cause large thunk chains, but I think this is fine and akin to needing to understand that foldr can blow up on infinite lists
-- Need to check against global time of cached value in thunk?!?!?!!?

current :: CurrentMonad m => a -> m a

semantics then become:
data Stream a = Stream  (Maybe a) (StreamState -> Stream a) --value, next, StreamState
              | End
              | Constant a


-- | Current IORef a

feedBack3   = seq [countUp, mouseX |> take 1, countDown, feedBack]
noFeedback  = seq [countUp, mouseX |> take 1, countDown]

countDownBase = Stream 9 (Stream 8 End)

next :: Stream a -> (a, Stream a)
next = undefined

mkSequence :: Array (Stream a) -> Stream a
mkSequence streams = sequence 0 streams (Array.empty (Array.size streams))
    where
        sequence index streams newStreams =

take :: Stream a -> Stream Int -> Stream a
take stream numStream = go stream ystream 0
    where
         go (Stream streamVal streamCont) (Stream numVal numCont) count = if count >= numVal
            then Stream Nothing          (go streamCont numCont 0)
            else Stream (Just streamVal) (go streamCont numCont (count + 1))

countUp   = Stream (Just 1) (Stream (Just 2) End))
countDown = Stream (Just 9) (Stream (Just 8) End))
feedBack3 =

data StreamIO a = StreamIO (World -> (a, StreamIO (), World))

instance Monad StreamIO where
    x >>= f = StreamIO $ \world -> case demand x of
        (xVal, xCont) -> case f xVal of
            StreamIO ff -> case ff world of
                (gVal, gCont, world2) -> (gVal, xCont >> gCont, world2)

current :: Stream a -> StreamIO (Stream a)
current (Stream val cont) = StreamIO $ \world ->
    case mkCurrentRef val world of
        (ref, world2) -> let refStream     = Stream (Just (unsafeRead ref)) stream
                             refCont cont' = StreamIO (\world3 -> let (contVal, contCont) = demand cont' in let world4 = writeCurrentRef contVal in ((), refCont' contCont, world4))
                         in  StreamIO (refStream, refCont, world2)

data StreamIO x a = StreamIO (StreamState -> (a, x -> StreamIO a, StreamState))
data Stream   a   = Stream a (StreamIO () a)

instance Monad StreamIO where
    x >>= f = StreamIO $ \state ->
        let (xVal, xCont)         = demand x
            StreamIO sf           = f xVal
            (gVal, gCont, state') = sf state
        in (gVal, (xCont ()) >>= gCont, state')

-- Non-Strict, No Circular References, is it possible:
feedback = seq [0, 1 + feedback]

values   = {0, 1, 2, 3}
refs     = {[ref 0, ref 1 + ref feedback[0]]}

feedback[0] = Sequence ()

main :: IO () ()
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

-- Comonadic semantics for effects idea:
-- Comonadic do idea
-- Extraction is a safe opeartion in the main Necro Language
current :: a -> {a}

-- Injection is an unsafe operation in the main Necro language
-- constant :: {a} -> a -- UNSAFE!!!

rand :: Num a => a -> a -> {a}

(=>>) :: a -> (a -> {b}) -> b

sin 440 =>> current
sin 440 =>> simpleRand

main :: ()
main = do
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 synths

randSynth :: Audio -> Audio -> {Audio}
randSynth low high = do
    r1 <- rand low high
    r2 <- rand low high
    r1 + r2 |> current

-equivalant to-

randSynth :: Audio -> Audio -> {Audio}
randSynth low' high' =
    (low'         =>> \low  ->
    high'         =>> \high ->
    rand low high =>> \r1   ->
    (rand low high |> \r2   ->
     current (r1 + r2)))

    current (coolSynth =>> \coolSynth' -> current coolSynth')
    current (rand l h  =>> \rand' -> current rand')

current :: Stream a -> a
current (Stream aVal aCont) = aVal

rand :: Stream Audio -> Stream Audio -> Audio
rand (Stream lowVal _ lowState) (Stream highVal _ highState) = genRandWithSeed (mergeRand lowState highState + 1)

instance Comonad Stream where
    current (Stream aVal _ _) = aVal
    stream =>> f = Stream (f stream) (cont stream =>> f)

-- Need State parameter for things like rand to get threaded through...how?
Store Comonad for State

()            \_     ->
rand 0 1  =>> \rand1 ->
rand 0 2  =>> \rand2 ->
coolSynth =>> \coolSynth' ->

randSynth :: Audio -> Audio -> {Audio}
randSynth low high = do
    r1 <- rand low high
    r2 <- rand low high
    current (r1 + r2)

randSynth :: Audio -> Audio -> {Audio}
randSynth low high =
    rand low high =>> (\r1 ->
    rand low high |>  (\r2 ->
    current (r1 + r2))

-- Like this things can actually be strict because the cont is hidden in a function
data Stream a = Stream a (\Int -> Stream) (Int -> Int) Int

instance Comonad Stream where
    current (Stream aVal _ _ _ _) = aVal
    (Stream val cont getter state) =>> f =

---------------------------------------------------------------------
-- Comonads approach 2: Comonadic effects on top of main language
type IO a = StreamIO StreamState a

main :: IO State -> ()
main = do (u)
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth (current sample1)) mouseX
        synth2 = poly1 tick       (synth (current sample2)) mouseY
        synths = synth 1 + synth2
    current audioOut 0 synths

loadSample :: String -> IO () -> AudioBuffer

audioOut :: Audio -> IO () -> ()
rand :: IO (Audio, Audio) -> Audio

-- rand :: Audio -> Audio -> IO Audio
-- rand low high = store (\state -> genRand low high state) initState

data IO s a = IO (s -> a) s
instance Function (IO s) where
    fmap f (IO g s) = IO (f . g) s

instance Comonad (IO s) where
    current   (IO g s) = g s
    duplicate (IO g s) = IO (IO g) (bumpSeed s)

---------------------------------------------------------------------
-- Monadic approach 3: Use Comonad Store under the hood

data Stream a = Stream a (Stream a)
data IO s a   = IO (s -> a -> a) (Stream s) (Stream a)

audioOut :: Stream Audio -> IO (Stream ())
load :: Stream String -> IO (Stream AudioBuffer)
rand :: Stream Audio -> Stream Audio -> IO (Stream Audio)

current :: Stream a -> IO (Stream a)
current (Stream aVal aCont) = IO (Constant aVal) aCont

rand :: Stream Audio -> Stream Audio -> IO (Stream Audio)

-- Split and merge state for random numbers
instance Monad IO where
    pure x = go
        where
            go = IO (\_ -> (x, go)) x
    IO xf xs xa >>= f = IO (fsa fs
        where
            xVal         = xf (current xs) (current xa)
            IO fsa fs fa = f xVal
            fsa xs fa = fsa' (IO xsa xCont)

---------------------------------------------------------------------
-- Comonads approach 3: Comonadic effects on top of main language with alternate do and api
type IO a = StreamIO StreamState a

main :: IO () -> ()
main = do ()
    sample1 <- load "pulseDemon"
    sample2 <- load "doomBlad"
    let synth1 = poly1 mouseClick (synth (current sample1)) mouseX
        synth2 = poly1 tick       (synth (current sample2)) mouseY
        synths = synth 1 + synth2
    current audioOut 0 synths

loadSample :: String -> IO () -> AudioBuffer
audioOut :: IO Audio -> ()
rand :: IO (Audio, Audio) -> Audio

data IO s a = IO (s -> a) s
instance Function (IO s) where
    fmap f (IO g s) = IO (f . g) s

instance Comonad (IO s) where
    current   (IO g s) = g s
    duplicate (IO g s) = IO (IO g) (bumpSeed s)

---------------------------------------------------------------------
-- Arrow approach to effects: Works but seems like overkill

audioOut :: IO Audio ()
load     :: IO String AudioBuffer
rand     :: IO (Audio, Audio) (Audio)
current  :: IO a a

main :: IO () ()
main = proc () -> do
    sample1 <- load -< "pulseDemon"
    sample2 <- load -< "doomBlad"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth 1 + synth2
    audioOut 0 -< synths

randSynth :: Audio Audio -> IO () Audio
randSynth low high = proc () -> do
    r1 <- rand -< (low, high)
    r2 <- rand -< (low, high)
    returnA -< r1 + r2

---------------------------------------------------------------------
-- Stream Monad approach: World Parameter fuxorz this idea, causes time and space leak

data World = World
data IO a  = IO (World -> (a, IO a, World))

instance Functor IO where
    pure x         = IO (\w -> (x, pure x, w))
    map  f (IO xw) = IO (\w -> let (x, xs, w') = xw w in (f x, map f xs, w'))

instance Monad IO where
    xs >>= f = IO diagonal (map f xs)
        where
            ioHead   (IO xw) w = let (xh, _, w') = xw w in (xh, w')
            ioTail   (IO xw)   = IO (\w -> let (_, IO xw', w') = xw w in xw' w')
            diagonal (IO xw) w = (h, IO diagonal (map ioTail ioss), w')
                where
                    (ios, ioss, w') = xw w
                    (h, w'')        = ioHead ios w'

instance Monad IO where
    xs >>= f = diagonal (map f xs)
        where
            ioHead (IO x _)        = x
            ioTail (IO _ xs)       = xs
            diagonal (IO ios ioss) = IO (ioHead ios) (diagonal (map ioTail ioss))

current :: Stream a -> IO (Stream a)
current (Stream aVal aCont) = IO (\w -> (Constant aVal, current aCont, w))

rand :: (Rand a) => Stream a -> Stream a -> IO (Stream a)
rand low high = IO go
    where
        g w = (nStream n, pure nStream, w')
            where
                (n, w') = genRand (streamHead low) (streamHead high) w
                nStream = Constant n

---------------------------------------------------------------------
-- Stream Monad approach: World Parameter fuxorz this idea, causes time and space leak
data World    = World
data Stream a = Stream a (Stream a)
data IO a     = IO (World -> (Stream a, World))

current :: Stream a -> IO (Stream a)
current stream = IO (\w -> (go stream, w))
    where
        go

---------------------------------------------------------------------
-- Streamed IO idea .... doesn't work, state gets wonky and if the value isn't used (such as with >>) the effect doesn't manifest

-- Monadic approaches also don't solve the problem of having lazy streams but still having access to "input" benign effects like mouse input as a pure stream

data World    = World
data Stream a = Stream a (Stream a)
data IO a     = IO (World -> a) World

current :: Stream a -> Stream (IO a)
current (Stream aVal aCont) = Stream (IO (\_ -> aVal)) (current aCont)

rand :: (Rand a) => Stream a -> Stream a -> Stream (IO a)
rand (Stream lowVal lowCont) (Stream highVal highCont) = Stream (IO (\w -> w))

load :: Stream String -> Stream (IO (Stream AudioBuffer))
load


-- Haskell-fied
type World    = Int
data Stream a = Stream a (Stream a)
data SIO a    = SIO (World -> a) World

mergeWorlds :: World -> World -> World
mergeWorlds w1 w2 = w1 + w2

initWorld :: World
initWorld = 0

runSIO :: SIO a -> a
runSIO (SIO sa s) = sa s

instance Functor SIO where
    fmap f (SIO sa s) = SIO (\s' -> let x = sa s' in f x) s

instance Applicative SIO where
    pure x = SIO (\_ -> x) initWorld
    (<*>)  = undefined

instance Monad SIO where
    return = pure;
    SIO sa s >>= f = SIO fsa initWorld
        where
            fsa s' = let SIO fsa' s'' = f (sa (mergeWorlds s s')) in fsa' s''

countSeed :: SIO Int
countSeed = SIO (\s -> s + 1) 1 -- initWorld of 1 will bump seed count by 1 when it merges with another world

---------------------------------------------------------------------
-- Comonadic IO on top Streams.....????

audioOut :: IO Audio -> ()
load :: IO String -> AudioBUffer
rand :: Num a => IO a -> IO a -> a
current :: IO a -> a

main :: IO () -> ()
main = do () =>
    -- how the fuck does this work???
    let sample1 = load "pulseDemon"
        sample2 = load "doomBlade"
        synth1  =  poly1 mouseClick (synth (current sample1)) mouseX
        synth2  =  poly1 tick       (synth (current sample2)) mouseY
    audioOut 0 synth

randSynth :: IO Audio -> IO Audio -> Audio
randSynth = do (low, high) =>
    r1 <- rand low high
    r2 <- rand low high
    current r1 + current r2

---------------------------------------------------------------------
-- Comonadic IO on top Streams 2???

audioOut   :: Int -> IO Audio -> ()
playBuffer :: IO AudioBuffer -> Audio
loadBuffer :: String -> IO () -> AudioBuffer
current    :: IO a -> a
rand       :: Num a => a -> a -> IO () -> a

main :: IO () -> ()
main = do(io)
    sample1 <- loadBuffer "pulseDemon" io
    sample2 <- loadBuffer "doomBlade" io
    synth1  <- poly1 mouseClick (synth sample1) mouseX
    synth2  <- poly1 tick       (synth sample2) mouseY
    synths  <- extract synth1 + extract synth2
    audioOut 0 synth

---------------------------------------------------------------------
-- Coeffects, using Indexed Comonads
(models both per-variable and whole context)

-- Linear Types vs Coeffects?!?!?!
-- Since we're already doing a comonadic translation, making them "Indexed" comonads might be simpler?!?! or is it?!?!

-- Bounded reuse
audioOut   :: Int -> Audio -> IO -o IO
playBuffer :: AudioBuffer -> Audio
loadBuffer :: String -o IO -o (AudioBuffer, IO)

-- Non-determinism
rand       :: Num a => a -> a -> IO -o (a, IO)
noise      :: Num a => a -> a -> IO -o (a, IO)
blur       :: Num a => a -> a -> Int -> (a -> a) -> IO -o (a, IO)

-- Bang notation a la' alms
"The pattern !cap bound by let marks cap
 as an “imperative variable,” which means
 that within its scope, functions applied to
 cap are expected to return a pair of their
 real result and the new version of cap.
 Alms transforms this code into the explicitly-threaded
 version above. Currently this transformation
 happens before type checking, which means that it
 cannot compromise soundness but also cannot exploit type in-
 formation."

-- Semantically this works well
-- Syntactically
-- Wait, how do demand rate semantics play into this!!?!?!?!
-- Linearity should prevent shenanigans?
-- current combinator / concept still needs to be banged out, but this seems like the most promising idea
-- Perhaps still Lucids idea, but use bind operator:
    currSynth <- sinOsc 440 * sinOsc 0.1

main :: IO -o IO
main !io = audioOut 0 synths io
    where
        sample1 = loadBuffer "pulseDemon" io
        sample2 = loadBuffer "doomBlade"  io
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

randSynth :: Audio -> Audio -> IO -o (Audio, IO)
randSynth low high !io = (b, io)
    where
        r1  = rand  low high io
        n   = noise low high io
        f x = x * r1 + n |> sinOsc
        b   = blur  low high 64 f io

currSynth :: Event Audio
currSynth = pattern ts vs
    where
        c <- sinOsc 440 * sinOsc 0.1
        ts = [0.5, 0.25, 0.25]
        vs = seq [0, 1, take 2 c]

=== Stream translation

-- Works perfectly since the impure actions can now manifest and share values in the regular stream scope
rand :: Stream a -> Stream a -> Stream IO -> Stream (a, IO)
rand (Stream lowVal _) (Stream highVal _) (Stream ioVal ioCont) = Stream (rVal, ioVal2) (rCont ioCont)
    where
        (rVal, ioVal2)                = genRand lowVal highVal ioVal
        rCont (Stream ioVal3 ioCont2) = Stream (rVal, ioVal3) (rCont ioCont2)

mainDriver :: (Stream IO -> Stream IO) -> IO -> (Stream IO -> StreamIO, IO)
mainDriver (Stream mainVal mainCont) io = (mainCont, streamHead (mainVal (Constant io)))

-- ???? Still needs to be worked out
currSynth :: Stream (Event Audio)
currSynth =
    where
        Stream cVal cCont = ...
        c                 = Stream (cVal `until` ???)
        currSynthBody c   = ...

//=====================================================
// Stream Bind
//=====================================================
data Stream a = Stream a (Stream a)
data World    = World
data IO a     = IO (World -> (a, World))

data IOC a    = IO (a -> World -> (a, World)) a

(>>=) :: Monad m => Stream (m a) -> Stream (a -> m b) -> Stream (m b)

instance Monad IO where
    return x                                = Constant (\w -> (x, w))
    Stream xVal xCont >>= Stream fVal fCont = Stream g (xCont >>= fCont)
        where


//=====================================================
// Continuation IO
//=====================================================
data Stream a = Stream a (Stream a)
data World    = World
data IO a     = IO ((a -> World) -> World)

instance Monad IO where
    return x    = IO (\k -> k a)
    IO xk >>= f = IO <| \k ->
        let

---------------------------------------------------------------------
-- Uniqueness Types (a la the paper Uniqueness Typing Simplified)

-- Bounded reuse
audioOut   :: Int -> Audio -> World* -> World*
loadBuffer :: String -> World* -> (AudioBuffer, World*)
playBuffer :: AudioBuffer -> Audio

-- Non-determinism
rand       :: Rand a => a -> a -> World* -> (a, World*)
noise      :: Rand a => a -> a -> World* -> (a, World*)
blur       :: Rand a => a -> a -> [(a -> a)] -> World* -> (a, World*)

-- Semantically this works well
-- Syntactically....?
-- Uniquness types prevent demand rate shenanigans on I/O
-- Another win is performance, Monads introduce more bloat on top of the language,
   whereas Uniqueness are much lighter weight (a word-sized object is tossed around) and even allows for things like in-place updates
-- current combinator / concept still needs to be banged out, but this seems like the most promising idea

-- No Sugar
main :: World* -> World*
main w = audioOut 0 synths w2
    where
        (sample1, w1) = loadBuffer "pulseDemon" w
        (sample2, w2) = loadBuffer "doomBlade"  w1
        synth1        = poly1 mouseClick (synth sample1) mouseX
        synth2        = poly1 tick       (synth sample2) mouseY
        synths        = synth1 + synth2

-- Bang notation a la' alms
"The pattern !cap bound by let marks cap
 as an “imperative variable,” which means
 that within its scope, functions applied to
 cap are expected to return a pair of their
 real result and the new version of cap.
 Alms transforms this code into the explicitly-threaded
 version above. Currently this transformation
 happens before type checking, which means that it
 cannot compromise soundness but also cannot exploit type in-
 formation."

-- Uniqueness bang notation, stolen from Alms programming language
main :: World* -> World*
main !w = audioOut 0 synths w
    where
        sample1 = loadBuffer "pulseDemon" w
        sample2 = loadBuffer "doomBlade"  w
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

randSynth :: Audio -> Audio -> World* -> (Audio, World*)
randSynth low high !w = b w
    where
        r1  = rand  low high w
        n   = noise low high w
        f x = x * r1 + n |> sinOsc
        b   = blur low high (repeat 64 f)

//=====================================================
//
//=====================================================
audioOut   :: Audio -> IO ()
loadBuffer :: String -> IO AudioBuffer
rand       :: Rand a => a -> a -> IO a
current    :: a -> IO a

main :: IO ()
main = do
    sample1 <- loadBuffer "pulseDemon"
    sample2 <- loadBuffer "doomBlade"
    let synth1 = poly1 mouseClick (synth sample1) mouseX
        synth2 = poly1 tick       (synth sample2) mouseY
        synths = synth1 + synth2
    audioOut 0 synths

//=====================================================
// Coeffects
//=====================================================
data Input  = LoadAudioBuffer String
            | Mouse Int Int
data Output = AudioOut Int Audio

-- Coeffects put requirements on the environment
-- "Indexed Comonads", are essentially type level monoids
   that you can perform type level operatios on and which contain information
   about the requirements on the context of your program.

audioOut   :: Audio {1|aout}-> ()
loadBuffer :: String {aload}-> AudioBuffer

-- Rand just seems effectful
rand       :: Rand a => a -> a -> IO a

-- Current? Carries around time offset? Or something!?
current    :: a -> IO a

main :: () -{_}-> ()
main _ = audioOut 0 synths
    where
        sample1 = loadBuffer "pulseDemon"
        sample2 = loadBuffer "doomBlade"
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

audioOut   :: Int -> Audio -> Output -> Output
loadBuffer :: String -> Input -> AudioBuffer

-- bido?

main :: Input -> Output
main input = audioOut 0 synths initOut
    where
        sample1 = loadBuffer "pulseDemon" input
        sample2 = loadBuffer "doomBlade"  input
        synth1  = poly1 mouseClick (synth sample1) mouseX
        synth2  = poly1 tick       (synth sample2) mouseY
        synths  = synth1 + synth2

//=====================================================
// Env Streams
//=====================================================
data Env      = Env
data Stream a = Stream (a, Time) (Env -> Stream a)

--?!?!?!
-- tickStream :: Env -> Stream a -> Stream a
-- tickStream

nextAndTick :: Stream a -> Stream a
nextAndTick (Stream (_, t) cont) = cont (t + 1)

next :: Stream a -> Stream a
next (Stream (_, _) cont) = cont t

--=====================================================
-- Lucid with tracing GC and extended env
--=====================================================
-- With Coeffects and Type level literals
-- Requires both more advanced type system and runtime support

pulseDemon :: AudioBuffer @ Load "pulseDemon.aiff"
pulseDemon = load

kick1 :: AudioBuffer @ Load "kick.wav"
kick1 = load

chadSux :: Float @ Osc 192.168.0.1:21 "chadIn"
chadSux = osc

main :: Audio
main = playSample pulseDemon + playSample kick1

--=====================================================
-- Top Level do:
-- https://mail.haskell.org/pipermail/haskell/2004-October/014618.html
--=====================================================
-- This has actually been proposed for Haskell, so it's not completely insane

module main = do
mouseX     <- mouseXIO                     -- A single block of top level do block
pulseDemon <- loadBuffer "pulseDemon.wav"
kick       <- loadBuffer "kick.aiff"       -- Followed by pure functional definitions
let

coolSynth :: Audio -> Audio
coolSynth mul = mul * playBuffer pulseDemon + mouseX

main :: IO ()
main = audioOut 0 synths
    where
        synths = playBuffer pulseDemon + playBuffer kick

-------------------------------------------------------
-- STATE is current state Monad
-- Probably requires Lucid style runtime
-------------------------------------------------------
latch :: Event a -> a

data CoolState { x :: Int, y :: Int}

setX, setY :: Int -> CoolStateMonad ()
getX, getY :: CoolStateMonad Int

data CoolStateMonad a = CoolStateMonad (CoolState -> (a, CoolState))

instance Monad CoolStateMonad where
    return x                = CoolStateMonad (\s -> (a, s))
    CoolStateMonad xa >>= f = CoolStateMonad g where g s = ga s'
        where
            (x, s')           = xa e s
            CoolStateMonad ga = f x

getX :: CoolStateMonad Int
getX = CoolStateMonad <| \s -> (global (x s), s)

setX :: Int -> CoolStateMonad ()
setX val = CoolStateMonad <| \s -> ((), s{x = val})

mx :: CoolStateMonad Int
mx = CoolStateMonad <| \s -> (mouseX s, s)

isCurrent :: a -> IO a
isCurrent x = unsafeWithCurrent (\x' -> CoolStateMonad (\s -> (x', s))) x

fby :: a -> a -> a
fby x y = <x0, y0, y1,...,xn> (primop)

next :: a -> a
next x  = <x1, x2, x3,...,xn> (primop)

first :: a -> a
first x = y
    where
        y = <x, y>

whenever :: a -> Bool -> a
whenever a b = if first b
    then <first a, whenever (next a) (next b)>
    else whenever (next a) (next b)

upon :: a -> Bool -> a
upon a b = <first a, a'>
    where
        a' = if first b
            then upon (next a) (next b)
            else upon a        (next b)

coolMain :: CoolStateMonad ()
coolMain = do
    x <- getX
    let doubleTime = pattern twoToOne x |> latch
    doubleTime + 1 |> setX

runCoolStateMonad :: CoolStateMonad a -> CoolState -> a
runCoolStateMonad (CoolStateMonad f) state = f state

initState :: CoolState
initState = CoolState 0 0

runCoolMain :: CoolStateMonad ()
runCoolMain = state
    where
        state = unsafeWithCurrent <| (runCoolStateMonad coolMain) <initState, state>

unsafeWithCurrent :: (a -> b) -> a -> b
unsafeWithCurrent = black magic

-- IORefs back unsafeWithCurrent?

x = [0..]
printAndGo :: [Int] -> [Int] -> IO ()
printAndGo (x1 : xs1) (x2 : _ : xs2) = do
    putStrLn $ "x1: " ++ show x1 ++ ", x2: " ++ show x2
    printAndGo xs1 xs2
printAndGo x x

-------------------------------------------------------
-- Coeffects strike back
-- Use coeffects to track "Transient" values
-- Transient values must have a statically known lifetime (over time itself)
-- Transient values need to have a statically known buffer size
-------------------------------------------------------


myCoolFunc :: Int@
myCoolFunc = mouse + 1

mouse  :: (Int, Int)@

mouseX :: Int@
mouseX = ...

mouseSynth :: Audio -> Audio@
mouseSynth freq = x
    where
        x = sinOsc (freq + mouseX * (0 fby x))
        -- Actually this is ok
        -- Just say all transient values are "current"

main :: Audio@
main = mouseSynth 440

-------------------------------------------------------
-- Lucid Synchrone Semantics
-------------------------------------------------------
mouseX     :: Float : BlockRate
mouseClick :: () : OnClick
pClock     :: Time -> Clock:Clock -- ???
poly       :: Num b => (a -> b):c1 -> a:c1 -> b:c2
getClock   :: a:c1 -> Clock:c1 -- ???

merge      :: a:c1 -> a:c2 -> a:c3 -- ?!?!?!
sample     :: a:c1 -> a:c2 -- ?!?! MAGIC
when       :: a:c1 -> Clock:c2 -> a:c2 -- !?!?!?

audioOut   :: Int:Sys -> Audio:Sys -> IO () :Sys

synth :: Audio -> Audio -> Audio
synth freq = osc where
    osc = sinOsc (440 + freq * (0 fby osc))

main :: IO ()
main = audioOut 0 synths where
    freq1  = mouseX `when` clockOf mouseClick
    freq2  = d2f Minor {0, 1, 2, sample mouseX, freq2} `when` pattern {0.25, 0.5, 0.25, 0.5}
    synths = poly synth (merge freq1 freq2)

-------------------------------------------------------
-- Moment Monad
-------------------------------------------------------
-- Require the MomentMonad whenever you want dynamic streams (i.e. streams that start after the very beginning of time)
-- That means for things like poly which spawn new streams,
   things like pattern which jump between multiple streams,
   and feedback which starts with a delay
-- Should memo behavior be default, opt-in, or opt-out?
-- How does this work with long running-feedback problem?
-- Require RandMonad for randomness
-- Require IO Monad for loading buffers and writing to output
-- Buffer combinator which has different semantics than delay (doesn't actually delay starting the second stream, provides a buffer value)
   buffer wouldn't need MomentMonad?

class MomentMonad a
instance MomentMonad IO

mouseX     :: Float
mouseClick :: Event ()
on         :: a -> Event b -> Event a
merge      :: Event a -> Event a -> Event a
pattern    :: MomentMonad m => [Time] -> [a] -> m (Event a)
poly       :: (MomentMonad m, Num b) => (a -> b) -> Event a -> m b
audioOut   :: Int -> Audio -> IO ()
take       :: Int -> a -> a

-- MomentMonad required because we want feedback
synth :: MomentMonad m => Audio -> Audio -> m Audio
synth freq = do rec
    osc <- delay 0 <| sinOsc <| 440 + freq * osc
    pure osc

-- MomentMonad not required because its using buffer instead of delay
synth' :: Audio -> Audio -> Audio
synth' freq = osc
    where osc = 440 + freq * osc |> sinOsc |> buffer 0

main :: IO ()
main = do
    let freq1 = mouseX `on` mouseClick
    freq2    <- pattern [0.25, 0.5, 0.25, 0.5] <| map (d2f Minor) [0, 1, 2, take 1 mouseX]
    synths   <- poly synth (merge freq1 freq2)
    audioOut 0 synths

-------------------------------------------------------
-- Lucid Synchrone Semantics, Take 2
-------------------------------------------------------
-- Don't think this works, doesn't have a correct enforcement mechanism
-- Look into either phantom types or
-- Look into first class clocks with dependent kinding

poly       :: Num b => (a -> b) -> Event a -> b
poly       :           c1       -> c2      -> c2

pattern    :: Seq Time -> Seq a -> Event a
pattern    :  c1       -> c1    -> c2

seq        :: Seq a -> a
seq        :  c1    -> c2

sample     :: a  -> a
sample     :  c1 -> c2

latch      :: Event a -> a
latch      :  c1      -> c2

mouseX     :: Float    : Sys
mouseClick :: Event () : Sys

audioOut   :: Int -> Audio -> IO ()
audioOut   :  Sys -> Sys   -> Sys

fby        :: a -> a -> a --Do we care about distinction between pointwise and stateful streams?!
merge      :: Event a -> Event a -> Event a
on         :: a -> Event b -> Event a
take       :: Int -> a -> a

synth :: Audio -> Audio -> Audio
synth freq = osc where
    osc = sinOsc (440 + freq * 0 fby osc)

main :: IO ()
main = audioOut 0 synths where
    freq1  = mouseX `on` mouseClick
    freq2  = pattern {0.25, 0.5, 0.25, 0.5} (d2f Minor {0, 1, 2, sample mouseX |> take 1, latch freq2})
    synths = poly synth (merge freq1 freq2)

-------------------------------------------------------
-- Phantom Sequences?
-------------------------------------------------------

-------------------------------------------------------
-- Lucid Synchrone Semantics take 3
-------------------------------------------------------
http://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf
https://www.di.ens.fr/~pouzet/lucid-synchrone/lucid-synchrone-3.0-manual.pdf

mouseX     :: Float
mouseX     :  Sys

mouseClick :: Tick
mouseClick :  Sys

poly       :: Num b => (a -> b) -> a -> b
poly       :           t        -> t -> t

pattern    :: Time -> Tick -- The thing that's different is our sample times can be hella different!
pattern    :  t    -> t

when       :: a -> b        -> a
when       :  t -> (c0 : t) -> t on c0

sample     :: a:c1 -> a:c2 -- ?!?! MAGIC
merge      :: a:c1 -> a:c2 -> a:c3 -- ?!?!?!

audioOut   :: Int -> Audio -> IO ()
audioOut   :  Sys -> Sys   -> Sys

synth :: Audio -> Audio -> Audio
synth freq = osc where
    osc = sinOsc (440 + freq * (0 fby osc))

main :: IO ()
main = audioOut 0 synths where
    freq1  = mouseX `when` clockOf mouseClick
    freq2  = d2f Minor {0, 1, 2, sample mouseX, freq2} `when` pattern {0.25, 0.5, 0.25, 0.5}
    synths = poly synth (merge freq1 freq2)

-------------------------------------------------------
-- Thoughts about FRP stuff
-------------------------------------------------------
-- Problem is worse than you first realize:
   "Leaks" are inherent to several things, but one in particular is "switching" between streams
   Switching includes anything with branching, such if/else/then, guards, case statements, pattern matching, etc
-- This would mean that following Elerea monadic StreamGen interface all branching would have to return a StreamGen
-- Following the Phanton Types solution, everything in the arms of the branching expressions (then/else, or the case alternatives) would need to carry Rank-2 phantom types.
-- FrpNow! paper offers interesting ideas but only sets up a semantics that aren't INHERENTLY leaky, but can still allow leaks in user code (and it's not that hard to do from what I've read).
   Not good enough
-- In general I feel like FRP is trying to solve problems in the MOST general way (First class streams, Dynamic Higher-Order streams, etc),
   when I would actually prefer less complicated solutions that are either less general or require light amounts of black magic.
-- Someone basically invented an entire language for FRP and their solution was to pass around a unique stream of "allocation rights"
   that grant individual functions the ability to make dynamic networks....
   ....yes, really.........

-------------------------------------------------------
-- Sequence + Event + Lucid Synchrone Semantics, Take 4
-------------------------------------------------------
-- Basically Lucid Synchrone semantics are a good starting place
-- But it's actually too flexible/powerful in some ways and too weak an inflexible in other ways
-- The concepted of kinded clocks is useful.
-- Control structures as special cases of when/c_merge is useful
-- First class clocks and dependent kinding are less useful for us perhaps (is this true?)
-- We also need dynamic networks, but I believe we can achieve that with runtime black magic and not needing to distinguish pointwise functions from stateful functions
-- Given that setup it seems that perhaps patterns are what cause most issues in the language?
-- Most everything else is at the same rate

-- Possible Space leaks:
--     1. Single Producer, Double Consumers with different rates
--     2. The Long Feedback (This is a form of leak 1 actually)
--     3. Starting after time 0
-- Idea:
--     * We use clock types (or perhaps kinds) which tag all values in the language with a clock.
--     * Most of the language will "step" or "tick" with the same clock
--     * There are a few things in the language that do not follow the main clock: Sequences, The arguments to pattern, dynamic synths/networks spawned by poly
--     * This is because the arguments to pattern do not necessarily flow with this clock, Sequences have dynamic temporal behavior, synths have an unknown mapping to global time.
--     * Idea: Anything with an idiosyncratic clock behavior uses Rank-2 phantom types for their clock types.
--     * Type system enforces that clock types match
--     * This prevents values with phantom clocks from naively using things with concrete clocks which do not match.
--     * sample combinator allows communication between values running on different clocks, also translates the phantom clock type.
-- How this fixes the leaks:
--     1. The type system rules this out entire. Two consumers MUST share the same rate.
--        The sample combinator allows consumers of different rates to "sample" the current value of something asynchronously, which still maintains no leaks.
--     2. A specialized version of above, with the same solution: Pattern has different clocks for its arguments and result, thus feedback will require the sample combinator.
--     3. The constant tick

-- This also enforces that

-- Sequences are tree-like data structures that represent chained together streams
-- Can't be used directly, must be forced via combinators like pattern or seq.
-- Use phantom types, thus require usage of the sample combinator to use things outside of the sequence

-- fby differs from Sequences in that the value on the right has its global clock delayed by 1 sample
-- The reason this is OK for fby and not Sequences is because fby creates a deterministic and fixed 1 sample buffer size, wheras sequences are more dynamic.

-- Everything has two signatures: A regular type signature, and a temporal clock signature
-- If no clock signature is given it is assumed everything in the type signature shares one common polymorphic clock variable
-- Do we care about distinction between pointwise and stateful streams?!

poly       :: Num b => (a -> b)        -> Event a -> b
poly       :.          (forall c1. c1) -> c2      -> c2

pattern    :: Time            -> a               -> Event a
pattern    :. (forall c1. c1) -> (forall c2. c2) -> c3

seq        :: [a]             -> a -- reifies a Sequence into a Stream
seq        :. (forall c1. c1) -> c2

sample     :: a               -> a
sample     :. (forall c1. c1) -> c2

latch      :: Event a -> a
latch      :. c1      -> c2

mouseX     :: Float
mouseX     :. Sys

mouseClick :: Event ()
mouseClick :. Sys

audioOut   :: Int -> Audio -> IO ()
audioOut   :. Sys -> Sys   -> Sys

fby        :: a -> a -> a                   -- Deterministic 1 sample delay which maintains the same clock
c_merge    :: Bool -> a -> a -> a           -- Like if/then/else, but arms are on different clocks, therefore has lazier semantics
merge      :: Event a -> Event a -> Event a -- This is <> monoidal append for Events
on         :: a -> Event () -> Event a
take       :: Int -> a -> a

input keyword? -- i.e. One shot IO at the global scale run once on program start, useful for setting up executable environment

input pulseDemon <- loadBuffer "pulseDemon.aiff"
input mouseX     <- mouseXIn

synth :: Audio -> Audio -> Audio
synth freq = osc where
    osc = 440 * sample mouseX + freq * (0 `fby` osc) |> sinOsc

main :: IO ()
main = audioOut 0 synths where
    freq1  = mouseX `on` mouseClick
    freq2  = pattern (seq [0.25, 0.5, 0.25, 0.5]) (d2f minor <| seq [0, 1, 2, sample mouseX |> take 1, latch freq2])
    synths = poly synth (merge freq1 freq2)

-- Compare vanilla, if/then/else, fby, seq, pattern, poly temporal characteristics
-- b                       == {t,  f,  t,  f,  f}
-- x                       == {x0, x1, x2, x3, x4}
-- y                       == {y0, y1, y2, y3, y4}
-- if b then x else y      == {x0, y0, x1, y2, y3} -- Wouldn't this then require the arms of if/then/else and case to have the phantom type????
-- x fby y                 == {x0, y0, y1, y2, y3}
-- seq [x, y]              == {x0, x1, x2, x3, x4, y0, y1, y2, y3, y4, x0,...}
-- pattern 0.5 x           == {x0, _,  x1, _,  x2}
-- poly id (pattern 0.5 x) =  {x0, x1, x0 + x2, x1 + x3, x0 + x2 + x4,...}