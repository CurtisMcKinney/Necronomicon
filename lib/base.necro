--------------------
-- Necro.Base
--------------------

-- -- TODO: Move into tests!
-- data ETest1 a     = ETest1 (Maybe a)
-- data ETest2 a     = ETest2 (Bool, Maybe a)
-- data ETest3 a     = ETest3 (Maybe (Bool, Maybe a))
-- data T3feri a b c = T3feri (a, a) (b, b) (c, c)
-- data HKT  t a     = HKT  (t a)
-- data HTest  a b   = HTest (Maybe a) (Maybe b) (Either a b)
-- data HKT2 t a b   = HKT2 (t a b)

testAssertion :: Bool -> *World -> *World
testAssertion b w = primUndefined

panic :: UInt -> UInt
panic x = primUndefined

-- boundsCheck :: Array n Char -> UInt -> UInt -> UInt
-- boundsCheck str index capacity =
--   if index < capacity then index else
--     index
--     |> traceLn "bounds check FAILED:"
--     |> trace "| "
--     |> traceLn str
--     |> trace "| index:    "
--     |> traceLn index
--     |> trace "| capacity: "
--     |> traceLn capacity
--     |> traceLn " "
--     |> panic

-- testAndPrintAssertion :: (Print a, Eq a) => a -> a -> *World -> *World
-- testAndPrintAssertion x y w = testAssertion (x == y) <| printLn x w

boolToInt :: Bool -> Int
boolToInt b = primUndefined

id :: .a -> .a
id x = x

fst :: (.a, .b) -> .a
fst (x, _) = x

snd :: (.a, .b) -> .b
snd (_, y) = y

fst' :: (#.a, .b#) -> .a
fst' (#x, _#) = x

snd' :: (#.a, .b#) -> .b
snd' (#_, y#) = y

fst3 :: (.a, .b, .c) -> .a
fst3 (x, _, _) = x

snd3 :: (.a, .b, .c) -> .b
snd3 (_, y, _) = y

thd3 :: (.a, .b, .c) -> .c
thd3 (_, _, z) = z

-- We're uh....hitting stack overflow...
-- fst3' :: (#.a, .b, .c#) -> .a
-- fst3' (#x, _, _#) = x

-- snd3' :: (#.a, .b, .c#) -> .b
-- snd3' (#_, y, _#) = y

thd3' :: (#.a, .b, .c#) -> .c
thd3' (#_, _, z#) = z

flip :: .(.a -> .b -> .c) -> .b -> .a -> .c
flip f y x = f x y

-- TODO: Fold into Ord class
min :: Ord a => a -> a -> a
min x y =
  if x < y then
    x
  else
    y

-- TODO: Fold into Ord class
max :: Ord a => a -> a -> a
max x y =
  if x > y then
    x
  else
    y

uncurry :: .(.a -> .b -> .c) -> (.a, .b) -> .c
uncurry f (x, y) = f x y

uncurry3 :: .(.a -> .b -> .c -> .d) -> (.a, .b, .c) -> .d
uncurry3 f (x, y, z) = f x y z

uncurry' :: .(.a -> .b -> .c) -> (#.a, .b#) -> .c
uncurry' f (#x, y#) = f x y

uncurry3' :: .(.a -> .b -> .c -> .d) -> (#.a, .b, .c#) -> .d
uncurry3' f (#x, y, z#) = f x y z

mouseX :: Int
mouseX = getMouseX ()

mouseY :: Int
mouseY = getMouseY ()


----------------------
-- Bool
----------------------
data Bool = False | True

-- TODO: primitive for not
not :: .Bool -> .Bool
not b =
  case b of
    True  -> False
    False -> True


----------------------
-- Some Base Classes
----------------------

class Print a where
  print :: a -> *World -> *World

class Semigroup m where
  append :: m -> m -> m

class Semigroup m => Monoid m where
  mempty :: m

class Functor f where
  map :: (a -> b) -> f a -> f b

class UFunctor f where
  umap :: .(.a -> .b) -> f .a -> f .b

class FunctorN f where
  map2 :: (a -> b -> c) -> f a -> f b -> f c
  map3 :: (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  map4 :: (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
  -- TODO: map4, etc

class Functor f => Applicative f where
  pure :: a -> f a
  ap   :: f (a -> b) -> f a -> f b

class Applicative m => Monad m where
  bind :: m a -> (a -> m b) -> m b

class Applicative f => Alternative f where
  empty       :: f a
  alternative :: f a -> f a -> f a

class Enum a where
  toEnum   :: Int -> a
  fromEnum :: a -> Int

class Foldable f where
  fold   :: Monoid m => f m -> m
  foldl  :: (.b -> .a -> .b) -> .b -> f .a -> .b

class Eq a where
  eq  :: a -> a -> Bool
  neq :: a -> a -> Bool

class Eq a => Ord a where
  lt  :: a -> a -> Bool
  gt  :: a -> a -> Bool
  lte :: a -> a -> Bool
  gte :: a -> a -> Bool

class Default a where
  default :: a

printUInt :: UInt -> *World -> *World
printUInt u w = w

printInt :: Int -> *World -> *World
printInt i w = w

printFloat :: Float -> *World -> *World
printFloat i w = w

printChar :: Char -> *World -> *World
printChar c w = w

printNewline :: *World -> *World
printNewline w = printChar '\n' w

instance Print UInt where
  print x w = printUInt x w

instance Print Int where
  print x w = printInt x w

instance Print Float where
  print x w = printFloat x w

instance Print Char where
  print x w = printChar x w

printLn :: Print a => a -> *World -> *World
printLn x w =
  printNewline (print x w)

trace :: Print a => a -> .b -> .b
trace x y =
  case print x primUndefined of
    _ -> y

traceLn :: Print a => a -> .b -> .b
traceLn x y =
  case printLn x primUndefined of
    _ -> y


----------------------
-- Numeric Hierarchy
----------------------
class Semiring a where
  zero :: a
  one  :: a
  add  :: a -> a -> a
  mul  :: a -> a -> a

class Semiring a => Ring a where
  sub     :: a -> a -> a
  fromInt :: Int -> a

class Ring a => DivisionRing a where
  recip :: a -> a

class Ring a => EuclideanRing a where
  div :: a -> a -> a
  rem :: a -> a -> a
  -- mod :: a -> a -> a

class (EuclideanRing a, DivisionRing a) => Field a where

class (Eq a, Ring a) => Num a where
  abs      :: a -> a
  signum   :: a -> a
  copysign :: a -> a -> a

class (Num a, EuclideanRing a) => Integral a where
  -- quotient :: a -> a -> a

class (Num a, Field a) => Floating a where
  fromFloat :: Float -> a
  sqrt :: a -> a
  floor :: a -> a
  ceil :: a -> a
  truncate :: a -> a
  round :: a -> a
  -- fmin :: a -> a -> a -- TODO: Remove these for Ord instances once min/max is in Ord
  -- fmax :: a -> a -> a

class Floating a => Trig a where
  sine     :: a -> a
  cosine   :: a -> a
  -- tan      :: a -> a
  -- asine    :: a -> a
  -- acosine  :: a -> a
  -- atan     :: a -> a
  -- atan2    :: a -> a -> a
  sinh     :: a -> a
  -- cosineh  :: a -> a
  -- tanh     :: a -> a
  -- asineh   :: a -> a
  -- acosineh :: a -> a
  -- atanh    :: a -> a
  -- atanh2   :: a -> a -> a
  exp      :: a -> a
  exp2     :: a -> a
  log      :: a -> a
  log10    :: a -> a
  log2     :: a -> a
  pow      :: a -> a -> a

  -- atan      :: a -> a
  -- floor'    :: Integral b => a -> b
  -- ceil'     :: Integral b => a -> b

-- toFloating :: (Num' a, Floating b) => a -> b
-- toFloating = fromRational' <. toRational


----------------------------------------
-- Trig Approximation Functions
----------------------------------------

-- -- How to deal with Float maybe 64 vs 32 bit?
-- tanF32 :: Float -> Float
-- tanF32 n = tanResult
--   where
--     x = rem n twoPi
--     octant = floor <| (x * fourOverPi)
--     -- HACK -> Need to be able to convert from Float to
--     octantInt = if octant < 1 then 0
--       else if octant < 2 then 1
--       else if octant < 3 then 2
--       else if octant < 4 then 3
--       else if octant < 5 then 4
--       else if octant < 6 then 5
--       else if octant < 7 then 6
--       else 7
--     -- Accurate to about 8.2 decimal digits over the range (0, pi/4)
--     -- This computes tan (pi * x/4), range reduction must be used before input
--     tan82 x = (x * (c1 + c2 * x2) / (c3 + x2 * (c4 + x2)))
--       where
--         c1 = 211.849369664121
--         c2 = -12.5288887278448
--         c3 = 269.7350131214121
--         c4 = -71.4145309347748
--         x2 = (x * x)
--     tanResult = case octantInt of
--       0 -> tan82 (x * fourOverPi)
--       1 -> 1 / (tan82 ((halfPi - x) * fourOverPi))
--       2 -> -1 / (tan82 ((x - halfPi) * fourOverPi))
--       3 -> negate <| tan82 ((pi - x) * fourOverPi)
--       4 -> tan82 ((x - pi) * fourOverPi)
--       5 -> 1 / (tan82 ((threeHalfPi - x) * fourOverPi))
--       6 -> -1 / (tan82 ((x - threeHalfPi) * fourOverPi))
--       7 -> negate <| tan82 ((twoPi - x) * fourOverPi)
--       _ -> 0 -- ?!?

tanF64 :: Float -> Float
tanF64 n = tanResult
  where
    wrappedN = rem n twoPi
    twoPiN = twoPi + wrappedN
    x = if wrappedN < 0 then twoPiN else wrappedN
    -- TODO: investigate alternatives like masking etc..
    -- signMask = bitShiftRightA wrappedN 63
    -- x = wrappedN + (bitAnd (twoPi - wrappedN - wrappedN) signMask)
    -- x = rem wrappedN twoPi
    octant = truncateToInt <| (x * fourOverPi)
    -- Accurate to about 14 decimal digits over the range (0, pi/4)
    -- This computes tan (pi * x/4), range reduction must be used before input
    tan14s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = -34287.4662577359568109624
        c2 = 2566.7175462315050423295
        c3 = -26.5366371951731325438
        c4 = -43656.1579281292375769579
        c5 = 12244.4839556747426927793
        c6 = -336.611376245464339493
        x2 = (x * x)
    tanResult = case octant of
      0 -> tan14s (x * fourOverPi)
      1 -> 1 / (tan14s ((halfPi - x) * fourOverPi))
      2 -> -1 / (tan14s ((x - halfPi) * fourOverPi))
      3 -> negate <| tan14s ((pi - x) * fourOverPi)
      4 -> tan14s ((x - pi) * fourOverPi)
      5 -> 1 / (tan14s ((threeHalfPi - x) * fourOverPi))
      6 -> -1 / (tan14s ((x - threeHalfPi) * fourOverPi))
      7 -> negate <| tan14s ((twoPi - x) * fourOverPi)
      _ -> 0 -- ?!?


-- create a scalar for branchless selection if x > y
scalarIfGreaterThan :: Float -> Float -> Float
scalarIfGreaterThan x y = bitAnd subtractionMask 1
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF
    subtractionMask = bitShiftRightA subtractionSign 63

-- create a mask (0xFFFFFFFFFFFFFFFF or 0x0000000000000000) for branchless masking if x > y
maskIfGreaterThan :: Float -> Float -> Float
maskIfGreaterThan x y = bitShiftRightA subtractionSign 63
  where
    subtraction = y - (x + f64Epsilon)
    subtractionSign = bitAnd subtraction iEEESignMaskF

-- branchless 64 bit atan
atanF64 :: Float -> Float
atanF64 n = copysign z n
  where
    absN = bitAnd n (bitNot iEEESignMaskF)
    -- absN = abs n
    -- complement = absN > 1
    -- complementCon = if complement then allBitsF else 0
    -- Set sign bit if absN > 1
    complement = bitAnd (1 - (absN + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    complementCon = bitShiftRightA complement 63
    -- x = if complement then 1 / absN else absN
    x = (bitAnd complementCon (1 / absN)) + (bitAnd absN (bitNot complementCon))
    -- region = x > tanTwelthPi
    -- regionCon = if region then 1 else 0
    -- Set sign bit if x > tanTwelthPi
    region = bitAnd (tanTwelthPi - (x + f64Epsilon)) iEEESignMaskF
    -- right fill to get mask
    regionMask = bitShiftRightA region 63
    -- create scalar from mask for selection
    regionCon = bitAnd regionMask 1
    -- x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    x' = (x - (tanSixthPi * regionCon)) / (1 + (tanSixthPi * x * regionCon))
    -- y = if region then atan137s + sixthPi else atan137s
    y = atan137s + (sixthPi * regionCon)
    -- z = if complement then halfPi - y else y
    z = y + (bitAnd complementCon (halfPi - y - y))
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s = (x' * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x' * x'

slowAtanF64 :: Float -> Float
slowAtanF64 n = if sign then negate z else z
  where
    sign = n < 0
    absN = abs n
    complement = absN > 1
    x = if complement then 1 / absN else absN
    region = x > tanTwelthPi
    x' = if region then (x - tanSixthPi) / (1 + tanSixthPi * x) else x
    y = if region then atanX + sixthPi else atanX
    z = if complement then halfPi - y else y
    atanX = atan137s x'
    -- Accurate to about 13.7 decimal digits over the range [0, pi/12].
    atan137s x = (x * (c1 + x2 * (c2 + x2 * c3)) / (c4 + x2 * (c5 + x2 * (c6 + x2))))
      where
        c1 = 48.70107004404898384
        c2 = 49.5326263772254345
        c3 = 9.40604244231624
        c4 = 48.70107004404996166
        c5 = 65.7663163908956299
        c6 = 21.587934067020262
        x2 = x * x
----------------------------------------

class Bits a where
  bitAnd         :: a -> a -> a
  bitNot         :: a -> a
  bitOr          :: a -> a -> a
  bitXor         :: a -> a -> a
  bitShiftLeft   :: a -> UInt -> a
  bitShiftRight  :: a -> UInt -> a -- logical right shift
  bitShiftRightA :: a -> UInt -> a -- arithmetic right shift
  bitReverse     :: a -> a
  toBits         :: a -> UInt
  fromBits       :: UInt -> a

sqr :: Semiring a => a -> a
sqr n = n * n

--------------------
-- ()
--------------------
-- TODO: Can't currently parse () in an instance head!
-- instance Eq () where
--   eq  _ _ = True
--   neq _ _ = False
--
-- instance Ord () where
--   lt  _ _ = False
--   gt  _ _ = False
--   lte _ _ = True
--   gte _ _ = True


--------------------
-- Bool
--------------------
instance Eq Bool where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Bool where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

instance Semiring Bool where
  zero    = False
  one     = True
  add x y = x || y
  mul x y = x && y

instance Semigroup Bool where
  append x y = x || y

instance Monoid Bool where
  mempty = False

instance Default Bool where
  default = True


--------------------
-- Int
--------------------
instance Eq Int where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Int where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Int where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Int where
  sub   x y = primUndefined
  fromInt x = x

instance EuclideanRing Int where
  div x y = primUndefined
  rem x y = primUndefined

instance Num Int where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x sign = (abs x) * (signum sign)

instance Integral Int where

instance Semigroup Int where
  append x y = x + y

instance Monoid Int where
  mempty = 0

instance Default Int where
  default = 0


--------------------
-- UInt
-- NOTE: that this is the traditional programming language concept of an unsigned integer (with its idiosyncrasies) and not the more mathematically defined set of Natural Numbers
--------------------
instance Eq UInt where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord UInt where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring UInt where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring UInt where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance EuclideanRing UInt where
  div x y = primUndefined
  rem x y = primUndefined

instance Num UInt where
  abs    x = primUndefined
  signum x = primUndefined
  copysign x _ = x

instance Integral UInt where

instance Bits UInt where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = x
  fromBits       x   = x

instance Semigroup UInt where
  append x y = x + y

instance Monoid UInt where
  mempty = 0

instance Default UInt where
  default = 0

--------------------
-- Float
--------------------
instance Eq Float where
  eq  x y = primUndefined
  neq x y = primUndefined

instance Ord Float where
  lt  x y = primUndefined
  gt  x y = primUndefined
  lte x y = primUndefined
  gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring Float where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring Float where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num Float where
  abs    x = primUndefined
  copysign x sign = primUndefined
  signum x = copysign 1 x

instance EuclideanRing Float where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing Float where
  recip x = 1 / x

instance Field Float where

instance Floating Float where
  fromFloat x = x
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined
  -- fmin      x y = primUndefined
  -- fmax      x y = primUndefined

instance Trig Float where
  sine   x = primUndefined
  cosine x = primUndefined
  sinh   x = primUndefined
  exp    x = primUndefined
  exp2   x = primUndefined
  log    x = primUndefined
  log10  x = primUndefined
  log2   x = primUndefined
  pow  x y = primUndefined

instance Bits Float where
  bitAnd         x y = primUndefined
  bitNot         x   = primUndefined
  bitOr          x y = primUndefined
  bitXor         x y = primUndefined
  bitShiftLeft   x y = primUndefined
  bitShiftRight  x y = primUndefined
  bitShiftRightA x y = primUndefined
  bitReverse     x   = primUndefined
  toBits         x   = primUndefined
  fromBits       x   = primUndefined

instance Semigroup Float where
  append x y = x + y

instance Monoid Float where
  mempty = 0

instance Default Float where
  default = 0

negate :: Ring a => a -> a
negate x = 0 - x

floatToUInt :: Float -> UInt
floatToUInt x = primUndefined

-- f64ToUInt :: F64 -> UInt
-- f64ToUInt x = primUndefined

-- --------------------
-- -- F64
-- --------------------
-- instance Eq F64 where
--   eq  x y = primUndefined
--   neq x y = primUndefined
--
-- instance Ord F64 where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined
--
-- -- TODO: prim zero / one instances
-- instance Semiring F64 where
--   zero    = primUndefined
--   one     = primUndefined
--   add x y = primUndefined
--   mul x y = primUndefined
--
-- instance Ring F64 where
--   sub   x y = primUndefined
--   fromInt x = primUndefined
--
-- instance Num F64 where
--   abs    x = primUndefined
--   copysign x sign = primUndefined
--   signum x = copysign 1 x
--
-- instance EuclideanRing F64 where
--   div x y = primUndefined
--   rem x y = primUndefined
--
-- instance DivisionRing F64 where
--   recip x = 1 / x
--
-- instance Field F64 where
--
-- instance Floating F64 where
--   fromFloat x = primUndefined
--   sqrt      x = primUndefined
--   floor     x = primUndefined
--   ceil      x = primUndefined
--   truncate  x = primUndefined
--   round     x = primUndefined
--   -- fmin      x y = primUndefined
--   -- fmax      x y = primUndefined
--
-- instance Trig F64 where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined
--
-- instance Bits F64 where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined
--
-- instance Semigroup F64 where
--   append x y = x + y
--
-- instance Monoid F64 where
--   mempty = 0
--
-- instance Default F64 where
--   default = 0

fastFloor :: Float -> Float
fastFloor x = primUndefined

-- floor :: F64 -> F64
-- floor x = primUndefined
--
-- ceil :: F64 -> F64
-- ceil x = primUndefined
--
-- truncate :: F64 -> F64
-- truncate x = primUndefined
--
-- round :: F64 -> F64
-- round x = primUndefined
--
-- copysign :: F64 -> F64 -> F64
-- copysign x sign = primUndefined
--
-- fmin :: F64 -> F64 -> F64
-- fmin x y = primUndefined
--
-- fmax :: F64 -> F64 -> F64
-- fmax x y = primUndefined

floorToInt :: Float -> Int
floorToInt x = primUndefined

ceilToInt :: Float -> Int
ceilToInt x = primUndefined

truncateToInt :: Float -> Int
truncateToInt x = primUndefined

roundToInt :: Float -> Int
roundToInt x = primUndefined

fma :: Float -> Float -> Float -> Float
fma x y z = primUndefined

------------------------------------------------------------
-- iEEE 754 Double Precision Float Format constants
------------------------------------------------------------
iEEESignMask :: UInt
iEEESignMask = bitShiftLeft 1 63

iEEESignMaskF :: Float
iEEESignMaskF = fromBits iEEESignMask

iEEENumExponentBits :: UInt
iEEENumExponentBits = 11

iEEENumSignificandBits :: UInt
iEEENumSignificandBits = 52

iEEEExponentMask :: UInt
iEEEExponentMask = bitShiftLeft (-1) iEEENumSignificandBits |> bitAnd (bitNot iEEESignMask)

iEEEExponentMaskF :: Float
iEEEExponentMaskF = fromBits iEEEExponentMask

iEEESignificandMask :: UInt
iEEESignificandMask = bitAnd (-1) (bitNot (bitOr iEEEExponentMask iEEESignMask))

iEEESignificandMaskF :: Float
iEEESignificandMaskF = fromBits iEEESignificandMask

allBits :: UInt
allBits = -1

allBitsF :: Float
allBitsF = fromBits allBits

f64EpsilonU :: UInt
f64EpsilonU = 4372995238176751616

f64Epsilon :: Float
f64Epsilon = fromBits f64EpsilonU


--------------------
-- FloatVec
--------------------

--TODO: insertelement
--TODO: extractelement

-- TODO: Finish!
instance Eq (FloatVec n) where
  eq  x y = primUndefined
  neq x y = primUndefined

-- instance Ord (FloatVec n) where
--   lt  x y = primUndefined
--   gt  x y = primUndefined
--   lte x y = primUndefined
--   gte x y = primUndefined

-- TODO: prim zero / one instances
instance Semiring (FloatVec n) where
  zero    = primUndefined
  one     = primUndefined
  add x y = primUndefined
  mul x y = primUndefined

instance Ring (FloatVec n) where
  sub   x y = primUndefined
  fromInt x = primUndefined

instance Num (FloatVec n) where
  abs      x      = primUndefined
  copysign x sign = primUndefined
  signum   x      = copysign 1 x

instance EuclideanRing (FloatVec n) where
  div x y = primUndefined
  rem x y = primUndefined

instance DivisionRing (FloatVec n) where
  recip x = 1 / x

instance Field (FloatVec n) where

instance Floating (FloatVec n) where
  fromFloat x = primUndefined
  sqrt      x = primUndefined
  floor     x = primUndefined
  ceil      x = primUndefined
  truncate  x = primUndefined
  round     x = primUndefined
  -- fmin      x y = primUndefined
  -- fmax      x y = primUndefined

-- instance Trig (FloatVec n) where
--   sine   x = primUndefined
--   cosine x = primUndefined
--   sinh   x = primUndefined
--   exp    x = primUndefined
--   exp2   x = primUndefined
--   log    x = primUndefined
--   log10  x = primUndefined
--   log2   x = primUndefined
--   pow  x y = primUndefined

-- instance Bits (FloatVec n) where
--   bitAnd         x y = primUndefined
--   bitNot         x   = primUndefined
--   bitOr          x y = primUndefined
--   bitXor         x y = primUndefined
--   bitShiftLeft   x y = primUndefined
--   bitShiftRight  x y = primUndefined
--   bitShiftRightA x y = primUndefined
--   bitReverse     x   = primUndefined
--   toBits         x   = primUndefined
--   fromBits       x   = primUndefined

instance Semigroup (FloatVec n) where
  append x y = x + y

instance Monoid (FloatVec n) where
  mempty = 0

instance Default (FloatVec n) where
  default = 0

-- floatVecInsert :: Index n -> Float -> FloatVec n -> FloatVec n
-- floatVecInsert i f v = primUndefined

-- floatVecExtract :: Index n -> FloatVec n -> Float
-- floatVecExtract i v = primUndefined

toFloatVecArray :: .Array n Float -> .Array (NatDiv n vn) (FloatVec vn)
toFloatVecArray a = primUndefined

fromFloatVecArray ::  .Array (NatDiv n vn) (FloatVec vn) -> .Array n Float
fromFloatVecArray v = primUndefined


--------------------
-- Rational
--------------------
-- TODO: I64 on 32-bit breaks during JIT due to not linking against ___divdi3 and the like
-- TODO: Proper Fraction
-- TODO: More efficient gcd algorithm
data Rational = Rational# Int Int

gcd :: Int -> Int -> Int
gcd x y =
  fst' <| loop (#a, b#) = (#abs x, abs y#) while b > 0 do
    (#b, a % b#)

reduce :: Int -> Int -> Rational
reduce x y =
  Rational# (x / d) (y / d)
  where
    d = gcd x y

rational :: Int -> Int -> Rational
rational x y = reduce (x * signum y) (abs y)

numerator :: Rational -> Int
numerator (Rational# n _) = n

denominator :: Rational -> Int
denominator (Rational# _ d) = d

instance Eq Rational where
  eq  (Rational# xn xd) (Rational# yn yd) = eq (xn * yd) (yn * xd)
  neq (Rational# xn xd) (Rational# yn yd) = neq (xn * yd) (yn * xd)

instance Ord Rational where
  lt  (Rational# xn xd) (Rational# yn yd) = lt  (xn * yd) (yn * xd)
  lte (Rational# xn xd) (Rational# yn yd) = lte (xn * yd) (yn * xd)
  gt  (Rational# xn xd) (Rational# yn yd) = gt  (xn * yd) (yn * xd)
  gte (Rational# xn xd) (Rational# yn yd) = gte (xn * yd) (yn * xd)

instance Semiring Rational where
  zero = Rational# 0 1
  one  = Rational# 1 1
  add (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd + yn * xd) (xd * yd)
  mul (Rational# xn xd) (Rational# yn yd) = reduce (xn * yn) (xd * yd)

instance Ring Rational where
  sub (Rational# xn xd) (Rational# yn yd) = reduce (xn * yd - yn * xd) (xd * yd)
  fromInt x                               = Rational# (fromInt x) 1

instance Num Rational where
  abs    (Rational# xn xd) = Rational# (abs xn) xd
  signum (Rational# xn _)  = Rational# (signum xn) 1
  copysign (Rational# xn xd) (Rational#  yn _) = Rational# (copysign xn yn) (abs xd)

instance DivisionRing Rational where
  recip (Rational# n d) =
    if n == 0 then
      Rational# 0 1
    else
      d // n

instance EuclideanRing Rational where
  rem x y = primUndefined
  div x y = x * recip y

instance Field Rational where

instance Semigroup Rational where
  append x y = x + y

instance Monoid Rational where
  mempty = 0

instance Default Rational where
  default = 0

rationalToFloat :: Rational -> Float
rationalToFloat r = fromInt (numerator r) / fromInt (denominator r)


--------------------
-- Complex
--------------------
data Complex = Complex# Float Float

realPart :: Complex -> Float
realPart (Complex# r _) = r

imagPart :: Complex -> Float
imagPart (Complex# _ i) = i

mkPolar :: Float -> Float -> Complex
mkPolar r theta = Complex# (r * cosine theta) (r * sine theta)

cis :: Float -> Complex
cis theta = Complex# (cosine theta) (sine theta)

polar :: Complex -> (Float, Float)
polar c = (magnitude c, phase c)

sqrMagnitude :: Complex -> Float
sqrMagnitude (Complex# r i) = (r * r) + (i * i)

magnitude :: Complex -> Float
magnitude (Complex# r i) = sqrt ((r * r) + (i * i))

conjugate :: Complex -> Complex
conjugate (Complex# r i) = Complex# r (negate i)

phase :: Complex -> Float
phase c = primUndefined
-- TODO: ADD ATAN2!
-- phase (Complex# r i) = atan2 r i

instance Eq Complex where
  eq  (Complex# rx ix) (Complex# ry iy) = rx == ry && ix == iy
  neq (Complex# rx ix) (Complex# ry iy) = rx /= ry || ix /= iy

instance Semiring Complex where
  zero                                  = Complex# 0 0
  one                                   = Complex# 1 0
  add (Complex# rx ix) (Complex# ry iy) = Complex# (rx + ry) (ix + iy)
  mul (Complex# rx ix) (Complex# ry iy) = Complex# (rx * ry - ix * iy) (rx * iy + ix * ry)

instance Ring Complex where
  sub (Complex# rx ix) (Complex# ry iy) = Complex# (rx - ry) (ix - iy)
  fromInt z                             = Complex# (fromInt z) 0

instance EuclideanRing Complex where
  div x y = Complex# (zx / yIntoConjugate) (zi / yIntoConjugate)
    where
      conjugateY     = conjugate y
      yIntoConjugate = y * conjugateY |> realPart
      Complex# zx zi = x * conjugateY
  rem x y = x - y * w
    where
      z = x / y
      w = case z of
        Complex# rz iz -> Complex# (floor rz) (floor iz)

instance DivisionRing Complex where
  recip (Complex# r i) = Complex# (r / sqrRsqrI) (negate (i / sqrRsqrI))
    where
      sqrRsqrI = (r * r) + (i * i)

instance Num Complex where
  abs z    = Complex# (magnitude z) 0
  signum z =
    case z of
      Complex# r i ->
        if r == 0 && i == 0 then 0 else
          let m = magnitude z in
            Complex# (r / m) (i / m)
  copysign x sign = (abs x) * (signum sign) -- Note: unsure if this is well founded or not?

instance Field Complex where

instance Floating Complex where
  fromFloat f = Complex# (fromFloat f) 0
  sqrt z = case z of
    Complex# r i ->
      if r == 0 then
        let
          u = sqrt ((abs i) / r)
          v = if i < 0 then negate u else u
        in
          Complex# u v
      else
        let
          u = sqrt (2 * (magnitude z + abs r))
          v = u / 2
        in
          if r > 0 then
            Complex# v (i / u)
          else
            let
              vByI = if i < 0 then negate v else v
            in
              Complex# ((abs i) / u) vByI
  floor     (Complex# r i) = Complex# (floor r) (floor i)
  ceil      (Complex# r i) = Complex# (ceil r) (ceil i)
  truncate  (Complex# r i) = Complex# (truncate r) (truncate i)
  round     (Complex# r i) = Complex# (round r) (round i)
  -- fmin      x y = if (magnitude x < magnitude y) then x else y -- TODO: brancless versions?
  -- fmax      x y = if (magnitude x > magnitude y) then x else y

-- TODO - ADD SINEH and COSINEH
-- instance Trig Complex where
--   sine (Complex# r, i) = Complex# (sine r * cosineh i) (cosine r * sineh i)
--   cosine (Complex# r i) = Complex# (cosine r * cosineh i) (negate (sine r) * sineh i)
--   exp    :: a -> a
--   exp2   :: a -> a
--   log    :: a -> a
--   log10  :: a -> a
--   log2   :: a -> a
--   pow    :: a -> a -> a

--------------------
-- Maybe
--------------------
data Maybe a = Just a | Nothing

nothing :: Maybe a
nothing = Nothing

instance Eq a => Eq (Maybe a) where
  eq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> True
          _       -> False

      Just x ->
        case my of
          Nothing -> False
          Just y  -> eq x y
  neq mx my =
    case mx of
      Nothing ->
        case my of
          Nothing -> False
          _       -> True

      Just x ->
        case my of
          Nothing -> True
          Just y  -> neq x y

instance Default (Maybe a) where
  default = nothing

instance Semigroup a => Semigroup (Maybe a) where
  append mx my =
    case mx of
      Nothing -> my
      Just x  ->
        case my of
          Nothing -> mx
          Just y  -> Just (append x y)

instance Monoid (Maybe a) where
  mempty = nothing

instance Functor Maybe where
  map f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> nothing

instance UFunctor Maybe where
  umap f m =
    case m of
      Just x  -> Just (f x)
      Nothing -> Nothing

instance FunctorN Maybe where
  map2 f mx my =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            Just (f x y)
  map3 f mx my mz =
    case mx of
      Nothing -> nothing
      Just x  ->
        case my of
          Nothing -> nothing
          Just y  ->
            case mz of
              Nothing -> nothing
              Just z  ->
                Just (f x y z)
  map4 f mw mx my mz =
    case mw of
      Nothing -> nothing
      Just w  ->
        case mx of
          Nothing -> nothing
          Just x  ->
            case my of
              Nothing -> nothing
              Just y  ->
                case mz of
                  Nothing -> nothing
                  Just z  ->
                    Just (f w x y z)

instance Applicative Maybe where
  pure x   = Just x
  ap mf mx =
    case mf of
      Nothing -> nothing
      Just f  ->
        case mx of
          Nothing -> nothing
          Just x  -> Just (f x)

instance Alternative Maybe where
  empty           = nothing
  alternative x y =
    case x of
      Nothing -> y
      Just _  -> x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
maybe :: .b -> .(.a -> .b) -> Maybe .a -> .b
maybe defaultValue f m =
  case m of
    Nothing -> defaultValue
    Just x  -> f x

-- This are wrong, wtf is going on? Is it parsing wrong? Is it inferring wrong?
fromMaybe :: .a -> Maybe .a -> .a
fromMaybe defaultValue m =
  case m of
    Nothing -> defaultValue
    Just x  -> x


--------------------
-- Either
--------------------
data Either a b = Left a | Right b

either :: .(.a -> .c) -> .(.b -> .c) -> Either .a .b -> .c
either lf rf e =
  case e of
    Left  lx -> lf lx
    Right rx -> rf rx


--------------------
-- Ptr
--------------------
ptrMalloc :: UInt -> Ptr *a
ptrMalloc capacity = primUndefined

ptrRealloc :: UInt -> Ptr *a -> Ptr *a
ptrRealloc capacity ptr = primUndefined

ptrFree :: Ptr .a -> *()
ptrFree ptr = primUndefined

-- unsafePtrPeek :: UInt -> *Ptr a -> (#a, *Ptr a#)
-- unsafePtrPeek index ptr = primUndefined

unsafePtrPoke :: UInt -> *a -> Ptr *a -> Ptr *a
unsafePtrPoke index value ptr = primUndefined

unsafePtrSwapElement :: UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
unsafePtrSwapElement index element ptr = primUndefined

-- unsafePtrPokeChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> Ptr *a
-- unsafePtrPokeChecked str capacity index value ptr =
--   unsafePtrPoke (boundsCheck str index capacity) value ptr

-- unsafePtrSwapElementChecked :: Array n Char -> UInt -> UInt -> *a -> Ptr *a -> (#*a, Ptr *a#)
-- unsafePtrSwapElementChecked str capacity index element ptr =
--   unsafePtrSwapElement (boundsCheck str index capacity) element ptr

-- TODO: Checked readArray and writeArray!

-- unsafeCastPtr :: *Ptr a -> *Ptr b
-- unsafeCastPtr = primUndefined


----------------------
-- MutRef: A hack to allow for recursively owned types...
----------------------
-- data MutRef a = MutRef (Ptr (Maybe a))

-- HACK / NOTE: mutRef expects the first argument to be CONSTANT (Need to support this concept in the type system...)
mutRef :: Maybe *a -> Ptr (Maybe *a)
mutRef x =
  primUndefined

mutRefTake :: (() -> *a) -> (#*a, Ptr (Maybe *a)#)
mutRefTake mkFn =
  case unsafePtrSwapElement 0 Nothing (mutRef Nothing) of
    (#mx, ptr1#) ->
      case mx of
        Just x  -> (#x, ptr1#)
        Nothing -> (#mkFn (), ptr1#)

mutRefPut :: *a -> Ptr (Maybe *a) -> ()
mutRefPut x ptr =
  case unsafePtrPoke 0 (Just x) ptr of
    _ -> ()


--------------------
-- Array
--------------------

-- TODO: Make range unboxed? Proper unboxed types? End constructor name with # to create unboxed type?
data Range  (n :: Nat) = Range# UInt UInt UInt
data Index  (n :: Nat) = Index UInt
data NatVal (n :: Nat) = NatVal

natVal :: NatVal n -> UInt
natVal n = primUndefined

mkRange :: UInt -> UInt -> NatVal n -> Range n
mkRange init inc end = Range# init inc (natVal end)

each :: Range n
each = mkRange 0 1 NatVal

unsafeEmptyArray :: () -> *Array n a
unsafeEmptyArray u = primUndefined

freezeArray :: *Array n a -> .Array n a
freezeArray a = primUndefined

readArray :: Index n -> Array n a -> a
readArray i a = primUndefined

readArrayU :: Index n -> Array n .a -> (#.a, Array n .a#)
readArrayU i a = primUndefined

writeArray :: Index n -> a -> *Array n a -> *Array n a
writeArray i x a = primUndefined

-- writeArrayChecked :: Array n Char -> UInt -> Index n -> a -> *Array n a -> *Array n a
-- writeArrayChecked str capacity (Index i) x a =
--   writeArray (Index (boundsCheck str capacity i)) x a

-- readArrayChecked :: Array n Char -> UInt -> Index n -> Array n a -> a
-- readArrayChecked str capacity (Index i) a =
--   readArray (Index (boundsCheck str capacity i)) a

instance Default a => Default (Array n a) where
  default = arrayFrom default

arrayFrom :: a -> .Array n a
arrayFrom x =
  freezeArray xa
  where
    xa =
      loop a = unsafeEmptyArray () for i <- each do
        writeArray i x a

instance Foldable (Array n) where
  fold a =
    loop x = mempty for i <- each do
      x <> readArray i a
  foldl f init a0 =
    fst' <| loop (#x, a1#) = (#init, a0#) for i <- each do
      case readArrayU i a1 of
        (#y, a2#) ->
          (#f x y, a2#)

--------------------
-- Index
--------------------
-- TODO: Hide Index constructor outside of base.necro for safety
-- TODO: Use Max to restrict UInt to range?
unsafeUIntToIndex :: UInt -> Index n
unsafeUIntToIndex i = Index i

indexToUInt :: Index n -> UInt
indexToUInt (Index i) = i

bitReverseIndex :: Index n -> Index n
bitReverseIndex (Index i) = Index (bitReverse i)

toIndexMultiple :: Index n -> Index (NatMul n (NatMax k 1))
toIndexMultiple (Index i) = Index i

sampleRate :: UInt
sampleRate = primUndefined

recipSampleRate :: Float
recipSampleRate = primUndefined

audioSampleRate :: UInt
audioSampleRate = 48000

audioBlockSize :: UInt
audioBlockSize = 256

audioOverSampleAmount :: UInt
audioOverSampleAmount = 24

audioRecipOverSampleRate :: Float
audioRecipOverSampleRate = recip <| fromUInt <| audioSampleRate * audioOverSampleAmount

-- audioBlockSize :: UInt
-- audioBlockSize = audioBlockSize' * audioOverSampleAmount

audioBlockSizeF :: Float
audioBlockSizeF = fromUInt audioBlockSize

-- audioSampleRate :: UInt
-- audioSampleRate = audioSampleRate' * audioOverSampleAmount

audioSampleRateF :: Float
audioSampleRateF = fromUInt audioSampleRate

audioBlocksPerSecond :: UInt
audioBlocksPerSecond = audioSampleRate / audioBlockSize

audioBlockDelta :: Rational
audioBlockDelta = 1 // fromUInt audioBlocksPerSecond

audioSampleDelta :: Rational
audioSampleDelta = 1 // fromUInt audioSampleRate

-- -- NOTE: Assumes audioBlockSize is a power of 2!
-- audioBlockSizeLog2 :: UInt
-- audioBlockSizeLog2 =
--   fst' <| loop (#bits, n#) = (#0, audioBlockSize#) while n > 0 do
--     (#bits + 1, bitShiftRight n 1#)

audioSampleOffset :: UInt
audioSampleOffset = 0


--------------------
-- Audio
--------------------
data Audio = AudioEnd | BlockRate Float | AudioRate (Array BlockSize Float)

outAudioBlock :: UInt -> Array BlockSize Float -> *World -> *World
outAudioBlock c a w = primUndefined

silentBlock :: Array BlockSize Float
silentBlock =
  fromFloatVecArray a
  where
    a :: Array (NatDiv BlockSize 32) (FloatVec 32)
    a = arrayFrom 0

outChannel :: UInt -> Audio -> *World -> *World
outChannel n c w =
  case c of
    AudioEnd    -> outAudioBlock n silentBlock w
    BlockRate _ -> outAudioBlock n silentBlock w
    AudioRate b -> outAudioBlock n b w

-- TODO / NOTE:
--     Take care when creating arrays for usage as audio buffers, they must be 64 BYTE aligned to allow for proper simd usage,
--     Thus audio buffers should always be created in the form:
--         Array (NatDiv BlockSize 32) (FloatVec 32)
--     and then cast to:
--         Array BlockSize Float
--     This will insure that the audio buffer is aligned properly by the llvm back end
audioInitArray :: () -> *Array BlockSize Float
audioInitArray u =
  snd' <| loop (#i, a#) = (#0, fromFloatVecArray ia#) while i < audioSampleOffset do
    (#i + 1, writeArray (Index i) 0 a#)
  where
    ia :: *Array (NatDiv BlockSize 32) (FloatVec 32)
    ia = unsafeEmptyArray ()

mapAudio :: (Float -> Float) -> Audio -> Audio
mapAudio f c =
  case c of
    AudioEnd    -> AudioEnd
    BlockRate x -> BlockRate (f x)
    AudioRate b ->
      AudioRate
      <| freezeArray
      <| loop a = audioInitArray () for i <- offsetToEndRange do
        writeArray i (f (readArray i b)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal

mapAudio2 :: (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2 f cx cy =
  case cx of
    AudioEnd    -> AudioEnd
    BlockRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y -> BlockRate (f x y)
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f x (readArray i y)) a
    AudioRate x ->
      case cy of
        AudioEnd    -> AudioEnd
        BlockRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) y) a
        AudioRate y ->
          AudioRate
          <| freezeArray
          <| loop a = ia for i <- offsetToEndRange do
            writeArray i (f (readArray i x) (readArray i y)) a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()

-- TODO: perc Env state in for loop
mapAudio2Vec :: (FloatVec 32 -> FloatVec 32 -> FloatVec 32) -> (Float -> Float -> Float) -> Audio -> Audio -> Audio
mapAudio2Vec f ff cx cy =
  case cx of
    AudioEnd     -> AudioEnd
    BlockRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' -> BlockRate (ff x' y')
        AudioRate y' ->
          let
            x = fromFloat x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f x (readArray i y)) a
    AudioRate x' ->
      case cy of
        AudioEnd     -> AudioEnd
        BlockRate y' ->
          let
            x = toFloatVecArray x'
            y = fromFloat y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) y) a
        AudioRate y' ->
          let
            x = toFloatVecArray x'
            y = toFloatVecArray y'
          in
            AudioRate
            <| freezeArray
            <| fromFloatVecArray
            <| loop a = ia for i <- each do
              writeArray i (f (readArray i x) (readArray i y)) a
  where
    ia = toFloatVecArray <| audioInitArray ()

constTrue :: a -> Bool
constTrue _ = True

constTrue' :: .a -> (#.a, Bool#)
constTrue' state = (#state, True#)

accumulateAudio1 :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio
accumulateAudio1 f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#s, a#) ->
          case isRunningFunc s of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio2 :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio
accumulateAudio2 f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#s, a#) ->
              case isRunningFunc s of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio3 :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3 f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#s, a#) ->
                  case isRunningFunc s of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out ~ (#default, primUndefined#) =
      case out of
        (#state, _#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
          in
            (#state', freezeArray o'#)

accumulateAudio1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio
accumulateAudio1U mkState f isRunningFunc input1 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case out of
        (#isRunning, a#) ->
          case isRunning of
            False -> AudioEnd
            _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f input1Val s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                    case f (readArray i input1Buffer) s of
                      (#s', x#) ->
                        (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)

accumulateAudio2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio
accumulateAudio2U mkState f isRunningFunc input1 input2 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case out of
            (#isRunning, a#) ->
              case isRunning of
                False -> AudioEnd
                _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f input1Val (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) input2Val s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                        case f (readArray i input1Buffer) (readArray i input2Buffer) s of
                          (#s', x#) ->
                            (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


accumulateAudio3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> Audio -> Audio -> Audio -> Audio
accumulateAudio3U mkState f isRunningFunc input1 input2 input3 =
  case input1 of
    AudioEnd -> AudioEnd
    _        ->
      case input2 of
        AudioEnd -> AudioEnd
        _        ->
          case input3 of
            AudioEnd -> AudioEnd
            _        ->
              case out of
                (#isRunning, a#) ->
                  case isRunning of
                    False -> AudioEnd
                    _     -> AudioRate a
  where
    offsetToEndRange = mkRange audioSampleOffset 1 NatVal
    ia               = audioInitArray ()
    out =
      case mutRefTake mkState of
        (#state, mref#) ->
          let
            (#state', o'#) =
              case input1 of
                AudioEnd -> (#state, ia#)
                BlockRate input1Val ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f input1Val (readArray i input2Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                AudioRate input1Buffer ->
                  case input2 of
                    AudioEnd -> (#state, ia#)
                    BlockRate input2Val ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) input2Val (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                    AudioRate input2Buffer ->
                      case input3 of
                        AudioEnd -> (#state, ia#)
                        BlockRate input3Val ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input2Buffer) input3Val s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
                        AudioRate input3Buffer ->
                          loop (#s, o#) = (#state, ia#) for i <- offsetToEndRange do
                            case f (readArray i input1Buffer) (readArray i input3Buffer) (readArray i input3Buffer) s of
                              (#s', x#) ->
                                (#s', writeArray i x o#)
            (#state'', isRunning#) = isRunningFunc state'
          in
            case mutRefPut state'' mref of
              _ -> (#isRunning, freezeArray o'#)


instance Eq Audio where
  eq x y =
    case x of
      AudioEnd ->
        case y of
          AudioEnd -> True
          _        -> False

      BlockRate xv ->
        case y of
          BlockRate yv -> xv == yv
          _            -> False

      AudioRate xa ->
        case y of
          AudioRate ya ->
            loop cond = True for i <- each do
              cond && readArray i xa == readArray i ya
          _ -> False

  neq x y = not (eq x y)

instance Semiring Audio where
  zero    = BlockRate 0
  one     = BlockRate 1
  add x y = mapAudio2Vec add add x y
  mul x y = mapAudio2Vec mul mul x y

instance Ring Audio where
  sub x y   = mapAudio2Vec sub sub x y
  fromInt i = BlockRate (fromInt i)

instance EuclideanRing Audio where
  div x y = mapAudio2 div x y
  rem x y = mapAudio2 rem x y

instance DivisionRing Audio where
  recip x = mapAudio recip x

instance Num Audio where
  signum x  = mapAudio signum x
  abs x     = mapAudio abs x
  copysign x sign = mapAudio2 copysign x sign

instance Field Audio where

instance Floating Audio where
  fromFloat f = BlockRate (fromFloat f)
  sqrt x      = mapAudio sqrt x
  floor     x = mapAudio floor x
  ceil      x = mapAudio ceil x
  truncate  x = mapAudio truncate x
  round     x = mapAudio round x
  -- fmin      x y = mapAudio fmin x y
  -- fmax      x y = mapAudio copysign x y

instance Semigroup Audio where
  append x y = x + y

instance Monoid Audio where
  mempty = 0

instance Default Audio where
  default = 0


--------------------
-- FFT
--------------------
-- https://www.dspguide.com/ch12/1.htm
-- FFT bins are represented as complex numbers wherein phase is encoded as the angle of a 2D vector and amplitude is encoded as the magnitude of the 2D vector.
data FFT k   = FFT (Array (NatMul BlockSize (NatMax k 1)) Complex)
data FFTWindow = FFTWindow (Array BlockSize Float)
-- TODO: FFT windowing!

uintToInt :: UInt -> Int
uintToInt x = primUndefined

fromUInt :: Ring a => UInt -> a
fromUInt x = fromInt (uintToInt x)

pi :: Floating a => a
pi = 3.1415926535897932384626433

twoPi :: Floating a => a
twoPi = pi * 2

twoOverPi :: Floating a => a
twoOverPi = 2 / pi

halfPi :: Floating a => a
halfPi = pi * 0.5

threeHalfPi :: Floating a => a
threeHalfPi = 3 * halfPi

fourOverPi :: Floating a => a
fourOverPi = 4 / pi

quarterPi :: Floating a => a
quarterPi = pi * 0.25

sixthPi :: Floating a => a
sixthPi = pi / 6

twelthPi :: Floating a => a
twelthPi = pi / 12

tanSixthPi :: Float
tanSixthPi = tanF64 sixthPi

tanTwelthPi :: Float
tanTwelthPi = tanF64 twelthPi

tau :: Floating a => a
tau = 2 * pi

recipPi :: Floating a => a
recipPi = 1 / pi

recipTau :: Floating a => a
recipTau = 1 / tau

recipTwoPi :: Floating a => a
recipTwoPi = recipTau

-- hanning :: FFTWindow
-- hanning =
--   FFTWindow <| freezeArray <| loop a = unsafeEmptyArray () for i <- each do
--     writeArray i (0.5 - 0.5 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt sampleRate)) a

-- hamming :: FFTWindow
-- hamming =
--   FFTWindow <| freezeArray <| loop a = unsafeEmptyArray () for i <- each do
--     writeArray i (0.54 - 0.46 * cosine (tau * fromUInt (indexToUInt i + 1) / fromUInt sampleRate)) a

-- -- TODO: Look more into this...
-- -- TODO: Shift right after bit reverse?
-- bitRevFFTArray :: Array BlockSize F64 -> FFTWindow -> *Array (NatMul BlockSize (NatMax k 1)) Complex
-- bitRevFFTArray audioBuffer (FFTWindow windowBuffer) =
--   loop a' = unsafeEmptyArray () for i <- each do
--     let
--       sample = readArray (bitReverseIndex i) audioBuffer
--       winval = readArray i windowBuffer
--       c      = Complex# (sample * winval) 0
--     in
--       writeArray (toIndexMultiple i) c a'

-- -- NOTE: bitReverse Cooley-Tukey FFT algorithm
-- -- TODO: Finish!
-- -- TODO: Compute log2n somehow
-- -- TODO: Windowing function!
-- fftAudio :: Array BlockSize F64 -> FFTWindow -> Array (NatMul BlockSize (NatMax 1 1)) Complex
-- fftAudio a w =
--   freezeArray <| snd' <|
--     loop (#i, a0#) = (#0, bitRevFFTArray a w#) while i < audioBlockSizeLog2 do
--       let
--         m1              = bitShiftLeft  1  i
--         m2              = bitShiftRight m1 1
--         wm              = 0 -- Compute somehow
--         (#_, _, aout1#) =
--           loop (#j, w, a1#) = (#0, 1, a0#) while j < m2 do
--             let
--               (#_, aout0#) =
--                 loop (#k, a2#) = (#j, a1#) while k < audioBlockSize do
--                   let
--                     ki        = Index k
--                     km2i      = Index (k + m2)
--                     (#t, a3#) = readArrayU km2i a2
--                     (#u, a4#) = readArrayU ki a3
--                     t'        = t * w
--                   in
--                     (#k + 1, writeArray km2i (u - t') (writeArray ki (u + t') a4)#)
--             in
--               (#j + 1, w * wm, aout0#)
--       in
--         (#i + 1, aout1#)

--------------------
-- AudioFormat
--------------------
data Mono a             = Mono a
data Stereo a           = Stereo# a a
data Quad a             = Quad# a a a a
data Ambisonic a        = Ambisonic# a a a a
data AudioBuffer s      = AudioBuffer (.Array (NatNextPowerOfTwo (NatMul SampleRate (NatMax s 1))) Float)
data Seconds (n :: Nat) = Seconds

-- TODO: Equal power panning
class (Functor f, FunctorN f, Applicative f, Foldable f) => AudioFormat f where
  accumulate1  :: Default s => (Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio
  accumulate2  :: Default s => (Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio
  accumulate3  :: Default s => (Float -> Float -> Float -> s -> (#s, Float#)) -> (s -> Bool) -> f Audio -> f Audio -> f Audio -> f Audio
  accumulate1U :: (() -> *s) -> (Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio
  accumulate2U :: (() -> *s) -> (Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio
  accumulate3U :: (() -> *s) -> (Float -> Float -> Float -> *s -> (#*s, Float#)) -> (*s -> (#*s, Bool#)) -> f Audio -> f Audio -> f Audio -> f Audio
  pan          :: Mono Audio -> f Audio -> Stereo Audio
  mixMono      :: Num a => f a -> Mono a
  mixStereo    :: Num a => f a -> Stereo a
  outAudio     :: UInt -> f Audio -> *World -> *World

stereo :: Mono a -> Mono a -> Stereo a
stereo (Mono l) (Mono r) = Stereo# l r

left :: Stereo a -> Mono a
left (Stereo# l _) = Mono l

right :: Stereo a -> Mono a
right (Stereo# _ r) = Mono r

flipStereo :: Stereo a -> Stereo a
flipStereo (Stereo# l r) = Stereo# r l

instance Functor Mono where
  map f (Mono x) = Mono (f x)

instance FunctorN Mono where
  map2 f (Mono x) (Mono y)                   = Mono (f x y)
  map3 f (Mono x) (Mono y) (Mono z)          = Mono (f x y z)
  map4 f (Mono w) (Mono x) (Mono y) (Mono z) = Mono (f w x y z)

instance Applicative Mono where
  pure x               = Mono x
  ap (Mono f) (Mono x) = Mono (f x)

instance Foldable Mono where
  fold (Mono x)      = x
  foldl f i (Mono x) = f i x

instance AudioFormat Mono where
  outAudio  n (Mono c)  w                                = outChannel n c w
  accumulate1 f isRunning (Mono c)                       = Mono (accumulateAudio1 f isRunning c)
  accumulate2 f isRunning (Mono x) (Mono y)              = Mono (accumulateAudio2 f isRunning x y)
  accumulate3 f isRunning (Mono x) (Mono y) (Mono z)     = Mono (accumulateAudio3 f isRunning x y z)
  accumulate1U mk f isRunning (Mono c)                   = Mono (accumulateAudio1U mk f isRunning c)
  accumulate2U mk f isRunning (Mono x) (Mono y)          = Mono (accumulateAudio2U mk f isRunning x y)
  accumulate3U mk f isRunning (Mono x) (Mono y) (Mono z) = Mono (accumulateAudio3U mk f isRunning x y z)
  pan (Mono amount) (Mono input)                         = Stereo# (input * (1 - amount)) (input * amount)
  mixMono x                                              = x
  mixStereo (Mono x)                                     = Stereo# x x

instance Functor Stereo where
  map f (Stereo# x y) = Stereo# (f x) (f y)

instance FunctorN Stereo where
  map2 f (Stereo# x1 x2) (Stereo# y1 y2)                                 = Stereo# (f x1 y1) (f x2 y2)
  map3 f (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2)                 = Stereo# (f x1 y1 z1) (f x2 y2 z2)
  map4 f (Stereo# w1 w2) (Stereo# x1 x2) (Stereo# y1 y2) (Stereo# z1 z2) = Stereo# (f w1 x1 y1 z1) (f w2 x2 y2 z2)

instance Applicative Stereo where
  pure x                             = Stereo# x x
  ap (Stereo# f1 f2) (Stereo# x1 x2) = Stereo# (f1 x2) (f2 x2)

instance Foldable Stereo where
  fold (Stereo# l r)      = l <> r
  foldl f i (Stereo# l r) = f (f i l) r

instance AudioFormat Stereo where
  outAudio  n (Stereo# l r) w                                                 = outChannel (n + 1) r (outChannel n l w)
  accumulate1 f isRunning (Stereo# l r)                                       = Stereo# (accumulateAudio1 f isRunning l) (accumulateAudio1 f isRunning r)
  accumulate2 f isRunning (Stereo# xl xr) (Stereo# yl yr)                     = Stereo# (accumulateAudio2 f isRunning xl yl) (accumulateAudio2 f isRunning xr yr)
  accumulate3 f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr)     = Stereo# (accumulateAudio3 f isRunning xl yl zl) (accumulateAudio3 f isRunning xr yr zr)
  accumulate1U mk f isRunning (Stereo# l r)                                   = Stereo# (accumulateAudio1U mk f isRunning l) (accumulateAudio1U mk f isRunning r)
  accumulate2U mk f isRunning (Stereo# xl xr) (Stereo# yl yr)                 = Stereo# (accumulateAudio2U mk f isRunning xl yl) (accumulateAudio2U mk f isRunning xr yr)
  accumulate3U mk f isRunning (Stereo# xl xr) (Stereo# yl yr) (Stereo# zl zr) = Stereo# (accumulateAudio3U mk f isRunning xl yl zl) (accumulateAudio3U mk f isRunning xr yr zr)
  pan (Mono amount) (Stereo# l r)                                             = Stereo# (l * (1 - amount)) (r * amount)
  mixMono (Stereo# l r)                                                       = Mono (l + r)
  mixStereo x                                                                 = x

-- Mono
instance Eq a => Eq (Mono a) where
  eq  (Mono x) (Mono y) = eq x y
  neq (Mono x) (Mono y) = neq x y

instance Semiring a => Semiring (Mono a) where
  zero                  = Mono zero
  one                   = Mono one
  add (Mono x) (Mono y) = Mono (x + y)
  mul (Mono x) (Mono y) = Mono (x * y)

instance Ring a => Ring (Mono a) where
  fromInt i             = Mono (fromInt i)
  sub (Mono x) (Mono y) = Mono (x - y)

instance EuclideanRing a => EuclideanRing (Mono a) where
  div (Mono x) (Mono y) = Mono (x / y)
  rem (Mono x) (Mono y) = Mono (rem x y)

instance DivisionRing a => DivisionRing (Mono a) where
  recip (Mono c) = Mono (recip c)

instance Num a => Num (Mono a) where
  signum (Mono c) = Mono (signum c)
  abs    (Mono c) = Mono (abs c)
  copysign (Mono x) (Mono sign) = Mono (copysign x sign)

instance Field a => Field (Mono a) where

instance Floating a => Floating (Mono a) where
  fromFloat f   = Mono (fromFloat f)
  sqrt (Mono c) = Mono (sqrt c)
  floor    (Mono x) = Mono (floor x)
  ceil     (Mono x) = Mono (ceil x)
  truncate (Mono x) = Mono (truncate x)
  round    (Mono x) = Mono (round x)
  -- fmin     (Mono x) (Mono y) = Mono (fmin x y)
  -- fmax     (Mono x) (Mono y) = Mono (fmax x y)

instance Semigroup a => Semigroup (Mono a) where
  append (Mono x) (Mono y) = Mono (append x y)

instance Monoid a => Monoid (Mono a) where
  mempty = Mono mempty

-- Stereo
instance Eq a => Eq (Stereo a) where
  eq  (Stereo# xl xr) (Stereo# yl yr) = eq xl yl && eq xr yr
  neq (Stereo# xl xr) (Stereo# yl yr) = neq xl yl || neq xr yr

instance Semiring a => Semiring (Stereo a) where
  zero                                = Stereo# zero zero
  one                                 = Stereo# one one
  add (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl + yl) (xr + yr)
  mul (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl * yl) (xr * yr)

instance Ring a => Ring (Stereo a) where
  fromInt i                           = let c = fromInt i in Stereo# c c
  sub (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl - yl) (xr - yr)

instance EuclideanRing a => EuclideanRing (Stereo a) where
  div (Stereo# xl xr) (Stereo# yl yr) = Stereo# (xl / yl) (xr / yr)
  rem (Stereo# xl xr) (Stereo# yl yr) = Stereo# (rem xl yl) (rem xr yr)

instance DivisionRing a => DivisionRing (Stereo a) where
  recip (Stereo# l r) = Stereo# (recip l) (recip r)

instance Num a => Num (Stereo a) where
  signum (Stereo# l r) = Stereo# (signum l) (signum r)
  abs    (Stereo# l r) = Stereo# (abs l) (abs r)
  copysign (Stereo# lx rx) (Stereo# ly ry) = Stereo# (copysign lx ly) (copysign rx ry)

instance Field a => Field (Stereo a) where

instance Floating a => Floating (Stereo a) where
  fromFloat f        = let c = (fromFloat f) in Stereo# c c
  sqrt (Stereo# l r) = Stereo# (sqrt l) (sqrt r)
  floor    (Stereo# l r) = Stereo# (floor l) (floor r)
  ceil     (Stereo# l r) = Stereo# (ceil l) (ceil r)
  truncate (Stereo# l r) = Stereo# (truncate l) (truncate r)
  round    (Stereo# l r) = Stereo# (round l) (round r)
  -- fmin     (Stereo# lx ry) (Stereo# ly ry) = Stereo# (fmin lx ly) (fmin ry ry)
  -- fmax     (Stereo# lx ry) (Stereo# ly ry) = Stereo# (fmax lx ly) (fmax ry ry)

instance Semigroup a => Semigroup (Stereo a) where
  append (Stereo# xl xr) (Stereo# yl yr)  = Stereo# (append xl yl) (append xr yr)

instance Monoid a => Monoid (Stereo a) where
  mempty = Stereo# mempty mempty


--------------------
-- UGens
--------------------

--------------------
-- downsample oversampled audio
sinc :: Float -> Float
sinc x =
  if x > -0.000001 && x < 0.000001 then 1.0 else
    sine x / x

bessel :: Float -> Float
bessel x =
  add 1 <| snd'<|
    loop (#i, sum#) = (#1, 0#) while i < 10 do
      let
        xpow = pow (x / 2) (fromUInt i)
        fac  =
          fromUInt <| snd' <|
            loop (#j, fac'#) = (#1, 1#) while j <= i do
              (#j + 1, fac' * j#)
      in
        (#i + 1, sum + pow (xpow / fac) 2#)

kaiserBesselWindowFunction :: Float -> Float -> Float -> Float
kaiserBesselWindowFunction i windowSize beta =
  window
  where
    warg   = beta * sqrt (1 - pow (((2 * i + 2) - windowSize) / windowSize) 2)
    window = bessel warg / bessel beta

hannWindowFunction :: Float -> Float -> Float
hannWindowFunction i windowSize =
  0.5 - (0.5 * cosine (tau * (i + 1) / windowSize))

hammingWindowFunction :: Float -> Float -> Float
hammingWindowFunction i windowSize =
  0.54 - (0.46 * cosine (tau * (i + 1) / windowSize))

nuttallBlackmanWindowFunction :: Float -> Float -> Float
nuttallBlackmanWindowFunction i windowSize =
  0.355768 -
  (0.487396 * cosine ((2.0 * pi * i) / windowSize)) +
  (0.144232 * cosine ((4.0 * pi * i) / windowSize)) -
  (0.012604 * cosine ((6.0 * pi * i) / windowSize))

downsampleCoefficients :: Array 32 Float
downsampleCoefficients =
  freezeArray coeff3
  where
    windowSize = 32
    freqCutoff = 20000
    omega      = freqCutoff / (audioSampleRateF * fromUInt audioOverSampleAmount)
    coeff1     =
      loop a = unsafeEmptyArray () for i <- each do
        let
          iReal       = fromUInt (indexToUInt i)
          iOffset     = iReal - ((windowSize - 1) / 2)
          window      = kaiserBesselWindowFunction iReal windowSize 3
          coefficient = omega * sinc (omega * iOffset * pi) * window
        in
          writeArray i coefficient a
    (#gainSum, coeff2#) =
      loop (#sum, a0#) = (#0, coeff1#) for i <- each do
        case readArrayU i a0 of
          (#x, a1#) ->
            (#sum + x, a1#)
    gainAdjust = 1.25 -- (1 / gainSum) * (1 / windowSize)
    coeff3     =
      loop a0 = coeff2 for i <- each do
        case readArrayU i a0 of
          (#x, a1#) ->
            writeArray i (x * gainAdjust) a1

-----------
-- saw

-- Oversampling saw wave, Some reading:
--   * PHASESHAPING OSCILLATOR ALGORITHMS FOR MUSICAL SOUND SYNTHESIS:
--       https://eprints.maynoothuniversity.ie/4100/1/SMC2010.pdf
--   * Antialiasing Oscillators in Subtractive Synthesis
--   * Audible Aliasing Distortion in Digital Audio Synthesis
--       https://www.researchgate.net/publication/268382833_Audible_Aliasing_Distortion_in_Digital_Audio_Synthesis

data OverSampleSawState = OverSampleSawState# Float UInt (.Array 32 Float)

mkOverSampleSawState :: () -> *OverSampleSawState
mkOverSampleSawState _ = OverSampleSawState# 0 0 (arrayFrom 0)

-- -- TODO: Replace FIR filter with IIR filter?
-- -- Oversampling saw oscillator, with FIR downsampling
-- accumulateSawFIR :: Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulateSawFIR freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 63)) (fma (phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 63)) (fma (phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 63)) (fma (phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 63)) (fma (phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 63)) (fma (phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 63)) (fma (phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 63)) (fma (phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 63)) (fma (phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 63, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 64 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 63)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 63)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 63)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 63)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 63)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 63)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 63)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 63)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 63, d8, firResult#)
--
-- sawFIR :: AudioFormat f => f Audio -> f Audio
-- sawFIR freq =
--   accumulate1U mkOverSampleSawState accumulateSawFIR constTrue' freq

data OverSampleSawStateIIR = OverSampleSawStateIIR# Float Float Float Float Float

instance Default OverSampleSawStateIIR where
  default = OverSampleSawStateIIR# 0 0 0 0 0

-- TODO: Port to using highShelf
-- TODO: fneg

-- Brickwall filter constants
ffreqBrickWall = 20000
gainBrickWall  = -28
slopeBrickWall = 1
bigaBrickWall  = pow 10 (gainBrickWall / 40)
omegaBrickWall = ffreqBrickWall * audioRecipOverSampleRate * tau
csoBrickWall   = cosine omegaBrickWall
alphaBrickWall = sine omegaBrickWall * 0.5 * sqrt (((bigaBrickWall + (1 / bigaBrickWall)) * ((1 / slopeBrickWall) - 1)) + 2)
betaBrickWall  = 2 * sqrt bigaBrickWall * alphaBrickWall

-- -- Oversampling saw wave with IIR brickwall filter
-- -- TODO: Upsample frequency?!?!!?
-- accumulateSaw :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateSaw freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (phase1 - floor phase1) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (phase2 - floor phase2) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (phase3 - floor phase3) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (phase4 - floor phase4) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (phase5 - floor phase5) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (phase6 - floor phase6) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (phase7 - floor phase7) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (phase8 - floor phase8) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)

-- saw :: AudioFormat f => f Audio -> f Audio
-- saw freq =
--   accumulate1 accumulateSaw constTrue freq

-----------
-- eptr saw
--
-- Alias-Suppressed Oscillators Based on Differentiated Polynomial Waveforms:
--   https://www.researchgate.net/publication/224557976_Alias-Suppressed_Oscillators_Based_on_Differentiated_Polynomial_Waveforms
--
-- IMPROVED POLYNOMIAL TRANSITION REGIONS ALGORITHM FORALIAS-SUPPRESSED SIGNAL SYNTHESIS:
--   http://home.mit.bme.hu/~bank/publist/smc13.pdf

-- NOTE: Fix up the negative frequency case!
accumulateSawEPTR :: Float -> Float -> (#Float, Float#)
accumulateSawEPTR freq phase0 =
  if freq > 0 && phase1 > 1 - t then
    let
      phaseOut = phase1 - 2
      oscOut   = phase1 - (phase1 / t) + (1 / t) - 1
    in
      (#phaseOut, oscOut#)
  else if freq < 0 && phase1 < -1 - t then
    let
      phase2   = 0 - phase1
      t2       = 0 - t
      phaseOut = phase1 + 2
      oscOut   = 0 - (phase2 - (phase2 / t2) + (1 / t2) - 1)
    in
      (#phaseOut, oscOut#)
  else
    (#phase1, phase1#)
  where
    t      = freq * recipSampleRate
    phase1 = fma 2 t phase0

saw :: AudioFormat f => f Audio -> f Audio
saw freq =
  accumulate1 accumulateSawEPTR constTrue freq

-----------
-- lfSaw
accumulateLFSaw :: Float -> Float -> (#Float, Float#)
accumulateLFSaw freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    out    = fma phase2 2 -1

lfSaw :: AudioFormat f => f Audio -> f Audio
lfSaw freq =
  accumulate1 accumulateLFSaw constTrue freq

-----------
-- pulse

-- -- Oversampling pulse oscillator, with FIR downsampling
-- accumulatePulseFIR :: Float -> Float -> *OverSampleSawState -> (#*OverSampleSawState, Float#)
-- accumulatePulseFIR width freq (OverSampleSawState# phaseIn downsampleIndexIn downsampleBufferIn) =
--   (#OverSampleSawState# phase downsampleIndex downsampleBuffer, firResult#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     (#_, phase, downsampleIndex1, downsampleBuffer1#) =
--       loop (#i, phase0, di, d0#) = (#0, phaseIn, downsampleIndexIn, downsampleBufferIn#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           d1      = writeArray (Index (bitAnd (di + 0) 31)) (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) d0
--           phase2  = freqDelta + phase1
--           d2      = writeArray (Index (bitAnd (di + 1) 31)) (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) d1
--           phase3  = freqDelta + phase2
--           d3      = writeArray (Index (bitAnd (di + 2) 31)) (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) d2
--           phase4  = freqDelta + phase3
--           d4      = writeArray (Index (bitAnd (di + 3) 31)) (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) d3
--           phase5  = freqDelta + phase4
--           d5      = writeArray (Index (bitAnd (di + 4) 31)) (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) d4
--           phase6  = freqDelta + phase5
--           d6      = writeArray (Index (bitAnd (di + 5) 31)) (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) d5
--           phase7  = freqDelta + phase6
--           d7      = writeArray (Index (bitAnd (di + 6) 31)) (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) d6
--           phase8  = freqDelta + phase7
--           d8      = writeArray (Index (bitAnd (di + 7) 31)) (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) d7
--         in
--           (#i + 8, phase8, bitAnd (di + 8) 31, d8#)
--     (#_, downsampleIndex, downsampleBuffer, firResult#) =
--       loop (#i, di, d0, firResult0#) = (#0, downsampleIndex1, downsampleBuffer1, 0#) while i < 32 do
--         let
--           (#s1, d1#) = readArrayU (Index (bitAnd (di + 0) 31)) d0
--           firResult1 = s1 * readArray (Index i) downsampleCoefficients
--           (#s2, d2#) = readArrayU (Index (bitAnd (di + 1) 31)) d1
--           firResult2 = s2 * readArray (Index (i + 1)) downsampleCoefficients
--           (#s3, d3#) = readArrayU (Index (bitAnd (di + 2) 31)) d2
--           firResult3 = s3 * readArray (Index (i + 2)) downsampleCoefficients
--           (#s4, d4#) = readArrayU (Index (bitAnd (di + 3) 31)) d3
--           firResult4 = s4 * readArray (Index (i + 3)) downsampleCoefficients
--           (#s5, d5#) = readArrayU (Index (bitAnd (di + 4) 31)) d4
--           firResult5 = s5 * readArray (Index (i + 4)) downsampleCoefficients
--           (#s6, d6#) = readArrayU (Index (bitAnd (di + 5) 31)) d5
--           firResult6 = s6 * readArray (Index (i + 5)) downsampleCoefficients
--           (#s7, d7#) = readArrayU (Index (bitAnd (di + 6) 31)) d6
--           firResult7 = s7 * readArray (Index (i + 6)) downsampleCoefficients
--           (#s8, d8#) = readArrayU (Index (bitAnd (di + 7) 31)) d7
--           firResult8 = s8 * readArray (Index (i + 7)) downsampleCoefficients
--           firResult  = firResult0 + firResult1 + firResult2 + firResult3 + firResult4 + firResult5 + firResult6 + firResult7 + firResult8
--         in
--           (#i + 8, bitAnd (di + 8) 31, d8, firResult#)

-- Oversampling pulse oscillator, with FIR downsampling
accumulatePulseFIR :: Float -> Float -> Float -> (#Float, Float#)
accumulatePulseFIR width freq phaseIn =
  (#phase, out#)
  where
    freqDelta = freq * audioRecipOverSampleRate
    (#_, phase, out#) =
      loop (#i, phase0, out0#) = (#0, phaseIn, 0#) while i < 32 do
        let
          phase1  = freqDelta + phase0
          out1    = fma (fma (fromInt <| boolToInt <| gt width <| phase1 - floor phase1) 2 -1) (readArray (Index i) downsampleCoefficients) out0
          phase2  = freqDelta + phase1
          out2    = fma (fma (fromInt <| boolToInt <| gt width <| phase2 - floor phase2) 2 -1) (readArray (Index i) downsampleCoefficients) out1
          phase3  = freqDelta + phase2
          out3    = fma (fma (fromInt <| boolToInt <| gt width <| phase3 - floor phase3) 2 -1) (readArray (Index i) downsampleCoefficients) out2
          phase4  = freqDelta + phase3
          out4    = fma (fma (fromInt <| boolToInt <| gt width <| phase4 - floor phase4) 2 -1) (readArray (Index i) downsampleCoefficients) out3
          phase5  = freqDelta + phase4
          out5    = fma (fma (fromInt <| boolToInt <| gt width <| phase5 - floor phase5) 2 -1) (readArray (Index i) downsampleCoefficients) out4
          phase6  = freqDelta + phase5
          out6    = fma (fma (fromInt <| boolToInt <| gt width <| phase6 - floor phase6) 2 -1) (readArray (Index i) downsampleCoefficients) out5
          phase7  = freqDelta + phase6
          out7    = fma (fma (fromInt <| boolToInt <| gt width <| phase7 - floor phase7) 2 -1) (readArray (Index i) downsampleCoefficients) out6
          phase8  = freqDelta + phase7
          out8    = fma (fma (fromInt <| boolToInt <| gt width <| phase8 - floor phase8) 2 -1) (readArray (Index i) downsampleCoefficients) out7
        in
          (#i + 8, phase8, out8#)

-- pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
-- pulse width freq =
--   accumulate2 accumulatePulseFIR constTrue width freq

-----------
-- Oversampling saw wave with IIR brickwall filter

b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
ra0       = 1 / a0

accumulatePulse :: Float -> Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
accumulatePulse width freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
  (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, fma (negate y1Out) 2 -1#)
  where
    freqDelta = freq * audioRecipOverSampleRate
    (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
      loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
        let
          phase1  = freqDelta + phase0
          in1     = fromInt (boolToInt (gt width (phase1 - floor phase1)))
          out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
          phase2  = freqDelta + phase1
          in2     = fromInt (boolToInt (gt width (phase2 - floor phase2)))
          out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
          phase3  = freqDelta + phase2
          in3     = fromInt (boolToInt (gt width (phase3 - floor phase3)))
          out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
          phase4  = freqDelta + phase3
          in4     = fromInt (boolToInt (gt width (phase4 - floor phase4)))
          out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
          phase5  = freqDelta + phase4
          in5     = fromInt (boolToInt (gt width (phase5 - floor phase5)))
          out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
          phase6  = freqDelta + phase5
          in6     = fromInt (boolToInt (gt width (phase6 - floor phase6)))
          out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
          phase7  = freqDelta + phase6
          in7     = fromInt (boolToInt (gt width (phase7 - floor phase7)))
          out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
          phase8  = freqDelta + phase7
          in8     = fromInt (boolToInt (gt width (phase8 - floor phase8)))
          out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
        in
          (#i + 8, phase8, in8, in7, out8, out7#)

-- pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
-- pulse width freq =
--   accumulate2 accumulatePulse constTrue width freq

-----------
-- eptr pulse
-- IMPROVED POLYNOMIAL TRANSITION REGIONS ALGORITHM FOR ALIAS-SUPPRESSED SIGNAL SYNTHESIS:
--   http://home.mit.bme.hu/~bank/publist/smc13.pdf

data PulseState = PulseState# Float UInt

instance Default PulseState where
  default = PulseState# -1 0

generalizedCorrectEPT :: Float -> Float -> Float -> Float -> Float -> Float
generalizedCorrectEPT p t a pmin pmax =
  p +
  ((invRange/(2 * a * t)) * p) +
  (invRange/2) +
  ((invRange * invRange) / (4 * a * t))
  where
    invRange = pmin - pmax

-- p + ((-2 / (2 * a * t)) * p) + -1 + (4 / (4 * a * t))

pulseCorrectEPT :: Float -> Float -> Float -> Float
pulseCorrectEPT p t a =
  p + ((-2 / (2 * a * t)) * p) + -1 + (4 / (4 * a * t))

-- TODO: Negative freq arg support!
accumulatePulseEPTR :: Float -> Float -> PulseState -> (#PulseState, Float#)
accumulatePulseEPTR width freq (PulseState# phase0 dir) =
  if dir == 0 then
    let
      w      = width * 2
      t      = 2 * freq * recipSampleRate
      phase1 = t + phase0
      a      = w
    in
      if phase1 > w - t then
        (#PulseState# (phase1 - w) 1, fma (generalizedCorrectEPT phase1 t a 0 1) 2 -1#)
      else
        (#PulseState# phase1 0, 1#)
  else
    let
      w      = (1 - width) * 2
      t      = 2 * freq * recipSampleRate
      phase1 = t + phase0
      a      = w
    in
      if phase1 > w - t then
        (#PulseState# (phase1 - w) 0, fma (0 - generalizedCorrectEPT phase1 t a 0 1) 2 -1#)
      else
        (#PulseState# phase1 1, -1#)

pulse :: AudioFormat f => f Audio -> f Audio -> f Audio
pulse width freq =
  accumulate2 accumulatePulseEPTR constTrue width freq


-----------
-- lfPulse
accumulateLFPulse :: Float -> Float -> Float -> (#Float, Float#)
accumulateLFPulse width freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    out    = fma (fromInt (boolToInt (phase2 > width))) 2 -1

lfPulse :: AudioFormat f => f Audio -> f Audio -> f Audio
lfPulse width freq =
  accumulate2 accumulateLFPulse constTrue width freq

-- -----------
-- -- Oversampling saw wave with IIR brickwall filter
-- accumulateTri :: Float -> OverSampleSawStateIIR -> (#OverSampleSawStateIIR, Float#)
-- accumulateTri freq (OverSampleSawStateIIR# phaseIn x1In x2In y1In y2In) =
--   (#OverSampleSawStateIIR# phaseOut x1Out x2Out y1Out y2Out, negate y1Out#)
--   where
--     freqDelta = freq * audioRecipOverSampleRate
--     b0        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall)
--     b1        = -2 * bigaBrickWall * ((bigaBrickWall - 1) + ((bigaBrickWall + 1) * csoBrickWall))
--     b2        = bigaBrickWall * ((bigaBrickWall + 1) + ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall)
--     a0        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) + betaBrickWall
--     a1        = 2 * ((bigaBrickWall - 1) - ((bigaBrickWall + 1) * csoBrickWall))
--     a2        = (bigaBrickWall + 1) - ((bigaBrickWall - 1) * csoBrickWall) - betaBrickWall
--     ra0       = 1 / a0
--     (#_, phaseOut, x1Out, x2Out, y1Out, y2Out#) =
--       loop (#i, phase0, inZ1, inZ2, outZ1, outZ2#) = (#0, phaseIn, x1In, x2In, y1In, y2In#) while i < audioOverSampleAmount do
--         let
--           phase1  = freqDelta + phase0
--           in1     = fma (abs (fma (phase1 - floor phase1) 2 -1)) 2 -1
--           out1    = 0 - (fma b0 in1 (fma b1 inZ1 (fma b2 inZ2 (fma a1 outZ1 (a2 * outZ2)))) * ra0)
--           phase2  = freqDelta + phase1
--           in2     = fma (abs (fma (phase2 - floor phase2) 2 -1)) 2 -1
--           out2    = 0 - (fma b0 in2 (fma b1 in1 (fma b2 inZ1 (fma a1 out1 (a2 * outZ1)))) * ra0)
--           phase3  = freqDelta + phase2
--           in3     = fma (abs (fma (phase3 - floor phase3) 2 -1)) 2 -1
--           out3    = 0 - (fma b0 in3 (fma b1 in2 (fma b2 in1 (fma a1 out2 (a2 * out1)))) * ra0)
--           phase4  = freqDelta + phase3
--           in4     = fma (abs (fma (phase4 - floor phase4) 2 -1)) 2 -1
--           out4    = 0 - (fma b0 in4 (fma b1 in3 (fma b2 in2 (fma a1 out3 (a2 * out2)))) * ra0)
--           phase5  = freqDelta + phase4
--           in5     = fma (abs (fma (phase5 - floor phase5) 2 -1)) 2 -1
--           out5    = 0 - (fma b0 in5 (fma b1 in4 (fma b2 in3 (fma a1 out4 (a2 * out3)))) * ra0)
--           phase6  = freqDelta + phase5
--           in6     = fma (abs (fma (phase6 - floor phase6) 2 -1)) 2 -1
--           out6    = 0 - (fma b0 in6 (fma b1 in5 (fma b2 in4 (fma a1 out5 (a2 * out4)))) * ra0)
--           phase7  = freqDelta + phase6
--           in7     = fma (abs (fma (phase7 - floor phase7) 2 -1)) 2 -1
--           out7    = 0 - (fma b0 in7 (fma b1 in6 (fma b2 in5 (fma a1 out6 (a2 * out5)))) * ra0)
--           phase8  = freqDelta + phase7
--           in8     = fma (abs (fma (phase8 - floor phase8) 2 -1)) 2 -1
--           out8    = 0 - fma b0 in8 (fma b1 in7 (fma b2 in6 (fma a1 out7 (a2 * out6)))) * ra0
--         in
--           (#i + 8, phase8, in8, in7, out8, out7#)
--
-- tri' :: AudioFormat f => f Audio -> f Audio
-- tri' freq =
--   accumulate1 accumulateTri constTrue freq

-----------
-- lfTri
accumulateLFTri :: Float -> Float -> (#Float, Float#)
accumulateLFTri freq phase0 =
  (#phase1, out#)
  where
    phase1 = fma freq recipSampleRate phase0
    phase2 = phase1 - floor phase1
    saw    = fma phase2 2 -1
    out    = fma (abs saw) 2 -1

tri :: AudioFormat f => f Audio -> f Audio
tri freq =
  accumulate1 accumulateLFTri constTrue freq

-----------
-- perc
data PercState = PercState# Float Float Float Float

mkPercState :: Float -> Float -> Float -> Float -> Float -> () -> *PercState
mkPercState level endLevel length curve currTime _ =
  PercState# a2 b1 grow currTime
  where
    length' = length * audioSampleRateF
    b1      = (endLevel - level) / (1 - exp curve)
    a2      = level + b1
    grow    = exp (curve / length')

accumulatePerc :: (#Float, Float, Float, Float#) -> Float -> *PercState -> (#*PercState, Float#)
accumulatePerc (#attackTime, decayTime, totalTime, curve#) input (PercState# a20 b10 grow0 currTime0) =
  (#PercState# a2 b12 grow currTime, out#)
  where
    currTime1 = currTime0 + recipSampleRate
    PercState# a2 b1 grow currTime =
      if currTime1 > attackTime && currTime0 <= attackTime then
        mkPercState (a20 - b10) 0 decayTime curve currTime1 ()
      else if currTime1 > totalTime then
        PercState# 0 0 0 currTime1
      else
        PercState# a20 b10 grow0 currTime1
    b12   = b1 * grow
    level = a2 - b12
    out   = level * input

percIsRunning :: Float -> *PercState -> (#*PercState, Bool#)
percIsRunning totalTime (PercState# a2 b1 grow currTime) =
  (#PercState# a2 b1 grow currTime, currTime < totalTime#)

perc :: AudioFormat f => Float -> Float -> Float -> f Audio -> f Audio
perc attackTime decayTime curve input =
  accumulate1U mk update isRunning input
  where
    totalTime = attackTime + decayTime
    mk        = mkPercState 0 1 attackTime curve 0
    update    = accumulatePerc (#attackTime, decayTime, totalTime, curve#)
    isRunning = percIsRunning totalTime

-----------
-- Wave tables

data WaveTable = WaveTable (Array 65536 Float)

sinTable :: WaveTable
sinTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (sine ((fromInt (uintToInt i) / 65536) * tau)) a

cosTable :: WaveTable
cosTable =
  WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
    case ix of
      Index i ->
        writeArray ix (cosine ((fromInt (uintToInt i) / 65536) * tau)) a

-- sinhTable :: WaveTable
-- sinhTable =
--   WaveTable <| freezeArray <| loop a = unsafeEmptyArray () for ix <- each do
--     case ix of
--       Index i ->
--         writeArray ix (sinh ((fromInt (uintToInt i) / 65536) * tau)) a

-- TODO: Accumulator will grow very large, reducing precision?
-- TODO: need ceil
accumulateWaveTable :: WaveTable -> Float -> Float -> (#Float, Float#)
accumulateWaveTable (WaveTable buffer) freq phase0 =
  (#phase1, out#)
  where
    phase1  = fma freq recipSampleRate phase0
    findex  = phase1 * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer
    out     = sample1 * delta + sample2 * (1 - delta)

wave :: AudioFormat f => WaveTable -> f Audio -> f Audio
wave buffer freq =
  accumulate1 (accumulateWaveTable buffer) constTrue freq

sin :: AudioFormat f => f Audio -> f Audio
sin freq = wave sinTable freq


-----------
-- Sync

-- TODO: default instance instead of accumulate3U
data SyncState = SyncState# Float Float Float

mkSyncState :: () -> *SyncState
mkSyncState _ = SyncState# 0 1 1

-- Kick Sync
accumulateSyncSaw :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncSaw sync kick freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    posSync = fromInt <| boolToInt <| (prevSync <= 0 && sync > 0)
    negSync = fromInt <| boolToInt <| (prevSync >= 0 && sync < 0)
    delta   = freq * recipSampleRate
    kicks   = posSync * kick + negSync * negate kick
    phase1  = delta + phase0 + kicks
    phase2  = phase1 - floor phase1
    out     = fma phase2 2.0 -1.0

syncSaw :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncSaw sync kickAmount freq =
  accumulate3U mkSyncState accumulateSyncSaw constTrue' sync kickAmount freq

-- Reverse sync
accumulateSyncTri :: Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncTri sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    phase2     = phase1 - floor phase1
    saw        = fma phase2 2.0 -1.0
    out        = fma (abs saw) 2.0 -1.0

syncTri :: AudioFormat f => f Audio -> f Audio -> f Audio
syncTri sync freq =
  accumulate2U mkSyncState accumulateSyncTri constTrue' sync freq

-- TODO: Branchless
-- Hard Sync
accumulateSyncPulse :: Float -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncPulse sync width freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction0 sync, out#)
  where
    phase1  =
      if prevSync <= 0 && sync > 0 then
        0
      else if prevSync >= 0 && sync < 0 then
        width
      else
        fma freq recipSampleRate phase0
    phase2  = phase1 - floor phase1
    out     = fma (fromInt (boolToInt (phase2 >= width))) 2.0 (-1.0)

syncPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
syncPulse sync width freq =
  accumulate3U mkSyncState accumulateSyncPulse constTrue' sync width freq

-- Reverse Sync
accumulateSyncWave :: WaveTable -> Float -> Float -> *SyncState -> (#*SyncState, Float#)
accumulateSyncWave (WaveTable buffer) sync freq (SyncState# phase0 direction0 prevSync) =
  (#SyncState# phase1 direction1 sync, out#)
  where
    change     = fromInt <| boolToInt <| ((prevSync <= 0 && sync > 0) || (prevSync >= 0 && sync < 0))
    direction1 = change * (negate direction0) + (1 - change) * direction0
    phase1     = fma freq (recipSampleRate * direction1) phase0
    findex     = phase1 * 65536
    delta      = (floor findex + 1) - findex
    index1     = bitAnd (floatToUInt findex) 65535
    index2     = bitAnd (index1 + 1) 65535
    sample1    = readArray (Index index1) buffer
    sample2    = readArray (Index index2) buffer
    out        = sample1 * delta + sample2 * (1 - delta)

syncWave :: AudioFormat f => WaveTable -> f Audio -> f Audio -> f Audio
syncWave buffer sync freq =
  accumulate2U mkSyncState (accumulateSyncWave buffer) constTrue' sync freq

syncSin :: AudioFormat f => f Audio -> f Audio -> f Audio
syncSin sync freq = syncWave sinTable sync freq


-----------
-- Super Osc
-- Based on Roland JP-8000 super saw oscillator design
data SuperSawState = SuperSawState# Float Float Float Float Float Float Float

-- TODO: Make default instance for SuperSawState instead of relying on accumulate3U, now that init weirdness has been fixed
mkSuperSawState :: () -> *SuperSawState
mkSuperSawState _ = SuperSawState# 0.260786585 0.087023334 0.866947809 0.392499353 0.728213602 0.122864975 0.167605335

accumulateSuperSaw :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperSaw freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (phaseA1 - floor phaseA1) 2 -1 * sideMix
    oscB    = fma (phaseB1 - floor phaseB1) 2 -1 * sideMix
    oscC    = fma (phaseC1 - floor phaseC1) 2 -1 * sideMix
    oscD    = fma (phaseD1 - floor phaseD1) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (phaseE1 - floor phaseE1) 2 -1 * sideMix
    oscF    = fma (phaseF1 - floor phaseF1) 2 -1 * sideMix
    oscG    = fma (phaseG1 - floor phaseG1) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: Turns out floor is faster than fastFloor???
superSaw :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superSaw freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperSaw constTrue' freq depth mix

accumulateSuperPulse :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperPulse freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    width   = 0.5 -- need accumulate4U to make this another parameter
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (fromInt <| boolToInt <| (phaseA1 - floor phaseA1) > width) 2 -1 * sideMix
    oscB    = fma (fromInt <| boolToInt <| (phaseB1 - floor phaseB1) > width) 2 -1 * sideMix
    oscC    = fma (fromInt <| boolToInt <| (phaseC1 - floor phaseC1) > width) 2 -1 * sideMix
    oscD    = fma (fromInt <| boolToInt <| (phaseD1 - floor phaseD1) > width) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (fromInt <| boolToInt <| (phaseE1 - floor phaseE1) > width) 2 -1 * sideMix
    oscF    = fma (fromInt <| boolToInt <| (phaseF1 - floor phaseF1) > width) 2 -1 * sideMix
    oscG    = fma (fromInt <| boolToInt <| (phaseG1 - floor phaseG1) > width) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: Turns out floor is faster than fastFloor???
superPulse :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superPulse freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperPulse constTrue' freq depth mix

accumulateSuperTri :: Float -> Float -> Float -> *SuperSawState -> (#*SuperSawState, Float#)
accumulateSuperTri freq depth mix (SuperSawState# phaseA0 phaseB0 phaseC0 phaseD0 phaseE0 phaseF0 phaseG0) =
  (#SuperSawState# phaseA1 phaseB1 phaseC1 phaseD1 phaseE1 phaseF1 phaseG1, out#)
  where
    freqA   = freq * (fma depth -0.11002313 1)
    freqB   = freq * (fma depth -0.06288439 1)
    freqC   = freq * (fma depth -0.01952356 1)
    freqD   = freq
    freqE   = freq * (fma depth 0.01991221 1)
    freqF   = freq * (fma depth 0.06216538 1)
    freqG   = freq * (fma depth 0.10745242 1)
    phaseA1 = fma freqA recipSampleRate phaseA0
    phaseB1 = fma freqB recipSampleRate phaseB0
    phaseC1 = fma freqC recipSampleRate phaseC0
    phaseD1 = fma freqD recipSampleRate phaseD0
    phaseE1 = fma freqE recipSampleRate phaseE0
    phaseF1 = fma freqF recipSampleRate phaseF0
    phaseG1 = fma freqG recipSampleRate phaseG0
    sideMix = mix * 0.5
    oscA    = fma (abs (fma (phaseA1 - floor phaseA1) 2 -1)) 2 -1 * sideMix
    oscB    = fma (abs (fma (phaseB1 - floor phaseB1) 2 -1)) 2 -1 * sideMix
    oscC    = fma (abs (fma (phaseC1 - floor phaseC1) 2 -1)) 2 -1 * sideMix
    oscD    = fma (abs (fma (phaseD1 - floor phaseD1) 2 -1)) 2 -1 * (1 - mix * 0.75)
    oscE    = fma (abs (fma (phaseE1 - floor phaseE1) 2 -1)) 2 -1 * sideMix
    oscF    = fma (abs (fma (phaseF1 - floor phaseF1) 2 -1)) 2 -1 * sideMix
    oscG    = fma (abs (fma (phaseG1 - floor phaseG1) 2 -1)) 2 -1 * sideMix
    out     = oscA + oscB + oscC + oscD + oscE + oscF + oscG

-- NOTE: Turns out floor is faster than fastFloor???
superTri :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
superTri freq depth mix =
  accumulate3U mkSuperSawState accumulateSuperPulse constTrue' freq depth mix

-----------
-- delay
data DelayState s = DelayState# (.AudioBuffer s) UInt Float

natSecondsToNatBufferSamples :: Seconds n -> NatVal (NatNextPowerOfTwo (NatMul SampleRate (NatMax n 1)))
natSecondsToNatBufferSamples _ = NatVal

-- TODO: Interpolate delayTime!
-- TODO: delay playback speed? Reverse delay? delay bank etc?
-- TODO: initialDelayTime, maxDelayTime, audioBufferSize, etc

accumulateDelay :: UInt -> Float -> Float -> Float -> *DelayState s -> (#*DelayState s, Float#)
accumulateDelay bufferSizeMinus1 targetDelayTime mix input (DelayState# (AudioBuffer buffer0) index delayTime) =
  (#DelayState# (AudioBuffer buffer2) index' delayTime', out#)
  where
    delayTime'       = targetDelayTime
    delayIndex       = bitAnd (index + floatToUInt (delayTime' * audioSampleRateF)) bufferSizeMinus1
    (#del, buffer1#) = readArrayU (Index index) buffer0
    out              = input * (1 - mix) + del * mix
    buffer2          = writeArray (Index delayIndex) out buffer1
    index'           = bitAnd (index + 1) bufferSizeMinus1

mkDelayState :: Seconds s -> () -> *DelayState s
mkDelayState _ _ = DelayState# (AudioBuffer (arrayFrom 0)) 0 1

delay :: AudioFormat f => Seconds n -> f Audio -> f Audio -> f Audio -> f Audio
delay maxDelayTime delayTime mix input =
  accumulate3U (mkDelayState maxDelayTime) (accumulateDelay (natVal (natSecondsToNatBufferSamples maxDelayTime) - 1)) (\s -> (#s, True#)) delayTime mix input

oneSec :: Seconds 1
oneSec = Seconds

twoSec :: Seconds 2
twoSec = Seconds

threeSec :: Seconds 3
threeSec = Seconds

fourSec :: Seconds 4
fourSec = Seconds

fiveSec :: Seconds 5
fiveSec = Seconds

-----------
-- RBJ Filters, Audio EQ Cookbook

data BiquadState = BiquadState# Float Float Float Float

instance Default BiquadState where
  default = BiquadState# 0 0 0 0

-- TODO: Optimize out transcendental functions

-- fi range: 0 - 1
waveTableFunction :: WaveTable -> Float -> Float
waveTableFunction (WaveTable buffer) fi =
  sample1 * delta + sample2 * (1 - delta)
  where
    findex  = fi * 65536
    delta   = (floor findex + 1) - findex
    index1  = bitAnd (floatToUInt findex) 65535
    index2  = bitAnd (index1 + 1) 65535
    sample1 = readArray (Index index1) buffer
    sample2 = readArray (Index index2) buffer

-----------
-- lpf
accumulateLPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 - cso) * 0.5
    b1    =  1 - cso
    b2    = (1 - cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

lpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
lpf freq q input =
  accumulate3 accumulateLPF constTrue freq q input

-----------
-- hpf
accumulateHPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = (1 + cso) * 0.5
    b1    = negate (1 + cso)
    b2    = (1 + cso) * 0.5
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

hpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
hpf freq q input =
  accumulate3 accumulateHPF constTrue freq q input

-----------
-- bpf
accumulateBPF :: Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateBPF freq q x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * q * 0.5
    b0    = alpha
    b1    = 0
    b2    = negate alpha
    a0    =  1 + alpha
    a1    = -2 * cso
    a2    =  1 - alpha
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

bpf :: AudioFormat f => f Audio -> f Audio -> f Audio -> f Audio
bpf freq q input =
  accumulate3 accumulateBPF constTrue freq q input

-----------
-- lowShelf
accumulateLowShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateLowShelf slope freq gain x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    biga  = pow 10 (gain / 40)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) - ((biga - 1) * cso) + beta)
    b1    = 2 * biga * ((biga - 1) - ((biga + 1) * cso))
    b2    = biga * ((biga + 1) - ((biga - 1) * cso) - beta)
    a0    = (biga + 1) + ((biga - 1) * cso) + beta
    a1    = -2 * ((biga - 1) + ((biga + 1) * cso))
    a2    = (biga + 1) + ((biga - 1) * cso) - beta
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

lowShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
lowShelf freq gain slope input =
  accumulate3 (accumulateLowShelf slope) constTrue freq gain input

-----------
-- highShelf
accumulateHighShelf :: Float -> Float -> Float -> Float -> BiquadState -> (#BiquadState, Float#)
accumulateHighShelf slope freq gain x0 (BiquadState# x1 x2 y1 y2) =
  (#BiquadState# x0 x1 (negate y0) y1, y0#)
  where
    biga  = pow 10 (gain / 40)
    omega = freq * recipSampleRate
    cso   = waveTableFunction cosTable omega
    alpha = waveTableFunction sinTable omega * 0.5 * sqrt (((biga + (1 / biga)) * ((1 / slope) - 1)) + 2)
    beta  = 2 * sqrt biga * alpha
    b0    = biga * ((biga + 1) + ((biga - 1) * cso) + beta)
    b1    = -2 * biga * ((biga - 1) + ((biga + 1) * cso))
    b2    = biga * ((biga + 1) + ((biga - 1) * cso) - beta)
    a0    = (biga + 1) - ((biga - 1) * cso) + beta
    a1    = 2 * ((biga - 1) - ((biga + 1) * cso))
    a2    = (biga + 1) - ((biga - 1) * cso) - beta
    y0    =
      fma b0 x0 (fma b1 x1 (fma b2 x2 (fma a1 y1 (a2 * y2)))) * (1 / a0)

highShelf :: AudioFormat f => f Audio -> f Audio -> Float -> f Audio -> f Audio
highShelf freq gain slope input =
  accumulate3 (accumulateHighShelf slope) constTrue freq gain input


--------------------
-- Seq
--------------------
data SeqControl = SeqEnd | SeqBlockEnd | SeqNormal | SeqLoopEnd | SeqPure
data SeqValue a = SeqValue# Rational SeqControl (Maybe a)
data Seq a      = Seq (() -> SeqValue a)

mergeSeqValueTimes :: Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes xt xc yt yc =
  case xc of
    SeqPure -> yt
    _ ->
      case yc of
        SeqPure -> xt
        _       -> min xt yt

mergeSeqValueTimes3 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes3 xt xc yt yc zt zc =
  case xc of
    SeqPure -> mergeSeqValueTimes yt yc zt zc
    _ ->
      case yc of
        SeqPure -> mergeSeqValueTimes xt xc zt zc
        _       ->
          case zc of
            SeqPure -> mergeSeqValueTimes xt xc yt yc
            _       -> min (min xt yt) zt

mergeSeqValueTimes4 :: Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational -> SeqControl -> Rational
mergeSeqValueTimes4 wt wc xt xc yt yc zt zc =
  case wc of
    SeqPure -> mergeSeqValueTimes3 xt xc yt yc zt zc
    _       ->
      case xc of
        SeqPure -> mergeSeqValueTimes3 wt wc yt yc zt zc
        _ ->
          case yc of
            SeqPure -> mergeSeqValueTimes3 wt wc xt xc zt zc
            _       ->
              case zc of
                SeqPure -> mergeSeqValueTimes3 wt wc xt xc yt yc
                _       -> min (min (min wt xt) yt) zt

instance Enum SeqControl where
  toEnum n =
    case n of
      0 -> SeqEnd
      1 -> SeqBlockEnd
      2 -> SeqNormal
      3 -> SeqLoopEnd
      _ -> SeqPure
  fromEnum s =
    case s of
      SeqEnd      -> 0
      SeqBlockEnd -> 1
      SeqNormal   -> 2
      SeqLoopEnd  -> 3
      SeqPure     -> 4

instance Semigroup SeqControl where
  append x y =
    if lt (fromEnum x) (fromEnum y) then
      x
    else
      y

instance Monoid SeqControl where
  mempty = SeqPure

instance Eq SeqControl where
  eq  x y = fromEnum x == fromEnum y
  neq x y = fromEnum x /= fromEnum y

seqControlFromEnumAlt :: SeqControl -> Int
seqControlFromEnumAlt s =
  case s of
    SeqNormal   -> 0
    SeqLoopEnd  -> 1
    SeqPure     -> 2
    SeqBlockEnd -> 3
    SeqEnd      -> 4

seqControlAlternative :: SeqControl -> SeqControl -> SeqControl
seqControlAlternative x y =
  if lt (seqControlFromEnumAlt x) (seqControlFromEnumAlt y) then
    x
  else
    y

instance Functor SeqValue where
  map f (SeqValue# t c x) =
    SeqValue# t c (map f x)

instance FunctorN SeqValue where
  map2 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (xc <> yc) (map2 f xv yv)
  map3 f (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes3 xt xc yt yc zt zc) (xc <> yc <> zc) (map3 f xv yv zv)
  map4 f (SeqValue# wt wc wv) (SeqValue# xt xc xv) (SeqValue# yt yc yv) (SeqValue# zt zc zv) =
    SeqValue# (mergeSeqValueTimes4 wt wc xt xc yt yc zt zc) (wc <> xc <> yc <> zc) (map4 f wv xv yv zv)

instance Applicative SeqValue where
  pure x = SeqValue# 1 SeqPure (Just x)
  ap (SeqValue# ft fc fv) (SeqValue# xt xc xv) =
    SeqValue# (mergeSeqValueTimes xt xc ft fc) (fc <> xc) (ap fv xv)

instance Semigroup a => Semigroup (SeqValue a) where
  append (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (append xc yc) (append xv yv)

instance Monoid (SeqValue a) where
  mempty = SeqValue# 1 SeqPure nothing

instance Alternative SeqValue where
  empty = SeqValue# 1 SeqEnd nothing
  alternative (SeqValue# xt xc xv) (SeqValue# yt yc yv) =
    SeqValue# (mergeSeqValueTimes xt xc yt yc) (seqControlAlternative xc yc) (alternative xv yv)

instance Default (SeqValue a) where
  default = SeqValue# 1 SeqPure nothing

instance Eq a => Eq (SeqValue a) where
  eq  (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt == yt && xc == tc && xv == yv
  neq (SeqValue# xt xc xv) (SeqValue# yt tc yv) = xt /= yt || xc /= tc || xv /= yv

instance Semiring a => Semiring (SeqValue a) where
  zero    = SeqValue# 1 SeqPure (Just zero)
  one     = SeqValue# 1 SeqPure (Just one)
  add x y = map2 add x y
  mul x y = map2 mul x y

instance Ring a => Ring (SeqValue a) where
  sub x y   = map2 sub x y
  fromInt i = SeqValue# 1 SeqPure (Just (fromInt i))

instance EuclideanRing a => EuclideanRing (SeqValue a) where
  div x y = map2 div x y
  rem x y = map2 rem x y

instance DivisionRing a => DivisionRing (SeqValue a) where
  recip x = map recip x

instance Num a => Num (SeqValue a) where
  signum x  = map signum x
  abs x     = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (SeqValue a) where

instance Floating a => Floating (SeqValue a) where
  fromFloat f = SeqValue# 1 SeqPure (Just (fromFloat f))
  sqrt f      = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x
  -- fmin      x y = map2 fmin x y
  -- fmax      x y = map2 fmax x y

runSeq :: Seq a -> () -> SeqValue a
runSeq (Seq stepFunc) _ = stepFunc ()

runSeq2 :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeq2 sx sy =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv#) ->
          let
            t = min xt yt
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
          in
            (#x, y#)

runSeq3 :: Seq a -> Seq b -> Seq c -> (#SeqValue a, SeqValue b, SeqValue c#)
runSeq3 sx sy sz =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min xt yt) zt
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz () else SeqValue# (zt - t) zc zv
          in
            (#x, y, z#)

runSeq4 :: Seq a -> Seq b -> Seq c -> Seq d -> (#SeqValue a, SeqValue b, SeqValue c, SeqValue d#)
runSeq4 sw sx sy sz =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# wt wc wv, SeqValue# xt xc xv, SeqValue# yt yc yv, SeqValue# zt zc zv#) ->
          let
            t = min (min (min wt xt) yt) zt
            w = if wt <= t then runSeq sw () else SeqValue# (wt - t) wc wv
            x = if xt <= t then runSeq sx () else SeqValue# (xt - t) xc xv
            y = if yt <= t then runSeq sy () else SeqValue# (yt - t) yc yv
            z = if zt <= t then runSeq sz () else SeqValue# (zt - t) zc zv
          in
            (#w, x, y, z#)

seqValueDuration :: SeqValue a -> Rational
seqValueDuration (SeqValue# t _ _) = t

seqValueControl :: SeqValue a -> SeqControl
seqValueControl (SeqValue# _ c _) = c

runSeqOnLeft :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnLeft ls rs =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc _, SeqValue# rt rc rv#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue# (lt - t) lc nothing
            r = if rt <= t then runSeq rs () else SeqValue# (rt - t) rc rv
          in
            (#l, r#)

runSeqOnRight :: Seq a -> Seq b -> (#SeqValue a, SeqValue b#)
runSeqOnRight ls rs =
  acc
  where
    acc ~ (#SeqValue# 0 SeqNormal Nothing, SeqValue# 0 SeqNormal Nothing#) =
      case acc of
        (#SeqValue# lt lc lv, SeqValue# rt rc _#) ->
          let
            t = min lt rt
            l = if lt <= t then runSeq ls () else SeqValue# (lt - t) lc lv
            r = if rt <= t then runSeq rs () else SeqValue# (rt - t) rc nothing
          in
          (#l, r#)

instance Functor Seq where
  map f s = Seq (\_ -> map f (runSeq s ()))

instance Applicative Seq where
  pure x   = Seq (\_ -> pure x)
  ap fs xs = Seq (\_ -> ap (runSeq fs ()) (runSeq xs ()))

instance FunctorN Seq where
  map2 f sx sy       = Seq (\_ -> let (#x, y#)       = runSeq2 sx sy       in map2 f x y)
  map3 f sx sy sz    = Seq (\_ -> let (#x, y, z#)    = runSeq3 sx sy sz    in map3 f x y z)
  map4 f sw sx sy sz = Seq (\_ -> let (#w, x, y, z#) = runSeq4 sw sx sy sz in map4 f w x y z)

instance Eq a => Eq (Seq a) where
  eq  sx sy = let (#x, y#) = runSeq2 sx sy in x == y
  neq sx sy = let (#x, y#) = runSeq2 sx sy in x == y

instance Semiring a => Semiring (Seq a) where
  zero      = Seq (\_ -> pure zero)
  one       = Seq (\_ -> pure one)
  add sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 add x y)
  mul sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 mul x y)

instance Ring a => Ring (Seq a) where
  sub sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 sub x y)
  fromInt i = Seq (\_ -> pure (fromInt i))

instance EuclideanRing a => EuclideanRing (Seq a) where
  div sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 div x y)
  rem sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in map2 rem x y)

instance DivisionRing a => DivisionRing (Seq a) where
  recip x = Seq (\_ -> map recip (runSeq x ()))

instance Num a => Num (Seq a) where
  signum x  = map signum x
  abs x     = map abs x
  copysign x sign = map2 copysign x sign

instance Field a => Field (Seq a) where

instance Floating a => Floating (Seq a) where
  fromFloat f = Seq (\_ -> pure (fromFloat f))
  sqrt f = map sqrt f
  floor     x = map floor x
  ceil      x = map ceil x
  truncate  x = map truncate x
  round     x = map round x
  -- fmin      x y = map2 fmin x y
  -- fmax      x y = map2 fmax x y

instance Semigroup (Seq a) where
  append sx sy = [sx sy]

instance Monoid (Seq a) where
  mempty = Seq (\_ -> SeqValue# 1 SeqPure nothing)

instance Alternative Seq where
  empty             = Seq (\_ -> SeqValue# 1 SeqPure nothing)
  alternative sx sy = Seq (\_ -> let (#x, y#) = runSeq2 sx sy in alternative x y)

-- TODO: <|>

-- Biased BinOps
-- +@  @+  +
-- -@  @-  -
-- *@  @*  *
-- /@  @/  /
-- <@  @< @<@
-- >@  @> @>@

-- TODO:
-- %@ @%

leftConst :: a -> b -> a
leftConst x _ = x

rightConst :: a -> b -> b
rightConst _ y = y

addSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
addSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 add l r)

addSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
addSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 add l r)

subSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
subSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 sub l r)

subSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
subSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 sub l r)

mulSeqOnLeft :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 mul l r)

mulSeqOnRight :: Num a => Seq a -> Seq a -> Seq a
mulSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 mul l r)

divSeqOnLeft :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 div l r)

divSeqOnRight :: EuclideanRing a => Seq a -> Seq a -> Seq a
divSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 div l r)

leftConstSeqOnLeft :: Seq a -> Seq b -> Seq a
leftConstSeqOnLeft ls _ = ls

leftConstSeqOnRight :: Seq a -> Seq b -> Seq a
leftConstSeqOnRight ls rs = Seq (\_ -> let (#l, r#) = runSeqOnRight ls rs in map2 leftConst l r)

rightConstSeqOnLeft :: Seq a -> Seq b -> Seq b
rightConstSeqOnLeft ls rs = Seq (\_ -> let (#l, r#) = runSeqOnLeft ls rs in map2 rightConst l r)

rightConstSeqOnRight :: Seq a -> Seq b -> Seq b
rightConstSeqOnRight _ rs = rs

leftConstSeqOnBoth :: Seq a -> Seq b -> Seq a
leftConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 leftConst l r)

rightConstSeqOnBoth :: Seq a -> Seq b -> Seq b
rightConstSeqOnBoth ls rs = Seq (\_ -> let (#l, r#) = runSeq2 ls rs in map2 rightConst l r)

-- addSeqOnLeftTest :: Seq Int
-- addSeqOnLeftTest =
--   [1 _ <2 3>] @+ [4 <5 6> <7 8 9>] *@ [1 2 _ 5] @- <3 4 5> @> fromInt mouseX

-- mouseBeat :: Seq Float
-- mouseBeat = fromInt mouseX <@ coolBeat

-- addSeqOnRightTest :: SeqValue Int
-- addSeqOnRightTest = runSeq (rightConstSeqOnLeft 1 2) ()

restSeqValue :: SeqValue a
restSeqValue =
  SeqValue# 1 SeqPure nothing

rest :: Seq a
rest =
  Seq (\_ -> restSeqValue)

seqValueDurationMul :: Rational -> SeqValue a -> SeqValue a
seqValueDurationMul speed (SeqValue# t c v) =
  SeqValue# (t * speed) c v

seqSpeed :: Rational -> Seq a -> Seq a
seqSpeed speed seq =
  Seq (\_ -> seqValueDurationMul (recip speed) (runSeq seq ()))

bpm :: Int -> Rational
bpm tempoInBPM =
  tempoInBPM // 60

toSeq :: SeqValue a -> Seq a
toSeq sv =
  Seq (\_ -> sv)

seqLoopEndIfLastSlot :: Int -> Int -> SeqControl
seqLoopEndIfLastSlot slot maxSlot =
  if (slot + 1) < maxSlot then
    SeqNormal
  else
    SeqLoopEnd

-- Combining nested case statements with case literals seems to break...
slotTick :: Int -> Int -> SeqControl -> SeqValue a -> (#Int, SeqValue a#)
slotTick slot maxSlot controlIfNotNormal sv =
  case sv of
    SeqValue# t c v ->
      case c of
        SeqNormal -> (#slot, sv#)
        _         -> (#(slot + 1) % maxSlot, SeqValue# t controlIfNotNormal v#)

seqTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
seqTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) sv

tupleTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
tupleTick slot maxSlot sv =
  slotTick slot maxSlot (seqLoopEndIfLastSlot slot maxSlot) (seqValueDurationMul (1 // maxSlot) sv)

interleaveTick :: Int -> Int -> SeqValue a -> (#Int, SeqValue a#)
interleaveTick slot maxSlot sv =
  slotTick slot maxSlot SeqLoopEnd sv


--------------------
-- Print
--------------------

instance Print a => Print (Array n a) where
  print a w =
    loop w' = w for i <- each do
      print (readArray i a) w'

instance Print Bool where
  print x w =
    case x of
      True -> print "True" w
      _    -> print "False" w

instance Print Rational where
  print (Rational# n d) w =
    print '(' w |> print n |> print " // " |> print d |> print ')'

instance Print a => Print (Maybe a) where
  print mx w =
    case mx of
      Nothing -> print '_' w
      Just x  -> print x w

instance Print a => Print (SeqValue a) where
  print (SeqValue# t _ v) w =
    print '(' w
    |> print t
    |> print ':'
    |> print v
    |> print ')'

printBarOnLoop :: SeqControl -> *World -> *World
printBarOnLoop c w =
  case c of
    SeqLoopEnd -> print '|' w |> print ' '
    _          -> w

instance Print a => Print (Seq a) where
  print s w = wout
    where
      tick ~ 0       = tick + audioBlockDelta
      (#_, _, wout#) =
        loop (#cont, time, w'#) = (#True, 0, w#) while cont do
          let nextValueTime ~ 0 = nextValueTime + time in
            if nextValueTime >= tick then
              (#False, 0, w'#)
            else
              case runSeq s () of
                SeqValue# t c mx ->
                  case mx of
                    Just x -> (#True, t, print x w' |> print ' ' |> printBarOnLoop c#)
                    _      -> (#True, t, printBarOnLoop c w'#)

instance Print Audio where
  print c w =
    case c of
      AudioEnd    -> print "AudioEnd" w
      BlockRate x -> print "BlockRate " w |> print x
      AudioRate b ->
        print '}' <| loop w' = (print '{' w) for i <- each do
          print (readArray i b) w' |> print ',' |> print ' '

instance Print a => Print (Mono a) where
  print (Mono c) w = print c w

instance Print a => Print (Stereo a) where
  print (Stereo# l r) w = print l (print ',' (print r w))

instance Print Complex where
  print (Complex# r i) w =
    print '(' w
    |> print r
    |> print " + i"
    |> print i
    |> print ')'

instance Print (FFT k) where
  print (FFT c) w =
    print "FFT [" w
    |> printNewline
    |> printNewline
    |> print c
    |> print ']'
    |> printNewline

  -- foldp :: (b -> a -> b) -> f a -> b

-- -- Switch to case expressions!
-- Looks like we have a nested case statement bug going on here, probably happening in mach_transform.c or mach_case.c???
-- instance Foldable Seq where
--   fold s = out
--     where
--       tick ~ 0      = tick + 1
--       (#_, _, out#) =
--         loop (#cont, time, acc#) = (#True, 0, mempty#) while cont do
--           let nextValueTime ~ 0 = nextValueTime + time in
--             if nextValueTime >= tick then (#False, 0, acc#) else
--               case runSeq s () of
--                 SeqNil   t _ -> (#True, t, acc#)
--                 SeqValue t x -> (#True, t, acc <> x#)
--
--   foldl f init s =
--     case out of
--       (#_, _, accOut#) -> accOut
--     where
--       out ~ (#0, 0, mempty#) =
--         case out of
--           (#tick', time', _#) ->
--             loop (#tick, time, acc#) = (#tick' + 1, time', init#) while time < tick do
--               case runSeq s () of
--                 SeqNil   t _ -> (#tick, time + t, acc#)
--                 SeqValue t x -> (#tick, time + t, f acc x#)
--   foldp f s =
--     acc'
--     where
--       (#tick' ~ 0, time' ~ 0, acc' ~ mempty#) =
--         loop (#tick, time, acc#) = (#tick' + 1, time', acc'#) while time < tick do
--           case runSeq s () of
--             SeqValue# t _ (Just x) -> (#tick, time + t, f acc x#)
--             SeqValue# t _ _        -> (#tick, time + t, acc#)
--
-- Seq laws:
-- Should expect to not be called again until the duration amount has passed

-- seqOne :: Seq Int
-- seqOne = x + y
--   where
--     x = 1 * 2
--     y = 3 + 4

-- foldSeqTest1 :: Int
-- foldSeqTest1 = fold seqOne

-- foldSeqTest :: Int
-- -- foldSeqTest = fold 0 + foldl sub 0 44 * foldp mul 33
-- foldSeqTest = fold seqOne + foldl sub 0 seqOne * foldp mul seqOne

-- foldPrint :: *World -> *World
-- foldPrint w = foldl (flip printInt) w 33

-- seqTest :: Seq Float
-- -- seqTest :: Seq Int
-- seqTest =
--   [0 _ 1 2] + [<3 4> _ <5 6> <7 8 9>]

-- seqTestGo :: SeqValue Float
-- seqTestGo =
--   runSeq seqTest ()

-- notAnInt :: Seq Float
-- notAnInt = 2 / 3

-- doubleTrouble :: SeqValue Int
-- doubleTrouble =
--   runSeq (2 * <33 44 <0 _ 1 2>>) ()

-- appendSeq :: Seq a -> Seq a -> Seq a
-- appendSeq x y = [x y]

-- appendGo :: SeqValue Rational
-- appendGo = runSeq (appendSeq 1 2) ()


----------------------
-- DynArray
----------------------
data PolyThunkState = PolyThunkAlloc | PolyThunkInit | PolyThunkEval
data PolyThunk a    = PolyThunk# (Ptr .()) (Ptr .()) a PolyThunkState Float
-- UpdateState, CopyState, Arg, ThunkState, SampleOffset

data DynTier      a = DynTier# UInt UInt UInt (Ptr (.PolyThunk a))
data DynArray     a = DynArray# (.DynTier a) (.DynTier a)
data DynTierIndex   = DynTierLow | DynTierHigh
data DynArrayIndex  = DynArrayIndex# DynTierIndex UInt

-- dynTierTrace :: *DynTier a -> *DynTier a
-- dynTierTrace (DynTier# cap count hwm ptr) =
--   DynTier# cap count hwm ptr
--   |> trace "    DynTier { cap: "
--   |> trace cap
--   |> trace ", count: "
--   |> trace count
--   |> trace ", hwm: "
--   |> trace hwm
--   |> traceLn " }"

-- dynArrayTrace :: Array n Char -> *DynArray a -> *DynArray a
-- dynArrayTrace opName (DynArray# low high) =
--   let low'  = dynTierTrace <| traceLn "  {" <| traceLn "  DynArray " <| traceLn opName low in
--   let high' = traceLn " " <| traceLn "  }" <| dynTierTrace high in
--   DynArray# low' high'

dynArrayIndexEmpty :: DynArrayIndex
dynArrayIndexEmpty = DynArrayIndex# DynTierLow 0

dynTierEmpty :: UInt -> *DynTier a
dynTierEmpty capacity =
  DynTier# capacity 0 0 (ptrMalloc capacity)

dynArrayEmpty :: UInt -> *DynArray a
dynArrayEmpty capacity =
  DynArray# (dynTierEmpty 0) (dynTierEmpty capacity)

dynTierSwapToEndAndDelete :: UInt -> *DynTier a -> *DynTier a
dynTierSwapToEndAndDelete index (DynTier# capacity count highWaterMark ptr) =
  if index >= capacity then
    DynTier# capacity count highWaterMark ptr
  else if index == (count - 1) then
    DynTier# capacity (count - 1) highWaterMark ptr
  else
    case unsafePtrSwapElement index primUndefined ptr of
      (#indexElement, ptr2#) ->
        case unsafePtrSwapElement (count - 1) indexElement ptr2 of
          (#endElement, ptr3#) ->
            DynTier# capacity (count - 1) highWaterMark (unsafePtrPoke index endElement ptr3)

-- NOTE: This assumes that the tier is correctly sized!
dynTierAppend :: *PolyThunk a -> *DynTier a -> *DynTier a
dynTierAppend element (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > count then
    case unsafePtrSwapElement count element ptr of
      (#hwmElement, ptr'#) ->
        DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr')
  else
    DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke count element ptr)

  -- |> trace "dynTierAppend, capacity: "
  -- |> trace capacity
  -- |> trace ", count: "
  -- |> traceLn count

data DynTierPromotePopResult a = DynTierPromotePopEmpty | DynTierPromotePopLive (.PolyThunk a) | DynTierPromotePopInactive (.PolyThunk a)
dynTierPromotePop :: *DynTier a -> (#*DynTierPromotePopResult a, *DynTier a#)
dynTierPromotePop (DynTier# capacity count highWaterMark ptr) =
  if highWaterMark > 0 && highWaterMark > count && highWaterMark <= capacity then
    case unsafePtrSwapElement (highWaterMark - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopInactive element, DynTier# capacity count (highWaterMark - 1) ptr'#)
  else if count > 0 && count <= capacity then
    case unsafePtrSwapElement (count - 1) primUndefined ptr of
      (#element, ptr'#) ->
        (#DynTierPromotePopLive element, DynTier# capacity (count - 1) (count - 1) ptr'#)
  else
    (#DynTierPromotePopEmpty, DynTier# capacity count highWaterMark ptr#)

-- TODO: Nested case branching seems broken!?!?!?
dynArrayPromoteElement :: *DynArray a -> *DynArray a
dynArrayPromoteElement (DynArray# low (DynTier# capacity count highWaterMark ptr)) =
  case dynTierPromotePop low of
    (#m, low'#) ->
      case m of
        DynTierPromotePopEmpty ->
          DynArray# low' (DynTier# capacity count highWaterMark ptr)

        DynTierPromotePopInactive element ->
          DynArray# low' (DynTier# capacity count (highWaterMark + 1) (unsafePtrPoke highWaterMark element ptr))

        DynTierPromotePopLive element ->
          case unsafePtrSwapElement count element ptr of
            (#hwmElement, ptr'#) ->
              DynArray# low' (DynTier# capacity (count + 1) (highWaterMark + 1) (unsafePtrPoke highWaterMark hwmElement ptr'))

-- NOTE: This assumes that the low tier has been completely moved to the high tier
dynArrayResize :: *DynArray a -> *DynArray a
dynArrayResize (DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)) =
  if highCount < highCapacity && hhwm < highCapacity then
    DynArray# (DynTier# lcap lcount lhwm lowPtr) (DynTier# highCapacity highCount hhwm highPtr)
  else
    let
      newCap  = highCapacity * 2
      newLow  = DynTier# highCapacity highCount hhwm highPtr
      newHigh = DynTier# newCap 0 0 (ptrRealloc newCap lowPtr)
    in
      DynArray# newLow newHigh

dynArrayAppend :: *PolyThunk a -> *DynArray a -> *DynArray a
dynArrayAppend element (DynArray# low high) =
  DynArray# low (dynTierAppend element high)

dynTierModifyElement :: UInt -> (*PolyThunk a -> *PolyThunk a) -> *DynTier a -> *DynTier a
dynTierModifyElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    DynTier# capacity count highWaterMark ptr0
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element, ptr1#) ->
        DynTier# capacity count highWaterMark (unsafePtrPoke index (f element) ptr1)

data DynArrayResult a = DynArrayEnd | DynArrayNothing | DynArrayJust a

dynTierWithElement :: UInt -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynTier a -> (#Maybe b, *DynTier a#)
dynTierWithElement index f (DynTier# capacity count highWaterMark ptr0) =
  if index >= count then
    (#Nothing, DynTier# capacity count highWaterMark ptr0#)
  else
    case unsafePtrSwapElement index primUndefined ptr0 of
      (#element0, ptr1#) ->
        case f element0 of
          (#result, element1#) ->
            (#Just result, DynTier# capacity count highWaterMark (unsafePtrPoke index element1 ptr1)#)

dynArrayWithElement :: DynArrayIndex -> (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArray a -> (#DynArrayResult b, *DynArray a#)
dynArrayWithElement (DynArrayIndex# tier index) f (DynArray# low high) =
  case tier of
    DynTierLow ->
      case dynTierWithElement index f low of
        (#result, low'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low' high#)
            _            -> (#DynArrayNothing, DynArray# low' high#)
    DynTierHigh ->
      case dynTierWithElement index f high of
        (#result, high'#) ->
          case result of
            Just result' -> (#DynArrayJust result', DynArray# low high'#)
            _            -> (#DynArrayEnd, DynArray# low high'#)

dynArrayDelete :: DynArrayIndex -> *DynArray a -> *DynArray a
dynArrayDelete (DynArrayIndex# tier index) (DynArray# low high) =
  case tier of
    DynTierLow  -> DynArray# (dynTierSwapToEndAndDelete index low) high
    DynTierHigh -> DynArray# low (dynTierSwapToEndAndDelete index high)

dynArrayEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArray a -> *DynArray a
dynArrayEmplaceOrAppend emplaceInit appendMk (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr)) =
  if highCount < highWaterMark then
    DynArray# low (dynTierModifyElement highCount emplaceInit <| DynTier# highCapacity (highCount + 1) highWaterMark highPtr)
  else
    dynArrayAppend (appendMk ()) (DynArray# low (DynTier# highCapacity highCount highWaterMark highPtr))

data DynArrayIterator a = DynArrayIterator# DynArrayIndex (.DynArray a)

dynArrayIterator :: *DynArray a -> *DynArrayIterator a
dynArrayIterator x = DynArrayIterator# dynArrayIndexEmpty x

dynArrayIteratorEnd :: *DynArrayIterator a -> *DynArray a
dynArrayIteratorEnd (DynArrayIterator# _ array) = array

dynArrayIteratorEmplaceOrAppend :: (*PolyThunk a -> *PolyThunk a) -> (() -> *PolyThunk a) -> *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorEmplaceOrAppend emplaceInit appendMk (DynArrayIterator# _ array) =
  DynArrayIterator# dynArrayIndexEmpty <| dynArrayEmplaceOrAppend emplaceInit appendMk <| dynArrayResize <| dynArrayPromoteElement array

dynArrayIteratorWithElement :: (*PolyThunk a -> (#b, *PolyThunk a#)) -> *DynArrayIterator a -> (#DynArrayResult b, *DynArrayIterator a#)
dynArrayIteratorWithElement f (DynArrayIterator# index array) =
  case dynArrayWithElement index f array of
    (#result, array'#) ->
      (#result, DynArrayIterator# index array'#)

dynArrayIteratorNext :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorNext (DynArrayIterator# (DynArrayIndex# tier index) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))) =
  case tier of
    DynTierLow ->
      if index < lcount then
        DynArrayIterator# (DynArrayIndex# DynTierLow (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
      else
        DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
    DynTierHigh ->
      DynArrayIterator# (DynArrayIndex# DynTierHigh (index + 1)) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))

dynArrayIteratorFree :: *DynArrayIterator a -> *DynArrayIterator a
dynArrayIteratorFree (DynArrayIterator# index array) =
  case dynArrayDelete index array of
    DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr) ->
      case index of
        DynArrayIndex# tier _ ->
          case tier of
            DynTierLow ->
              if lcount > 0 then
                DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
              else
                DynArrayIterator# (DynArrayIndex# DynTierHigh 0) (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))
            DynTierHigh ->
              DynArrayIterator# index (DynArray# (DynTier# lcap lcount lhwm lptr) (DynTier# hcap hcount hhwm hptr))


--------------------
-- PolyThunks
--------------------
-- NOTE on Propagation:
--    * All Type variables are propagating
--    * In data constructors type variables are always polymorphic in uniqueness
--    * In data constructors monomorphic types default to shared uniqueness
--    * Uniqueness notation is allowed in data constructors only on monomorphic type cons
--    * Higher Kinded Types do not have uniqueness types and do not propagate uniqueness, instead Type Applications have uniqueness types associated with them and are propagating!
--    * Propagation behavior is enforced by the type of the data constructor function!
dynDeepCopy :: a -> (#Ptr *(), a#)
dynDeepCopy x =
  primUndefined

dynDeepCopyInto :: Ptr *() -> a -> (#Ptr *(), a#)
dynDeepCopyInto copyState x =
  primUndefined

polyThunkAlloc :: a -> Float -> () -> *PolyThunk a
polyThunkAlloc x sampleOffset u =
  case dynDeepCopy x of
    (#copyState, x'#) ->
      PolyThunk# primUndefined copyState x' PolyThunkAlloc sampleOffset

polyThunkInit :: a -> Float -> *PolyThunk a -> *PolyThunk a
polyThunkInit x sampleOffset (PolyThunk# updateState copyState _ _ _)  =
  case dynDeepCopyInto copyState x of
    (#copyState', x'#) ->
      PolyThunk# updateState copyState' x' PolyThunkInit sampleOffset

-- compiler magic prevents this from inlining, which is required for poly to function properly
polyThunkEvalGo :: (a -> b) -> a -> b
polyThunkEvalGo f x = f x

polyThunkEval :: (a -> b) -> *PolyThunk a -> (#b, *PolyThunk a#)
polyThunkEval f t =
  let
    dummy = polyThunkEvalGo f primUndefined
  in
    primUndefined


----------------------
-- Poly
----------------------
class Finite a where
  isRunning :: a -> Bool

class (Monoid p, Finite p) => Poly p where

instance Finite Audio where
  isRunning c =
    case c of
      AudioEnd -> False
      _        -> True

instance Finite a => Finite (Mono a) where
  isRunning (Mono x) = isRunning x

instance Finite a => Finite (Stereo a) where
  isRunning (Stereo# l r) = isRunning l && isRunning r

instance Poly Audio where
instance Poly (Mono a) where
instance Poly a => Poly (Stereo a) where

calculateAudioSampleOffset :: Rational -> Rational -> Float
calculateAudioSampleOffset valueTime tickTime =
  (fromInt n / fromInt d) * fromUInt audioBlockSize
  where
    Rational# n d =
      (valueTime - (tickTime - audioBlockDelta)) / audioBlockDelta

seqToAudio :: (AudioFormat f) => Seq Float -> f Audio
seqToAudio s =
  pure (AudioRate (freezeArray aout))
  where
    (#_, aout#) =
      loop (#i0, a#) = (#audioSampleOffset, audioInitArray ()#) while i0 < audioBlockSize do
        let
          i1        = i0 + 1
          time ~ 0  = time + audioSampleDelta
          value ~ 0 =
            thd3' <| loop (#cont, seqDuration0, prevValue#) = (#True, 0, value#) while cont do
              let
                nextValueTime ~ 0 = nextValueTime + seqDuration0
              in
                if nextValueTime >= time then (#False, 0, prevValue#) else
                  case runSeq s () of
                    SeqValue# seqDuration1 _ msv ->
                      case msv of
                        Just seqValue -> (#True, seqDuration1, seqValue#)
                        Nothing       -> (#True, seqDuration1, prevValue#)
        in
          (#i1, writeArray (Index i0) (fromFloat value) a#)

poly :: Poly b => (a -> b) -> Seq a -> b
poly f s =
  case mutRefTake (\_ -> dynArrayEmpty 8) of
    (#thunks0, mref#) ->
      let
        tick ~ 0                = tick + audioBlockDelta
        (#_, _, acc', thunks4#) =
          loop (#cont, time, acc, thunks1#) = (#True, 0, mempty, dynArrayIterator thunks0#) while cont do
            let nextValueTime ~ 0 = nextValueTime + time in
              if nextValueTime < tick then
                case runSeq s () of
                  SeqValue# t _ mx ->
                    case mx of
                      Just x  -> (#True, t, acc, dynArrayIteratorEmplaceOrAppend (polyThunkInit x (calculateAudioSampleOffset nextValueTime tick)) (polyThunkAlloc x (calculateAudioSampleOffset nextValueTime tick)) thunks1#)
                      Nothing -> (#True, t, acc, thunks1#)
              else
                case dynArrayIteratorWithElement (polyThunkEval f) thunks1 of
                  (#maybeEvalResult, thunks2#) ->
                    case maybeEvalResult of
                      DynArrayJust evalResult ->
                        if isRunning evalResult then
                          (#True, 0, append acc evalResult, dynArrayIteratorNext thunks2#)
                        else
                          (#True, 0, acc, dynArrayIteratorFree thunks2#)
                      DynArrayNothing -> (#True,  0, acc, dynArrayIteratorNext thunks2#)
                      DynArrayEnd     -> (#False, 0, acc, thunks2#)
      in
        case mutRefPut (dynArrayIteratorEnd thunks4) mref of
          _ -> acc'

poly2 :: Poly c => (a -> b -> c) -> Seq a -> Seq b -> c
poly2 f x y = poly (uncurry' f) (map2 (\x' y' -> (#x', y'#)) x y)

poly3 :: Poly d => (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> d
poly3 f x y z = poly (uncurry3' f) (map3 (\x' y' z' -> (#x', y', z'#)) x y z)


----------------------
-- MinBLEP
--
-- Hard Sync Without Aliasing:
--   http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf
--
-- ExperimentalScene article on MinBLEPs with nice code examples
-- https://www.experimentalscene.com/articles/minbleps.php
----------------------

data MinBlepBuffer z o = MinBlepBuffer (.Array (NatMul (NatMul z 2) o) Float)
data MinBlepFFT    z o = MinBlepFFT (.Array (NatMul (NatMul z 2) o) Complex)

-- Slow n' dirty fft
minBlepFFT :: UInt -> MinBlepFFT z o -> *MinBlepFFT z o
minBlepFFT n (MinBlepFFT signal) =
  MinBlepFFT bins1
  where
    rn    = fromUInt n
    bins0 =
      loop b = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# 0 0) b
    bins1 = snd' <|
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = negate (sine p)
                (#Complex# fr fi, b3#) = readArrayU (Index k) b2
                Complex# xr xi         = readArray (Index i) signal
                yr                     = fr + ((xr * sr) - (xi * si))
                yi                     = fi + ((xr * si) + (xi * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          (#k + 1, b4#)

-- Slow n' dirty ifft
minBlepIFFT :: UInt -> MinBlepFFT z o -> MinBlepFFT z o
minBlepIFFT n (MinBlepFFT freqDomain) =
  MinBlepFFT <| freezeArray bins1
  where
    rn    = fromUInt n
    bins0 =
      loop b = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# 0 0) b
    bins1 = snd' <|
      loop (#k, b1#) = (#0, bins0#) while k < n do
        let
          b4 = snd' <|
            loop (#i, b2#) = (#0, b1#) while i < n do
              let
                p                      = (2 * pi * fromUInt k * fromUInt i) / rn
                sr                     = cosine p
                si                     = negate (sine p)
                (#Complex# fr fi, b3#) = readArrayU (Index k) b2
                Complex# xr xi         = readArray (Index i) freqDomain
                yr                     = fr + ((xr * sr) + (xi * si))
                yi                     = fi + ((xr * si) - (xi * sr))
              in
                (#i + 1, writeArray (Index k) (Complex# yr yi) b3#)
        in
          case readArrayU (Index k) b4 of
            (#Complex# xr xi, b5#) ->
              (#k + 1, writeArray (Index k) (Complex# (xr * rn) (xi * rn)) b5#)

-- Compute real cepstrum
minBlepCepstrum :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepCepstrum n (MinBlepBuffer signal) =
  MinBlepBuffer <| freezeArray realCepstrum
  where
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        writeArray i (Complex# (readArray i signal) 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          lcabs                   = log (sqrt ((xr * xr) + (xi * xi)))
          c                       = Complex# lcabs 0
        in
          writeArray i c fd1

    realCepstrum =
      loop rc = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) rc

-- Minimum phase reconstruction
minBlepMinimumPhase :: UInt -> MinBlepBuffer z o -> MinBlepBuffer z o
minBlepMinimumPhase n (MinBlepBuffer realCepstrum) =
  MinBlepBuffer <| freezeArray minimumPhase
  where
    n2                    = n / 2
    MinBlepFFT freqDomain = minBlepFFT n <| MinBlepFFT <| freezeArray <|
      loop td = unsafeEmptyArray () for i <- each do
        if indexToUInt i == 0 then
          writeArray i (Complex# (readArray i realCepstrum) 0) td
        else if indexToUInt i < n2 then
          writeArray i (Complex# (readArray i realCepstrum * 2) 0) td
        else
          writeArray i (Complex# 0 0) td

    MinBlepFFT timeDomain = minBlepIFFT n <| MinBlepFFT <| freezeArray <|
      loop fd0 = freqDomain for i <- each do
        let
          (#Complex# xr xi, fd1#) = readArrayU i fd0
          rexp                    = exp xr
          c                       = Complex# (rexp * cosine xi) (rexp * sine xi)
        in
          writeArray i c fd1

    minimumPhase =
      loop mp = unsafeEmptyArray () for i <- each do
        writeArray i (realPart (readArray i timeDomain)) mp

minBlepN :: NatVal z -> NatVal o -> NatVal (NatMul (NatMul z 2) o)
minBlepN _ _ = NatVal

-- Start with z = 16, o = 32, which should create 1024 table
generateMinBLEP :: NatVal z -> NatVal o -> MinBlepBuffer z o
generateMinBLEP z o =
  MinBlepBuffer minBlep1
  where
    n            = minBlepN z o |> natVal
    rn           = fromUInt n
    b            = natVal z |> fromUInt
    a            = negate b
    windowedSinc = MinBlepBuffer <| freezeArray <|
      loop wsb = unsafeEmptyArray () for i <- each do
        let
          ri = fromUInt (indexToUInt i)
          r  = ri / (rn - 1)
          s  = (a + (r * (b - a))) * pi |> sinc
          ws = nuttallBlackmanWindowFunction ri rn * s
        in
          writeArray i ws wsb

    MinBlepBuffer minPhase = minBlepCepstrum n windowedSinc |> minBlepMinimumPhase n

    (#minBlep0, m#) =
      loop (#mb, m0#) = (#unsafeEmptyArray (), 0#) for i <- each do
        let
          m1 = m0 + readArray i minPhase
        in
          (#writeArray i m1 mb, m1#)

    rm       = 1 / m
    minBlep1 = freezeArray <|
      loop mb0 = minBlep0 for i <- each do
        let
          (#x, mb1#) = readArrayU i mb0
        in
          writeArray i (x * rm) mb1

data File = File

arrayLength :: Array n Char -> NatVal n -> UInt
arrayLength _ n = natVal n

unsafeOpenFile :: Array n Char -> UInt -> *File
unsafeOpenFile fileName fileNameLength = primUndefined

-- Polymorphic is a motherfucker
openFile :: Array n Char -> *World -> (*File, *World)
openFile fileName w =
   (unsafeOpenFile fileName (arrayLength fileName NatVal), w)

closeFile :: *File -> ()
closeFile f = primUndefined

writeIntToFile :: Int -> *File -> *File
writeIntToFile x f = primUndefined

writeUIntToFile :: UInt -> *File -> *File
writeUIntToFile x f = primUndefined

writeFloatToFile :: Float -> *File -> *File
writeFloatToFile x f = primUndefined

writeCharToFile :: Char -> *File -> *File
writeCharToFile x f = primUndefined

-- somePow :: F64
-- somePow = pow pi 5

-- testJit :: *World -> *World
-- testJit w =
--     print "halfPi: " w
--     |> printLn halfPi
--     |> print "floor halfPi: "
--     |> printLn (floor halfPi)
--     |> print "floor -halfPi: "
--     |> printLn (floor <| negate halfPi)
--     |> print "ceil halfPi: "
--     |> printLn (ceil halfPi)
--     |> print "ceil -halfPi: "
--     |> printLn (ceil <| negate halfPi)
--     |> print "truncate halfPi: "
--     |> printLn (truncate halfPi)
--     |> print "truncate -halfPi: "
--     |> printLn (truncate <| negate halfPi)
--     |> print "round halfPi: "
--     |> printLn (round halfPi)
--     |> print "round -halfPi: "
--     |> printLn (round <| negate halfPi)
--     |> print "copysign 666 halfPi: "
--     |> printLn (copysign 666 halfPi)
--     |> print "copysign 666 -halfPi: "
--     |> printLn (copysign 666 <| negate halfPi)
--     |> print "signum halfPi: "
--     |> printLn (signum halfPi)
--     |> print "signum -halfPi: "
--     |> printLn (signum <| negate halfPi)
--     |> print "floorToInt halfPi: "
--     |> printLn (floorToInt halfPi)
--     |> print "floorToInt -halfPi: "
--     |> printLn (floorToInt <| negate halfPi)
--     |> print "ceilToInt halfPi: "
--     |> printLn (ceilToInt halfPi)
--     |> print "ceilToInt -halfPi: "
--     |> printLn (ceilToInt <| negate halfPi)
--     |> print "truncateToInt halfPi: "
--     |> printLn (truncateToInt halfPi)
--     |> print "truncateToInt -halfPi: "
--     |> printLn (truncateToInt <| negate halfPi)
--     |> print "roundToInt halfPi: "
--     |> printLn (roundToInt halfPi)
--     |> print "roundToInt -halfPi: "
--     |> printLn (roundToInt <| negate halfPi)

-- copysign :: F64 -> F64 -> F64
-- fmin :: F64 -> F64 -> F64
-- fmax :: F64 -> F64 -> F64
-- floorToInt :: F64 -> Int
-- ceilToInt :: F64 -> Int
-- truncateToInt :: F64 -> Int
-- roundToInt :: F64 -> Int

-- testJit :: *World -> *World
-- testJit w = printLn "IEEE format=========================================" w
--           |> print "iEEESignMask"
-- 		  |> print " -> "
--           |> printLn iEEESignMask
--           |> print "iEEESignMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignMaskF
--           |> print "iEEEExponentMask"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMask
--           |> print "iEEEExponentMaskF"
-- 		  |> print " -> "
--           |> printLn iEEEExponentMaskF
--           |> print "iEEESignificandMask"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMask
--           |> print "iEEESignificandMaskF"
-- 		  |> print " -> "
--           |> printLn iEEESignificandMaskF
--           |> print "all bits"
-- 		  |> print " -> "
--           |> printLn allBits
--           |> print "all bits F"
-- 		  |> print " -> "
--           |> printLn allBitsF
--     where
--       allBits :: UInt
--       allBits = -1
--       allBitsF :: Float
--       allBitsF = fromBits allBits

----------------------
-- Oscillator tests
----------------------

-- TODO: alignment!?!?!? what!?!?!?
oscTest :: (Mono Audio -> Mono Audio) -> Stereo Audio
oscTest f =
  perc 10 1 3 6000 + 50
  |> f
  |> perc 5 5 -1
  |> mul 0.2
  |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest sin) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest tri) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (lfPulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (pulse 0.5 |> oscTest) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       pulse ((sin 0.2 * 0.4) + 0.5) 440
--       |> perc 5 5 -1
--       |> mul 0.1
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest lfSaw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 (oscTest saw) w

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lpf (perc 10 1 4 5000 + 330) 0.075
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> hpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf (5330 - perc 10 1 -4 5000) 0.1
--       |> perc 5 5 -1
--       |> mul 0.25
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> bpf 2000 (abs (sin 0.5 * 3) + 0.01)
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> lowShelf (5110 - perc 10 1 -4 5000) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       saw 110
--       |> highShelf (perc 10 1 -4 5000 + 220) -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     a =
--       perc 10 1 3 6000 + 50
--       |> lfSaw
--       |> highShelf 20000 -64 1
--       |> perc 5 5 -1
--       |> mul 0.125
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superSaw 440 0.1 0.7
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superPulse 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     badAudio =
--       superTri 440 0.125 0.6
--       |> perc 5 5 -1
--       |> mul 0.08
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 200 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.125 * 0.125)
--     osc  =
--       syncTri sync 200
--       |> perc 5 15 0.1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.25 * 0.125)
--     osc  =
--       syncPulse 0.66667 sync 100
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 240 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.2 * 0.35)
--     osc  =
--       syncSaw sync 0.495 80
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     sync = [1 2 5 4 1 2 7 2 <5.5 6> <8 8.5> <5.5 4.5> <1.5 0.5>] * 100 |> seqSpeed 6 |> seqToAudio |> lfPulse (0.5 + sin 0.125 * 0.125)
--     osc  =
--       syncSin sync 200
--       |> perc 5 5 -1
--       |> mul 0.2
--       |> mixStereo

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       let feed ~ 0 = syncTri feed (stereo 660 500 + sin 2.0 * 50 + sin 0.1 * -50 + (delay oneSec 0.25 0.4 <| feed * -60)) in
--       feed
--       |> delay oneSec 0.25 0.2
--       |> perc 5 20 -1
--       |> mul 0.5

-- -- TODO: Perhaps upsample freq argument to saw and pulse?
-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (10 + perc 5 20 -1 200) * perc 5 20 -1 4000)
--       |> sin
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (10 + perc 5 20 -1 200) * perc 5 20 -1 2000)
--       |> tri
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (10 + perc 5 20 -1 200) * perc 5 20 -1 300)
--       |> pulse 0.5
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 osc w
--   where
--     osc =
--       stereo 440 330 + (sin (1 + perc 5 20 -1 30) * perc 5 20 -1 4000)
--       |> saw
--       |> perc 5 20 -1
--       |> mul 0.2

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 badAudio w
--   where
--     freqMul1  = sin 0.2  *  0.0035 + sin 0.6 *  0.00025 + 0.5
--     freqMul2  = sin 0.14 *  0.0035 + sin 0.5 * -0.00025 + 0.5
--     freqMul3  = sin 0.23 * -0.0035 + sin 0.4 *  0.00025 + 0.5
--     beatSpeed = 3 // 2
--     badBeat1  = seqSpeed beatSpeed [200 _ 300 <_ 350> 200 400 _ 600 <_ [350:700]> [300:800]]
--     badBeat2  = seqSpeed beatSpeed ([400 _ 600 <_ 700> <_ 1200> [1400:1350]] @* (seqSpeed (1 // 9) [_ _ _ _ 0.25 0.5 0.75 1 1.5]))
--     badBeat3  = seqSpeed (beatSpeed / 8) [100 60 75 100 60 75 80]
--     badSynth1 f =
--       tri (fromFloat f * 0.501) + tri (fromFloat f * freqMul1 + tri 1.33334 * 3) + (sin (fromFloat f) * 0.75)
--       |> mul 0.11
--       |> perc 0.005 2.5 -3.75
--       |> pan 0.375
--     badSynth2 f =
--       tri (fromFloat f * freqMul3 * 2.02) + tri (fromFloat f * 0.998) + (pulse (freqMul1 - 0.175) (fromFloat f * freqMul2 + tri 2.0 * 3) * 0.3)
--       |> mul 0.09
--       |> perc 0.01 3.5 -2.75
--       |> pan 0.625
--     bassSynth f =
--       sin (fromFloat (f * 0.5)) + (0.5 * (tri (fromFloat f - 0.1) + tri (fromFloat f * freqMul1 * 2) + tri (fromFloat f * (1 - freqMul3)) + tri (fromFloat (f * 0.5))))
--       |> mul 0.1
--       |> perc 0.005 5 -1.8
--       |> mixStereo
--     synths =
--       poly badSynth1 badBeat1 +
--       poly badSynth2 badBeat2
--       |> delay oneSec 0.6666667 0.6
--     badAudio =
--       poly bassSynth badBeat3 +
--       synths

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
-- 		  |> printLn (bitNot one |> bitAnd (fromBits negativeBit |> bitNot))
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> bitAnd (bitNot negativeBit |> fromBits)
--     -- unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w
-- 		  |> print " -> "
--           |> print negativeBit
--           |> print " -> "
--           |> print negativeOne
--           |> print " -> "
--           |> print unNegativeOne
--           |> printLn " "
--   where
--     one :: Float
--     one = fromInt mouseX
--     negativeBit :: UInt
--     negativeBit = bitShiftLeft 1 63
--     negativeOne :: Float
--     negativeOne = bitOr (toBits one) negativeBit |> fromBits
--     allBits :: UInt
--     allBits = -1
--     unNegativeOne :: Float
--     unNegativeOne = negativeOne |> toBits |> bitAnd (bitXor allBits negativeBit) |> fromBits
--

-- bitOneOne = bitAnd (bitXor (-1) negativeBit) bitOne |> fromBits

-- testJit :: *World -> *World
-- testJit w = print one w |> print " -> " |> print bitOne |> print " -> " |> print bitOneOne |> printLn " "
--   where
--     one :: Float
--     one = 1
--     -- negativeBit :: UInt
--     -- negativeBit = bitShiftRight 1 63
--     bitOne = bitShiftLeft one 2
--     bitOneOne = bitShiftRight bitOne 2
--
-- testJit :: *World -> *World
-- testJit w = print f64 w |> print " -> " |> print rF64 |> print " -> " |> print rrF64 |> printLn " "
--   where
--     f64 :: Float
--     f64 = pi
--     rF64 = bitReverse f64
--     rrF64 = bitReverse rF64
--

-- testJit :: *World -> *World
-- testJit w =
--   outAudio 0 a w
--   where
--     s = seqToAudio <| seqSpeed 4 [3 1 2 <4 3>]
--     t = seqToAudio <| seqSpeed 2 [0.5 1 2 <4 3>]
--     a =
--       pulse 0.125 (440 * stereo s t)
--       |> mul 0.125
--       |> pan 0.5

-- testJit :: *World -> *World
-- testJit w = printLn f64 w |> printLn (bitReverse f64) |> printLn (bitReverse <| bitReverse f64)
--   where
--     f64 :: F64
--     f64 = 5

-- Chad Test!
-- testJit :: *World -> *World
-- testJit w =
-- 	print "fmouse: " w
--     |> printLn fMouse
--     |> print "fMask 1 fMouse: "
--     |> printLn fMask
--     |> print "fSelection 1 fMouse: "
--     |> printLn fSelection
--     |> print "tan -1.8125: "
--     |> printLn (tanF64 -1.8125)
--     |> print "tanF64: "
--     |> printLn (tanF64 fMouse)
--     |> print "atanF64: "
--     |> printLn (atanF64 fMouse)
--     |> print "slowAtanF64: "
--     |> printLn (slowAtanF64 fMouse)
--     |> print "atanF64 -1.8125: "
--     |> printLn (atanF64 -1.8125)
--     |> print "slowAtanF64 -1.8125 "
--     |> printLn (slowAtanF64 -1.8125)
--     |> print "tan -17000: "
--     |> printLn (tanF64 -17000)
--   where
--     fMouseRaw :: F64
--     fMouseRaw = fromInt mouseX
--     fMouse = ((fMouseRaw / 1920) - 0.5) * (4 * pi)
--     fSelection = scalarIfGreaterThan fMouse 1
--     fMask = maskIfGreaterThan fMouse 1

--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# 8 2
--     b = Complex# 2 1
--     c = sqrt (Complex# (negate 3.4) pi)
--
-- testJit :: *World -> *World
-- testJit w = printLn a w |> printLn b |> printLn c
--   where
--     a = Complex# (negate pi) 3
--     b = Complex# 3 4
--     c = a / b


-- <> => Sequence
-- [] => Tuple
-- {} => Interleave

-- tupleTest :: Seq Float
-- tupleTest =
--   <0 _ 1 2>

-- tupleTestGo :: SeqValue Float
-- tupleTestGo = runSeq tupleTest ()

-- interleaveTest :: Seq Float
-- interleaveTest =
--   [0:_:1:2]

-- interleaveTestGo :: SeqValue Float
-- interleaveTestGo = runSeq interleaveTest ()

-- -- Seq + Seq
-- seqTest1 :: Seq Float
-- seqTest1 =
--   [0 _ 1 [2 3 4]]

-- seqTest1Go :: SeqValue Float
-- seqTest1Go = runSeq seqTest1 ()

-- -- Seq + Tuple
-- seqTest2 :: Seq Float
-- seqTest2 =
--   [0 _ 1 <2 _ 4>]

-- seqTest2Go :: SeqValue Float
-- seqTest2Go = runSeq seqTest2 ()

-- -- Seq + Interleave
-- seqTest3 :: Seq Float
-- seqTest3 =
--   [0 _ 1 [2:3:4]]

-- proceduralBeat :: Seq Float
-- proceduralBeat = Seq <| \_ ->
--   let
--     tick ~ 0 = tick + 1
--     value    = tick * 100 + fromInt mouseY * fromInt mouseX
--   in
--     SeqValue# 2 SeqNormal (Just value)

-- seqTest :: Seq Float
-- seqTest =
--   [x 100 200 <300 x> [400:500]]
--   where
--     x = <30 40 <50 60 70> 80> + 3

-- coolBeat :: Seq Float
-- coolBeat =
--   [
--     x y (y+y) z
--     _ x <5 z> x
--     _ 0 <1 2> y
--   ] * 2
--   where
--     x = <0 5 <1 2> 1>
--     y = 3
--     z = fromInt mouseX * 100

-- TODO: Simultaneous synths panned in the middle cause weird FM?!?!!?!?
-- TODO: Test arg copying
-- TODO: Test shared beats, etc (NOTE: Known to assert false currently)

-- TODO: Floatx32
-- TODO: Waveterrain oscillators + mandelbulb + strange attractors + delauney triangulation
-- TODO: phase distortion synthesis
-- TODO: Fix stack overflow problem
-- TODO: 64-bit refactor apocalypse
-- TODO: Multiplication precedence is WRONG!!!!
-- TODO: Oversample sync oscs
-- TODO: Make JIT faster
-- TODO: Generic env
-- TODO: Clipping detection
-- TODO: Looks like maybe the precedence between (+) and (*) and (|>) is a little wonky?
-- TODO: https://ccrma.stanford.edu/~jos/pasp/Freeverb.html
-- TODO: uint32 -> uint64
-- TODO: Set audioSampleOffset to NOT be constant and insure that it is never used at a global scope!!!!! (It is magical...)
-- TODO: repeat combinator
-- TODO: FFT stuff
-- TODO: Nested case literals seem broken!
-- TODO: Out of order monomorphic instances (i.e. 'instance Ring Complex' textually appearing before 'instance Ring F64') can cause erroneous 'Not An Instance' errors. Maybe need a better dep analysis story to make this work since we don't figure this out until inference which is at that point too late to fix.
-- TODO: Write to log file, perhaps class Log a similar to class Print a
-- TODO: Look at all the .i.i.i weirdness in llvm names???
-- TODO: Strange Attractor / MandelBrot oscillators

-- TODO: Optimize const expr globals
-- TODO: Memory access test audio stuff!
-- TODO: type sig coerce constraint!
-- TODO: Put constant check on initializers, not in type signatures. It doesn't need to be in the type system to be checked! Then we can nix Default for Monoid?
-- TODO: FFT generated signals, pure FFT
-- TODO: Compiler breaks down when a Non-Type kinded type is used in a class declaration!
-- TODO: endAfterTick IO combinator: endAfterTick :: *World -> *World
-- TODO: Immutable and Mutable (Unique) FFT API
-- TODO: Writing audio files

-- TODO: Concept of Constant Values somehow being worked into the type system for things like default and mutRef
-- TODO: Inline compose operators! .> and <.
-- TODO: Perhaps function caching is getting off, need more accurate check for HOF caching!
-- TODO: Replace Default with Monoid?
-- TODO: Need partial recursive values to get rid of monoid here
-- TODO: Partially recursive values
-- TODO: Use List type syntax for Sequences?
-- TODO: Partially recursive values
-- TODO: Defunctionalization of function on data structures
-- TODO: Stateful Pattern assignment

-- Sound ideas
--     * Percussive simulations
--     * Strange attractors in FFT?
--     * Cool FFT effects we used: Convolution with voices, Long time stretching

